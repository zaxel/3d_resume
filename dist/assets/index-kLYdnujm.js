var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_stdin = __commonJS({
  "<stdin>"(exports, module) {
    (async () => {
      (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const n of document.querySelectorAll('link[rel="modulepreload"]')) i(n);
        new MutationObserver((n) => {
          for (const r of n) if (r.type === "childList") for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function t(n) {
          const r = {};
          return n.integrity && (r.integrity = n.integrity), n.referrerPolicy && (r.referrerPolicy = n.referrerPolicy), n.crossOrigin === "use-credentials" ? r.credentials = "include" : n.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function i(n) {
          if (n.ep) return;
          n.ep = true;
          const r = t(n);
          fetch(n.href, r);
        }
      })();
      const ph = "175", qr = {
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
      }, Gr = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
      }, ng = 0, yd = 1, rg = 2, Nf = 1, Qf = 2, _n = 3, Sn = 0, _i = 1, Yi = 2, zn = 0, Xr = 1, xd = 2, Ed = 3, vd = 4, sg = 5, cr = 100, ag = 101, og = 102, cg = 103, lg = 104, hg = 200, dg = 201, ug = 202, fg = 203, dl = 204, ul = 205, pg = 206, Ag = 207, gg = 208, _g = 209, mg = 210, wg = 211, bg = 212, yg = 213, xg = 214, fl = 0, pl = 1, Al = 2, Zr = 3, gl = 4, _l = 5, ml = 6, wl = 7, Do = 0, Eg = 1, vg = 2, Gn = 0, Sg = 1, Cg = 2, Ig = 3, Mg = 4, Tg = 5, Rg = 6, Bg = 7, Sd = "attached", Dg = "detached", Of = 300, pr = 301, $r = 302, lo = 303, bl = 304, Po = 306, mi = 1e3, fi = 1001, ho = 1002, pi = 1003, zf = 1004, Ss = 1005, Rt = 1006, io = 1007, Ji = 1008, Jt = 1009, Gf = 1010, Hf = 1011, Ns = 1012, Ah = 1013, Ar = 1014, ii = 1015, vi = 1016, gh = 1017, _h = 1018, Qs = 1020, Vf = 35902, Wf = 1021, jf = 1022, Wt = 1023, qf = 1024, Xf = 1025, Os = 1026, zs = 1027, yn = 1028, mh = 1029, hr = 1030, wh = 1031, bh = 1033, no = 33776, Ts = 33777, ro = 33778, Rs = 33779, uo = 35840, yl = 35841, fo = 35842, xl = 35843, po = 36196, Ao = 37492, go = 37496, Gs = 37808, El = 37809, vl = 37810, Sl = 37811, Hs = 37812, Cl = 37813, Il = 37814, Ml = 37815, Tl = 37816, Rl = 37817, Bl = 37818, Dl = 37819, Pl = 37820, Ll = 37821, Bs = 36492, Fl = 36494, _o = 36495, Yf = 36283, kl = 36284, Ul = 36285, Nl = 36286, Lo = 2200, Pg = 2201, Lg = 2202, Vs = 2300, Ws = 2301, tc = 2302, Hr = 2400, Vr = 2401, mo = 2402, yh = 2500, Fg = 2501, kg = 0, Kf = 1, Ql = 2, Ug = 3200, Ng = 3201, Fo = 0, Qg = 1, an = "", nt = "srgb", oi = "srgb-linear", wo = "linear", pt = "srgb", Er = 7680, Cd = 519, Og = 512, zg = 513, Gg = 514, Jf = 515, Hg = 516, Vg = 517, Wg = 518, jg = 519, Ol = 35044, Id = "300 es", xn = 2e3, bo = 2001;
      class jn {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
        }
        hasEventListener(e, t) {
          const i = this._listeners;
          return i === void 0 ? false : i[e] !== void 0 && i[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          const i = this._listeners;
          if (i === void 0) return;
          const n = i[e];
          if (n !== void 0) {
            const r = n.indexOf(t);
            r !== -1 && n.splice(r, 1);
          }
        }
        dispatchEvent(e) {
          const t = this._listeners;
          if (t === void 0) return;
          const i = t[e.type];
          if (i !== void 0) {
            e.target = this;
            const n = i.slice(0);
            for (let r = 0, a = n.length; r < a; r++) n[r].call(this, e);
            e.target = null;
          }
        }
      }
      const si = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
      ];
      let Md = 1234567;
      const Ds = Math.PI / 180, es = 180 / Math.PI;
      function $i() {
        const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
        return (si[s & 255] + si[s >> 8 & 255] + si[s >> 16 & 255] + si[s >> 24 & 255] + "-" + si[e & 255] + si[e >> 8 & 255] + "-" + si[e >> 16 & 15 | 64] + si[e >> 24 & 255] + "-" + si[t & 63 | 128] + si[t >> 8 & 255] + "-" + si[t >> 16 & 255] + si[t >> 24 & 255] + si[i & 255] + si[i >> 8 & 255] + si[i >> 16 & 255] + si[i >> 24 & 255]).toLowerCase();
      }
      function He(s, e, t) {
        return Math.max(e, Math.min(t, s));
      }
      function xh(s, e) {
        return (s % e + e) % e;
      }
      function qg(s, e, t, i, n) {
        return i + (s - e) * (n - i) / (t - e);
      }
      function Xg(s, e, t) {
        return s !== e ? (t - s) / (e - s) : 0;
      }
      function Ps(s, e, t) {
        return (1 - t) * s + t * e;
      }
      function Yg(s, e, t, i) {
        return Ps(s, e, 1 - Math.exp(-t * i));
      }
      function Kg(s, e = 1) {
        return e - Math.abs(xh(s, e * 2) - e);
      }
      function Jg(s, e, t) {
        return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
      }
      function Zg(s, e, t) {
        return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
      }
      function $g(s, e) {
        return s + Math.floor(Math.random() * (e - s + 1));
      }
      function e_(s, e) {
        return s + Math.random() * (e - s);
      }
      function t_(s) {
        return s * (0.5 - Math.random());
      }
      function i_(s) {
        s !== void 0 && (Md = s);
        let e = Md += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
      }
      function n_(s) {
        return s * Ds;
      }
      function r_(s) {
        return s * es;
      }
      function s_(s) {
        return (s & s - 1) === 0 && s !== 0;
      }
      function a_(s) {
        return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
      }
      function o_(s) {
        return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
      }
      function c_(s, e, t, i, n) {
        const r = Math.cos, a = Math.sin, o = r(t / 2), c = a(t / 2), l = r((e + i) / 2), h = a((e + i) / 2), d = r((e - i) / 2), u = a((e - i) / 2), f = r((i - e) / 2), p = a((i - e) / 2);
        switch (n) {
          case "XYX":
            s.set(o * h, c * d, c * u, o * l);
            break;
          case "YZY":
            s.set(c * u, o * h, c * d, o * l);
            break;
          case "ZXZ":
            s.set(c * d, c * u, o * h, o * l);
            break;
          case "XZX":
            s.set(o * h, c * p, c * f, o * l);
            break;
          case "YXY":
            s.set(c * f, o * h, c * p, o * l);
            break;
          case "ZYZ":
            s.set(c * p, c * f, o * h, o * l);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
        }
      }
      function Ki(s, e) {
        switch (e.constructor) {
          case Float32Array:
            return s;
          case Uint32Array:
            return s / 4294967295;
          case Uint16Array:
            return s / 65535;
          case Uint8Array:
            return s / 255;
          case Int32Array:
            return Math.max(s / 2147483647, -1);
          case Int16Array:
            return Math.max(s / 32767, -1);
          case Int8Array:
            return Math.max(s / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function ft(s, e) {
        switch (e.constructor) {
          case Float32Array:
            return s;
          case Uint32Array:
            return Math.round(s * 4294967295);
          case Uint16Array:
            return Math.round(s * 65535);
          case Uint8Array:
            return Math.round(s * 255);
          case Int32Array:
            return Math.round(s * 2147483647);
          case Int16Array:
            return Math.round(s * 32767);
          case Int8Array:
            return Math.round(s * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const Ut = {
        DEG2RAD: Ds,
        RAD2DEG: es,
        generateUUID: $i,
        clamp: He,
        euclideanModulo: xh,
        mapLinear: qg,
        inverseLerp: Xg,
        lerp: Ps,
        damp: Yg,
        pingpong: Kg,
        smoothstep: Jg,
        smootherstep: Zg,
        randInt: $g,
        randFloat: e_,
        randFloatSpread: t_,
        seededRandom: i_,
        degToRad: n_,
        radToDeg: r_,
        isPowerOfTwo: s_,
        ceilPowerOfTwo: a_,
        floorPowerOfTwo: o_,
        setQuaternionFromProperEuler: c_,
        normalize: ft,
        denormalize: Ki
      };
      class oe {
        constructor(e = 0, t = 0) {
          oe.prototype.isVector2 = true, this.x = e, this.y = t;
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return this.x = e, this.y = t, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x, i = this.y, n = e.elements;
          return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
          return this.x = He(this.x, e.x, t.x), this.y = He(this.y, e.y, t.y), this;
        }
        clampScalar(e, t) {
          return this.x = He(this.x, e, t), this.y = He(this.y, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(He(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(He(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x, i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y;
          return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Oe {
        constructor(e, t, i, n, r, a, o, c, l) {
          Oe.prototype.isMatrix3 = true, this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], e !== void 0 && this.set(e, t, i, n, r, a, o, c, l);
        }
        set(e, t, i, n, r, a, o, c, l) {
          const h = this.elements;
          return h[0] = e, h[1] = n, h[2] = o, h[3] = t, h[4] = r, h[5] = c, h[6] = i, h[7] = a, h[8] = l, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements, i = e.elements;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements, n = t.elements, r = this.elements, a = i[0], o = i[3], c = i[6], l = i[1], h = i[4], d = i[7], u = i[2], f = i[5], p = i[8], m = n[0], g = n[3], A = n[6], x = n[1], b = n[4], y = n[7], I = n[2], M = n[5], R = n[8];
          return r[0] = a * m + o * x + c * I, r[3] = a * g + o * b + c * M, r[6] = a * A + o * y + c * R, r[1] = l * m + h * x + d * I, r[4] = l * g + h * b + d * M, r[7] = l * A + h * y + d * R, r[2] = u * m + f * x + p * I, r[5] = u * g + f * b + p * M, r[8] = u * A + f * y + p * R, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
          const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], h = e[8];
          return t * a * h - t * o * l - i * r * h + i * o * c + n * r * l - n * a * c;
        }
        invert() {
          const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], h = e[8], d = h * a - o * l, u = o * c - h * r, f = l * r - a * c, p = t * d + i * u + n * f;
          if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const m = 1 / p;
          return e[0] = d * m, e[1] = (n * l - h * i) * m, e[2] = (o * i - n * a) * m, e[3] = u * m, e[4] = (h * t - n * c) * m, e[5] = (n * r - o * t) * m, e[6] = f * m, e[7] = (i * c - l * t) * m, e[8] = (a * t - i * r) * m, this;
        }
        transpose() {
          let e;
          const t = this.elements;
          return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, i, n, r, a, o) {
          const c = Math.cos(r), l = Math.sin(r);
          return this.set(i * c, i * l, -i * (c * a + l * o) + a + e, -n * l, n * c, -n * (-l * a + c * o) + o + t, 0, 0, 1), this;
        }
        scale(e, t) {
          return this.premultiply(ic.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(ic.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(ic.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements, i = e.elements;
          for (let n = 0; n < 9; n++) if (t[n] !== i[n]) return false;
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const ic = new Oe();
      function Zf(s) {
        for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return true;
        return false;
      }
      function js(s) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", s);
      }
      function l_() {
        const s = js("canvas");
        return s.style.display = "block", s;
      }
      const Td = {};
      function so(s) {
        s in Td || (Td[s] = true, console.warn(s));
      }
      function h_(s, e, t) {
        return new Promise(function(i, n) {
          function r() {
            switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case s.WAIT_FAILED:
                n();
                break;
              case s.TIMEOUT_EXPIRED:
                setTimeout(r, t);
                break;
              default:
                i();
            }
          }
          setTimeout(r, t);
        });
      }
      function d_(s) {
        const e = s.elements;
        e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
      }
      function u_(s) {
        const e = s.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
      }
      const Rd = new Oe().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), Bd = new Oe().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function f_() {
        const s = {
          enabled: true,
          workingColorSpace: oi,
          spaces: {},
          convert: function(n, r, a) {
            return this.enabled === false || r === a || !r || !a || (this.spaces[r].transfer === pt && (n.r = En(n.r), n.g = En(n.g), n.b = En(n.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (n.applyMatrix3(this.spaces[r].toXYZ), n.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === pt && (n.r = Yr(n.r), n.g = Yr(n.g), n.b = Yr(n.b))), n;
          },
          fromWorkingColorSpace: function(n, r) {
            return this.convert(n, this.workingColorSpace, r);
          },
          toWorkingColorSpace: function(n, r) {
            return this.convert(n, r, this.workingColorSpace);
          },
          getPrimaries: function(n) {
            return this.spaces[n].primaries;
          },
          getTransfer: function(n) {
            return n === an ? wo : this.spaces[n].transfer;
          },
          getLuminanceCoefficients: function(n, r = this.workingColorSpace) {
            return n.fromArray(this.spaces[r].luminanceCoefficients);
          },
          define: function(n) {
            Object.assign(this.spaces, n);
          },
          _getMatrix: function(n, r, a) {
            return n.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ);
          },
          _getDrawingBufferColorSpace: function(n) {
            return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace;
          },
          _getUnpackColorSpace: function(n = this.workingColorSpace) {
            return this.spaces[n].workingColorSpaceConfig.unpackColorSpace;
          }
        }, e = [
          0.64,
          0.33,
          0.3,
          0.6,
          0.15,
          0.06
        ], t = [
          0.2126,
          0.7152,
          0.0722
        ], i = [
          0.3127,
          0.329
        ];
        return s.define({
          [oi]: {
            primaries: e,
            whitePoint: i,
            transfer: wo,
            toXYZ: Rd,
            fromXYZ: Bd,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
              unpackColorSpace: nt
            },
            outputColorSpaceConfig: {
              drawingBufferColorSpace: nt
            }
          },
          [nt]: {
            primaries: e,
            whitePoint: i,
            transfer: pt,
            toXYZ: Rd,
            fromXYZ: Bd,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
              drawingBufferColorSpace: nt
            }
          }
        }), s;
      }
      const ze = f_();
      function En(s) {
        return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
      }
      function Yr(s) {
        return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
      }
      let vr;
      class p_ {
        static getDataURL(e, t = "image/png") {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
          let i;
          if (e instanceof HTMLCanvasElement) i = e;
          else {
            vr === void 0 && (vr = js("canvas")), vr.width = e.width, vr.height = e.height;
            const n = vr.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), i = vr;
          }
          return i.toDataURL(t);
        }
        static sRGBToLinear(e) {
          if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = js("canvas");
            t.width = e.width, t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const n = i.getImageData(0, 0, e.width, e.height), r = n.data;
            for (let a = 0; a < r.length; a++) r[a] = En(r[a] / 255) * 255;
            return i.putImageData(n, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(En(t[i] / 255) * 255) : t[i] = En(t[i]);
            return {
              data: t,
              width: e.width,
              height: e.height
            };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
      }
      let A_ = 0;
      class Eh {
        constructor(e = null) {
          this.isSource = true, Object.defineProperty(this, "id", {
            value: A_++
          }), this.uuid = $i(), this.data = e, this.dataReady = true, this.version = 0;
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const i = {
            uuid: this.uuid,
            url: ""
          }, n = this.data;
          if (n !== null) {
            let r;
            if (Array.isArray(n)) {
              r = [];
              for (let a = 0, o = n.length; a < o; a++) n[a].isDataTexture ? r.push(nc(n[a].image)) : r.push(nc(n[a]));
            } else r = nc(n);
            i.url = r;
          }
          return t || (e.images[this.uuid] = i), i;
        }
      }
      function nc(s) {
        return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? p_.getDataURL(s) : s.data ? {
          data: Array.from(s.data),
          width: s.width,
          height: s.height,
          type: s.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let g_ = 0;
      class Nt extends jn {
        constructor(e = Nt.DEFAULT_IMAGE, t = Nt.DEFAULT_MAPPING, i = fi, n = fi, r = Rt, a = Ji, o = Wt, c = Jt, l = Nt.DEFAULT_ANISOTROPY, h = an) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", {
            value: g_++
          }), this.uuid = $i(), this.name = "", this.source = new Eh(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = r, this.minFilter = a, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = c, this.offset = new oe(0, 0), this.repeat = new oe(1, 1), this.center = new oe(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Oe(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
        }
        get image() {
          return this.source.data;
        }
        set image(e = null) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [
              this.repeat.x,
              this.repeat.y
            ],
            offset: [
              this.offset.x,
              this.offset.y
            ],
            center: [
              this.center.x,
              this.center.y
            ],
            rotation: this.rotation,
            wrap: [
              this.wrapS,
              this.wrapT
            ],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(e) {
          if (this.mapping !== Of) return e;
          if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case mi:
              e.x = e.x - Math.floor(e.x);
              break;
            case fi:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case ho:
              Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
              break;
          }
          if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case mi:
              e.y = e.y - Math.floor(e.y);
              break;
            case fi:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case ho:
              Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
              break;
          }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === true && (this.version++, this.source.needsUpdate = true);
        }
        set needsPMREMUpdate(e) {
          e === true && this.pmremVersion++;
        }
      }
      Nt.DEFAULT_IMAGE = null;
      Nt.DEFAULT_MAPPING = Of;
      Nt.DEFAULT_ANISOTROPY = 1;
      class je {
        constructor(e = 0, t = 0, i = 0, n = 1) {
          je.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = n;
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, n) {
          return this.x = e, this.y = t, this.z = i, this.w = n, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setW(e) {
          return this.w = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
          const t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements;
          return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, i, n, r;
          const c = e.elements, l = c[0], h = c[4], d = c[8], u = c[1], f = c[5], p = c[9], m = c[2], g = c[6], A = c[10];
          if (Math.abs(h - u) < 0.01 && Math.abs(d - m) < 0.01 && Math.abs(p - g) < 0.01) {
            if (Math.abs(h + u) < 0.1 && Math.abs(d + m) < 0.1 && Math.abs(p + g) < 0.1 && Math.abs(l + f + A - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const b = (l + 1) / 2, y = (f + 1) / 2, I = (A + 1) / 2, M = (h + u) / 4, R = (d + m) / 4, D = (p + g) / 4;
            return b > y && b > I ? b < 0.01 ? (i = 0, n = 0.707106781, r = 0.707106781) : (i = Math.sqrt(b), n = M / i, r = R / i) : y > I ? y < 0.01 ? (i = 0.707106781, n = 0, r = 0.707106781) : (n = Math.sqrt(y), i = M / n, r = D / n) : I < 0.01 ? (i = 0.707106781, n = 0.707106781, r = 0) : (r = Math.sqrt(I), i = R / r, n = D / r), this.set(i, n, r, t), this;
          }
          let x = Math.sqrt((g - p) * (g - p) + (d - m) * (d - m) + (u - h) * (u - h));
          return Math.abs(x) < 1e-3 && (x = 1), this.x = (g - p) / x, this.y = (d - m) / x, this.z = (u - h) / x, this.w = Math.acos((l + f + A - 1) / 2), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
          return this.x = He(this.x, e.x, t.x), this.y = He(this.y, e.y, t.y), this.z = He(this.z, e.z, t.z), this.w = He(this.w, e.w, t.w), this;
        }
        clampScalar(e, t) {
          return this.x = He(this.x, e, t), this.y = He(this.y, e, t), this.z = He(this.z, e, t), this.w = He(this.w, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(He(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class __ extends jn {
        constructor(e = 1, t = 1, i = {}) {
          super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new je(0, 0, e, t), this.scissorTest = false, this.viewport = new je(0, 0, e, t);
          const n = {
            width: e,
            height: t,
            depth: 1
          };
          i = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: Rt,
            depthBuffer: true,
            stencilBuffer: false,
            resolveDepthBuffer: true,
            resolveStencilBuffer: true,
            depthTexture: null,
            samples: 0,
            count: 1
          }, i);
          const r = new Nt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
          r.flipY = false, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
          const a = i.count;
          for (let o = 0; o < a; o++) this.textures[o] = r.clone(), this.textures[o].isRenderTargetTexture = true, this.textures[o].renderTarget = this;
          this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = i.depthTexture, this.samples = i.samples;
        }
        get texture() {
          return this.textures[0];
        }
        set texture(e) {
          this.textures[0] = e;
        }
        set depthTexture(e) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(e, t, i = 1) {
          if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e, this.height = t, this.depth = i;
            for (let n = 0, r = this.textures.length; n < r; n++) this.textures[n].image.width = e, this.textures[n].image.height = t, this.textures[n].image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
          for (let t = 0, i = e.textures.length; t < i; t++) {
            this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = true, this.textures[t].renderTarget = this;
            const n = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new Eh(n);
          }
          return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class Cn extends __ {
        constructor(e = 1, t = 1, i = {}) {
          super(e, t, i), this.isWebGLRenderTarget = true;
        }
      }
      class $f extends Nt {
        constructor(e = null, t = 1, i = 1, n = 1) {
          super(null), this.isDataArrayTexture = true, this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
          }, this.magFilter = pi, this.minFilter = pi, this.wrapR = fi, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class ep extends Nt {
        constructor(e = null, t = 1, i = 1, n = 1) {
          super(null), this.isData3DTexture = true, this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
          }, this.magFilter = pi, this.minFilter = pi, this.wrapR = fi, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      let At = class {
        constructor(e = 0, t = 0, i = 0, n = 1) {
          this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = n;
        }
        static slerpFlat(e, t, i, n, r, a, o) {
          let c = i[n + 0], l = i[n + 1], h = i[n + 2], d = i[n + 3];
          const u = r[a + 0], f = r[a + 1], p = r[a + 2], m = r[a + 3];
          if (o === 0) {
            e[t + 0] = c, e[t + 1] = l, e[t + 2] = h, e[t + 3] = d;
            return;
          }
          if (o === 1) {
            e[t + 0] = u, e[t + 1] = f, e[t + 2] = p, e[t + 3] = m;
            return;
          }
          if (d !== m || c !== u || l !== f || h !== p) {
            let g = 1 - o;
            const A = c * u + l * f + h * p + d * m, x = A >= 0 ? 1 : -1, b = 1 - A * A;
            if (b > Number.EPSILON) {
              const I = Math.sqrt(b), M = Math.atan2(I, A * x);
              g = Math.sin(g * M) / I, o = Math.sin(o * M) / I;
            }
            const y = o * x;
            if (c = c * g + u * y, l = l * g + f * y, h = h * g + p * y, d = d * g + m * y, g === 1 - o) {
              const I = 1 / Math.sqrt(c * c + l * l + h * h + d * d);
              c *= I, l *= I, h *= I, d *= I;
            }
          }
          e[t] = c, e[t + 1] = l, e[t + 2] = h, e[t + 3] = d;
        }
        static multiplyQuaternionsFlat(e, t, i, n, r, a) {
          const o = i[n], c = i[n + 1], l = i[n + 2], h = i[n + 3], d = r[a], u = r[a + 1], f = r[a + 2], p = r[a + 3];
          return e[t] = o * p + h * d + c * f - l * u, e[t + 1] = c * p + h * u + l * d - o * f, e[t + 2] = l * p + h * f + o * u - c * d, e[t + 3] = h * p - o * d - c * u - l * f, e;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          this._w = e, this._onChangeCallback();
        }
        set(e, t, i, n) {
          return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t = true) {
          const i = e._x, n = e._y, r = e._z, a = e._order, o = Math.cos, c = Math.sin, l = o(i / 2), h = o(n / 2), d = o(r / 2), u = c(i / 2), f = c(n / 2), p = c(r / 2);
          switch (a) {
            case "XYZ":
              this._x = u * h * d + l * f * p, this._y = l * f * d - u * h * p, this._z = l * h * p + u * f * d, this._w = l * h * d - u * f * p;
              break;
            case "YXZ":
              this._x = u * h * d + l * f * p, this._y = l * f * d - u * h * p, this._z = l * h * p - u * f * d, this._w = l * h * d + u * f * p;
              break;
            case "ZXY":
              this._x = u * h * d - l * f * p, this._y = l * f * d + u * h * p, this._z = l * h * p + u * f * d, this._w = l * h * d - u * f * p;
              break;
            case "ZYX":
              this._x = u * h * d - l * f * p, this._y = l * f * d + u * h * p, this._z = l * h * p - u * f * d, this._w = l * h * d + u * f * p;
              break;
            case "YZX":
              this._x = u * h * d + l * f * p, this._y = l * f * d + u * h * p, this._z = l * h * p - u * f * d, this._w = l * h * d - u * f * p;
              break;
            case "XZY":
              this._x = u * h * d - l * f * p, this._y = l * f * d - u * h * p, this._z = l * h * p + u * f * d, this._w = l * h * d + u * f * p;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
          }
          return t === true && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2, n = Math.sin(i);
          return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
          const t = e.elements, i = t[0], n = t[4], r = t[8], a = t[1], o = t[5], c = t[9], l = t[2], h = t[6], d = t[10], u = i + o + d;
          if (u > 0) {
            const f = 0.5 / Math.sqrt(u + 1);
            this._w = 0.25 / f, this._x = (h - c) * f, this._y = (r - l) * f, this._z = (a - n) * f;
          } else if (i > o && i > d) {
            const f = 2 * Math.sqrt(1 + i - o - d);
            this._w = (h - c) / f, this._x = 0.25 * f, this._y = (n + a) / f, this._z = (r + l) / f;
          } else if (o > d) {
            const f = 2 * Math.sqrt(1 + o - i - d);
            this._w = (r - l) / f, this._x = (n + a) / f, this._y = 0.25 * f, this._z = (c + h) / f;
          } else {
            const f = 2 * Math.sqrt(1 + d - i - o);
            this._w = (a - n) / f, this._x = (r + l) / f, this._y = (c + h) / f, this._z = 0.25 * f;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(He(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (i === 0) return this;
          const n = Math.min(1, t / i);
          return this.slerp(e, n), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e = this.length();
          return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x, n = e._y, r = e._z, a = e._w, o = t._x, c = t._y, l = t._z, h = t._w;
          return this._x = i * h + a * o + n * l - r * c, this._y = n * h + a * c + r * o - i * l, this._z = r * h + a * l + i * c - n * o, this._w = a * h - i * o - n * c - r * l, this._onChangeCallback(), this;
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const i = this._x, n = this._y, r = this._z, a = this._w;
          let o = a * e._w + i * e._x + n * e._y + r * e._z;
          if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this;
          const c = 1 - o * o;
          if (c <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * a + t * this._w, this._x = f * i + t * this._x, this._y = f * n + t * this._y, this._z = f * r + t * this._z, this.normalize(), this;
          }
          const l = Math.sqrt(c), h = Math.atan2(l, o), d = Math.sin((1 - t) * h) / l, u = Math.sin(t * h) / l;
          return this._w = a * d + this._w * u, this._x = i * d + this._x * u, this._y = n * d + this._y * u, this._z = r * d + this._z * u, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), r = Math.sqrt(i);
          return this.set(n * Math.sin(e), n * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
          return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
          return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }, T = class tp {
        constructor(e = 0, t = 0, i = 0) {
          tp.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
        }
        set(e, t, i) {
          return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
          return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
          return this.applyQuaternion(Dd.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(Dd.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x, i = this.y, n = this.z, r = e.elements;
          return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this;
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
          return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this;
        }
        applyQuaternion(e) {
          const t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, o = e.z, c = e.w, l = 2 * (a * n - o * i), h = 2 * (o * t - r * n), d = 2 * (r * i - a * t);
          return this.x = t + c * l + a * d - o * h, this.y = i + c * h + o * l - r * d, this.z = n + c * d + r * h - a * l, this;
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
          const t = this.x, i = this.y, n = this.z, r = e.elements;
          return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize();
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
          return this.x = He(this.x, e.x, t.x), this.y = He(this.y, e.y, t.y), this.z = He(this.z, e.z, t.z), this;
        }
        clampScalar(e, t) {
          return this.x = He(this.x, e, t), this.y = He(this.y, e, t), this.z = He(this.z, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(He(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x, n = e.y, r = e.z, a = t.x, o = t.y, c = t.z;
          return this.x = n * c - r * o, this.y = r * a - i * c, this.z = i * o - n * a, this;
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          return rc.copy(this).projectOnVector(e), this.sub(rc);
        }
        reflect(e) {
          return this.sub(rc.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(He(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
          return t * t + i * i + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const n = Math.sin(t) * e;
          return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
          return this.x = t, this.y = i, this.z = n, this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        setFromColor(e) {
          return this.x = e.r, this.y = e.g, this.z = e.b, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, i = Math.sqrt(1 - t * t);
          return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      };
      const rc = new T(), Dd = new At();
      class on {
        constructor(e = new T(1 / 0, 1 / 0, 1 / 0), t = new T(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = e, this.max = t;
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(zi.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(zi.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = zi.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
        }
        setFromObject(e, t = false) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = false) {
          e.updateWorldMatrix(false, false);
          const i = e.geometry;
          if (i !== void 0) {
            const r = i.getAttribute("position");
            if (t === true && r !== void 0 && e.isInstancedMesh !== true) for (let a = 0, o = r.count; a < o; a++) e.isMesh === true ? e.getVertexPosition(a, zi) : zi.fromBufferAttribute(r, a), zi.applyMatrix4(e.matrixWorld), this.expandByPoint(zi);
            else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Aa.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Aa.copy(i.boundingBox)), Aa.applyMatrix4(e.matrixWorld), this.union(Aa);
          }
          const n = e.children;
          for (let r = 0, a = n.length; r < a; r++) this.expandByObject(n[r], t);
          return this;
        }
        containsPoint(e) {
          return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
          return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
        }
        intersectsSphere(e) {
          return this.clampPoint(e.center, zi), zi.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
          let t, i;
          return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return false;
          this.getCenter(ps), ga.subVectors(this.max, ps), Sr.subVectors(e.a, ps), Cr.subVectors(e.b, ps), Ir.subVectors(e.c, ps), Bn.subVectors(Cr, Sr), Dn.subVectors(Ir, Cr), Yn.subVectors(Sr, Ir);
          let t = [
            0,
            -Bn.z,
            Bn.y,
            0,
            -Dn.z,
            Dn.y,
            0,
            -Yn.z,
            Yn.y,
            Bn.z,
            0,
            -Bn.x,
            Dn.z,
            0,
            -Dn.x,
            Yn.z,
            0,
            -Yn.x,
            -Bn.y,
            Bn.x,
            0,
            -Dn.y,
            Dn.x,
            0,
            -Yn.y,
            Yn.x,
            0
          ];
          return !sc(t, Sr, Cr, Ir, ga) || (t = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], !sc(t, Sr, Cr, Ir, ga)) ? false : (_a.crossVectors(Bn, Dn), t = [
            _a.x,
            _a.y,
            _a.z
          ], sc(t, Sr, Cr, Ir, ga));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, zi).distanceTo(e);
        }
        getBoundingSphere(e) {
          return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(zi).length() * 0.5), e;
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty() ? this : (dn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), dn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), dn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), dn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), dn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), dn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), dn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), dn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(dn), this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const dn = [
        new T(),
        new T(),
        new T(),
        new T(),
        new T(),
        new T(),
        new T(),
        new T()
      ], zi = new T(), Aa = new on(), Sr = new T(), Cr = new T(), Ir = new T(), Bn = new T(), Dn = new T(), Yn = new T(), ps = new T(), ga = new T(), _a = new T(), Kn = new T();
      function sc(s, e, t, i, n) {
        for (let r = 0, a = s.length - 3; r <= a; r += 3) {
          Kn.fromArray(s, r);
          const o = n.x * Math.abs(Kn.x) + n.y * Math.abs(Kn.y) + n.z * Math.abs(Kn.z), c = e.dot(Kn), l = t.dot(Kn), h = i.dot(Kn);
          if (Math.max(-Math.max(c, l, h), Math.min(c, l, h)) > o) return false;
        }
        return true;
      }
      const m_ = new on(), As = new T(), ac = new T();
      class cn {
        constructor(e = new T(), t = -1) {
          this.isSphere = true, this.center = e, this.radius = t;
        }
        set(e, t) {
          return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          t !== void 0 ? i.copy(t) : m_.setFromPoints(e).getCenter(i);
          let n = 0;
          for (let r = 0, a = e.length; r < a; r++) n = Math.max(n, i.distanceToSquared(e[r]));
          return this.radius = Math.sqrt(n), this;
        }
        copy(e) {
          return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
          return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
          return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
          As.subVectors(e, this.center);
          const t = As.lengthSq();
          if (t > this.radius * this.radius) {
            const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
            this.center.addScaledVector(As, n / i), this.radius += n;
          }
          return this;
        }
        union(e) {
          return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (ac.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(As.copy(e.center).add(ac)), this.expandByPoint(As.copy(e.center).sub(ac))), this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const un = new T(), oc = new T(), ma = new T(), Pn = new T(), cc = new T(), wa = new T(), lc = new T();
      let os = class {
        constructor(e = new T(), t = new T(0, 0, -1)) {
          this.origin = e, this.direction = t;
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, un)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = un.subVectors(e, this.origin).dot(this.direction);
          return t < 0 ? this.origin.distanceToSquared(e) : (un.copy(this.origin).addScaledVector(this.direction, t), un.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, i, n) {
          oc.copy(e).add(t).multiplyScalar(0.5), ma.copy(t).sub(e).normalize(), Pn.copy(this.origin).sub(oc);
          const r = e.distanceTo(t) * 0.5, a = -this.direction.dot(ma), o = Pn.dot(this.direction), c = -Pn.dot(ma), l = Pn.lengthSq(), h = Math.abs(1 - a * a);
          let d, u, f, p;
          if (h > 0) if (d = a * c - o, u = a * o - c, p = r * h, d >= 0) if (u >= -p) if (u <= p) {
            const m = 1 / h;
            d *= m, u *= m, f = d * (d + a * u + 2 * o) + u * (a * d + u + 2 * c) + l;
          } else u = r, d = Math.max(0, -(a * u + o)), f = -d * d + u * (u + 2 * c) + l;
          else u = -r, d = Math.max(0, -(a * u + o)), f = -d * d + u * (u + 2 * c) + l;
          else u <= -p ? (d = Math.max(0, -(-a * r + o)), u = d > 0 ? -r : Math.min(Math.max(-r, -c), r), f = -d * d + u * (u + 2 * c) + l) : u <= p ? (d = 0, u = Math.min(Math.max(-r, -c), r), f = u * (u + 2 * c) + l) : (d = Math.max(0, -(a * r + o)), u = d > 0 ? r : Math.min(Math.max(-r, -c), r), f = -d * d + u * (u + 2 * c) + l);
          else u = a > 0 ? -r : r, d = Math.max(0, -(a * u + o)), f = -d * d + u * (u + 2 * c) + l;
          return i && i.copy(this.origin).addScaledVector(this.direction, d), n && n.copy(oc).addScaledVector(ma, u), f;
        }
        intersectSphere(e, t) {
          un.subVectors(e.center, this.origin);
          const i = un.dot(this.direction), n = un.dot(un) - i * i, r = e.radius * e.radius;
          if (n > r) return null;
          const a = Math.sqrt(r - n), o = i - a, c = i + a;
          return c < 0 ? null : o < 0 ? this.at(c, t) : this.at(o, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null;
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return i === null ? null : this.at(i, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i, n, r, a, o, c;
          const l = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, u = this.origin;
          return l >= 0 ? (i = (e.min.x - u.x) * l, n = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, n = (e.min.x - u.x) * l), h >= 0 ? (r = (e.min.y - u.y) * h, a = (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h, a = (e.min.y - u.y) * h), i > a || r > n || ((r > i || isNaN(i)) && (i = r), (a < n || isNaN(n)) && (n = a), d >= 0 ? (o = (e.min.z - u.z) * d, c = (e.max.z - u.z) * d) : (o = (e.max.z - u.z) * d, c = (e.min.z - u.z) * d), i > c || o > n) || ((o > i || i !== i) && (i = o), (c < n || n !== n) && (n = c), n < 0) ? null : this.at(i >= 0 ? i : n, t);
        }
        intersectsBox(e) {
          return this.intersectBox(e, un) !== null;
        }
        intersectTriangle(e, t, i, n, r) {
          cc.subVectors(t, e), wa.subVectors(i, e), lc.crossVectors(cc, wa);
          let a = this.direction.dot(lc), o;
          if (a > 0) {
            if (n) return null;
            o = 1;
          } else if (a < 0) o = -1, a = -a;
          else return null;
          Pn.subVectors(this.origin, e);
          const c = o * this.direction.dot(wa.crossVectors(Pn, wa));
          if (c < 0) return null;
          const l = o * this.direction.dot(cc.cross(Pn));
          if (l < 0 || c + l > a) return null;
          const h = -o * Pn.dot(lc);
          return h < 0 ? null : this.at(h / a, r);
        }
        applyMatrix4(e) {
          return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      };
      class ge {
        constructor(e, t, i, n, r, a, o, c, l, h, d, u, f, p, m, g) {
          ge.prototype.isMatrix4 = true, this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ], e !== void 0 && this.set(e, t, i, n, r, a, o, c, l, h, d, u, f, p, m, g);
        }
        set(e, t, i, n, r, a, o, c, l, h, d, u, f, p, m, g) {
          const A = this.elements;
          return A[0] = e, A[4] = t, A[8] = i, A[12] = n, A[1] = r, A[5] = a, A[9] = o, A[13] = c, A[2] = l, A[6] = h, A[10] = d, A[14] = u, A[3] = f, A[7] = p, A[11] = m, A[15] = g, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new ge().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements, i = e.elements;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
        }
        copyPosition(e) {
          const t = this.elements, i = e.elements;
          return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, i) {
          return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
          const t = this.elements, i = e.elements, n = 1 / Mr.setFromMatrixColumn(e, 0).length(), r = 1 / Mr.setFromMatrixColumn(e, 1).length(), a = 1 / Mr.setFromMatrixColumn(e, 2).length();
          return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
          const t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), o = Math.sin(i), c = Math.cos(n), l = Math.sin(n), h = Math.cos(r), d = Math.sin(r);
          if (e.order === "XYZ") {
            const u = a * h, f = a * d, p = o * h, m = o * d;
            t[0] = c * h, t[4] = -c * d, t[8] = l, t[1] = f + p * l, t[5] = u - m * l, t[9] = -o * c, t[2] = m - u * l, t[6] = p + f * l, t[10] = a * c;
          } else if (e.order === "YXZ") {
            const u = c * h, f = c * d, p = l * h, m = l * d;
            t[0] = u + m * o, t[4] = p * o - f, t[8] = a * l, t[1] = a * d, t[5] = a * h, t[9] = -o, t[2] = f * o - p, t[6] = m + u * o, t[10] = a * c;
          } else if (e.order === "ZXY") {
            const u = c * h, f = c * d, p = l * h, m = l * d;
            t[0] = u - m * o, t[4] = -a * d, t[8] = p + f * o, t[1] = f + p * o, t[5] = a * h, t[9] = m - u * o, t[2] = -a * l, t[6] = o, t[10] = a * c;
          } else if (e.order === "ZYX") {
            const u = a * h, f = a * d, p = o * h, m = o * d;
            t[0] = c * h, t[4] = p * l - f, t[8] = u * l + m, t[1] = c * d, t[5] = m * l + u, t[9] = f * l - p, t[2] = -l, t[6] = o * c, t[10] = a * c;
          } else if (e.order === "YZX") {
            const u = a * c, f = a * l, p = o * c, m = o * l;
            t[0] = c * h, t[4] = m - u * d, t[8] = p * d + f, t[1] = d, t[5] = a * h, t[9] = -o * h, t[2] = -l * h, t[6] = f * d + p, t[10] = u - m * d;
          } else if (e.order === "XZY") {
            const u = a * c, f = a * l, p = o * c, m = o * l;
            t[0] = c * h, t[4] = -d, t[8] = l * h, t[1] = u * d + m, t[5] = a * h, t[9] = f * d - p, t[2] = p * d - f, t[6] = o * h, t[10] = m * d + u;
          }
          return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
          return this.compose(w_, e, b_);
        }
        lookAt(e, t, i) {
          const n = this.elements;
          return bi.subVectors(e, t), bi.lengthSq() === 0 && (bi.z = 1), bi.normalize(), Ln.crossVectors(i, bi), Ln.lengthSq() === 0 && (Math.abs(i.z) === 1 ? bi.x += 1e-4 : bi.z += 1e-4, bi.normalize(), Ln.crossVectors(i, bi)), Ln.normalize(), ba.crossVectors(bi, Ln), n[0] = Ln.x, n[4] = ba.x, n[8] = bi.x, n[1] = Ln.y, n[5] = ba.y, n[9] = bi.y, n[2] = Ln.z, n[6] = ba.z, n[10] = bi.z, this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements, n = t.elements, r = this.elements, a = i[0], o = i[4], c = i[8], l = i[12], h = i[1], d = i[5], u = i[9], f = i[13], p = i[2], m = i[6], g = i[10], A = i[14], x = i[3], b = i[7], y = i[11], I = i[15], M = n[0], R = n[4], D = n[8], S = n[12], E = n[1], P = n[5], j = n[9], H = n[13], Y = n[2], te = n[6], q = n[10], Z = n[14], V = n[3], re = n[7], he = n[11], ve = n[15];
          return r[0] = a * M + o * E + c * Y + l * V, r[4] = a * R + o * P + c * te + l * re, r[8] = a * D + o * j + c * q + l * he, r[12] = a * S + o * H + c * Z + l * ve, r[1] = h * M + d * E + u * Y + f * V, r[5] = h * R + d * P + u * te + f * re, r[9] = h * D + d * j + u * q + f * he, r[13] = h * S + d * H + u * Z + f * ve, r[2] = p * M + m * E + g * Y + A * V, r[6] = p * R + m * P + g * te + A * re, r[10] = p * D + m * j + g * q + A * he, r[14] = p * S + m * H + g * Z + A * ve, r[3] = x * M + b * E + y * Y + I * V, r[7] = x * R + b * P + y * te + I * re, r[11] = x * D + b * j + y * q + I * he, r[15] = x * S + b * H + y * Z + I * ve, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
          const e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], o = e[5], c = e[9], l = e[13], h = e[2], d = e[6], u = e[10], f = e[14], p = e[3], m = e[7], g = e[11], A = e[15];
          return p * (+r * c * d - n * l * d - r * o * u + i * l * u + n * o * f - i * c * f) + m * (+t * c * f - t * l * u + r * a * u - n * a * f + n * l * h - r * c * h) + g * (+t * l * d - t * o * f - r * a * d + i * a * f + r * o * h - i * l * h) + A * (-n * o * h - t * c * d + t * o * u + n * a * d - i * a * u + i * c * h);
        }
        transpose() {
          const e = this.elements;
          let t;
          return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, i) {
          const n = this.elements;
          return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
        }
        invert() {
          const e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], o = e[5], c = e[6], l = e[7], h = e[8], d = e[9], u = e[10], f = e[11], p = e[12], m = e[13], g = e[14], A = e[15], x = d * g * l - m * u * l + m * c * f - o * g * f - d * c * A + o * u * A, b = p * u * l - h * g * l - p * c * f + a * g * f + h * c * A - a * u * A, y = h * m * l - p * d * l + p * o * f - a * m * f - h * o * A + a * d * A, I = p * d * c - h * m * c - p * o * u + a * m * u + h * o * g - a * d * g, M = t * x + i * b + n * y + r * I;
          if (M === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const R = 1 / M;
          return e[0] = x * R, e[1] = (m * u * r - d * g * r - m * n * f + i * g * f + d * n * A - i * u * A) * R, e[2] = (o * g * r - m * c * r + m * n * l - i * g * l - o * n * A + i * c * A) * R, e[3] = (d * c * r - o * u * r - d * n * l + i * u * l + o * n * f - i * c * f) * R, e[4] = b * R, e[5] = (h * g * r - p * u * r + p * n * f - t * g * f - h * n * A + t * u * A) * R, e[6] = (p * c * r - a * g * r - p * n * l + t * g * l + a * n * A - t * c * A) * R, e[7] = (a * u * r - h * c * r + h * n * l - t * u * l - a * n * f + t * c * f) * R, e[8] = y * R, e[9] = (p * d * r - h * m * r - p * i * f + t * m * f + h * i * A - t * d * A) * R, e[10] = (a * m * r - p * o * r + p * i * l - t * m * l - a * i * A + t * o * A) * R, e[11] = (h * o * r - a * d * r - h * i * l + t * d * l + a * i * f - t * o * f) * R, e[12] = I * R, e[13] = (h * m * n - p * d * n + p * i * u - t * m * u - h * i * g + t * d * g) * R, e[14] = (p * o * n - a * m * n - p * i * c + t * m * c + a * i * g - t * o * g) * R, e[15] = (a * d * n - h * o * n + h * i * c - t * d * c - a * i * u + t * o * u) * R, this;
        }
        scale(e) {
          const t = this.elements, i = e.x, n = e.y, r = e.z;
          return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this;
        }
        getMaxScaleOnAxis() {
          const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, n));
        }
        makeTranslation(e, t, i) {
          return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, o = e.y, c = e.z, l = r * a, h = r * o;
          return this.set(l * a + i, l * o - n * c, l * c + n * o, 0, l * o + n * c, h * o + i, h * c - n * a, 0, l * c - n * o, h * c + n * a, r * c * c + i, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, i, n, r, a) {
          return this.set(1, i, r, 0, e, 1, a, 0, t, n, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, i) {
          const n = this.elements, r = t._x, a = t._y, o = t._z, c = t._w, l = r + r, h = a + a, d = o + o, u = r * l, f = r * h, p = r * d, m = a * h, g = a * d, A = o * d, x = c * l, b = c * h, y = c * d, I = i.x, M = i.y, R = i.z;
          return n[0] = (1 - (m + A)) * I, n[1] = (f + y) * I, n[2] = (p - b) * I, n[3] = 0, n[4] = (f - y) * M, n[5] = (1 - (u + A)) * M, n[6] = (g + x) * M, n[7] = 0, n[8] = (p + b) * R, n[9] = (g - x) * R, n[10] = (1 - (u + m)) * R, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
        }
        decompose(e, t, i) {
          const n = this.elements;
          let r = Mr.set(n[0], n[1], n[2]).length();
          const a = Mr.set(n[4], n[5], n[6]).length(), o = Mr.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], Gi.copy(this);
          const l = 1 / r, h = 1 / a, d = 1 / o;
          return Gi.elements[0] *= l, Gi.elements[1] *= l, Gi.elements[2] *= l, Gi.elements[4] *= h, Gi.elements[5] *= h, Gi.elements[6] *= h, Gi.elements[8] *= d, Gi.elements[9] *= d, Gi.elements[10] *= d, t.setFromRotationMatrix(Gi), i.x = r, i.y = a, i.z = o, this;
        }
        makePerspective(e, t, i, n, r, a, o = xn) {
          const c = this.elements, l = 2 * r / (t - e), h = 2 * r / (i - n), d = (t + e) / (t - e), u = (i + n) / (i - n);
          let f, p;
          if (o === xn) f = -(a + r) / (a - r), p = -2 * a * r / (a - r);
          else if (o === bo) f = -a / (a - r), p = -a * r / (a - r);
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
          return c[0] = l, c[4] = 0, c[8] = d, c[12] = 0, c[1] = 0, c[5] = h, c[9] = u, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = p, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
        }
        makeOrthographic(e, t, i, n, r, a, o = xn) {
          const c = this.elements, l = 1 / (t - e), h = 1 / (i - n), d = 1 / (a - r), u = (t + e) * l, f = (i + n) * h;
          let p, m;
          if (o === xn) p = (a + r) * d, m = -2 * d;
          else if (o === bo) p = r * d, m = -1 * d;
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
          return c[0] = 2 * l, c[4] = 0, c[8] = 0, c[12] = -u, c[1] = 0, c[5] = 2 * h, c[9] = 0, c[13] = -f, c[2] = 0, c[6] = 0, c[10] = m, c[14] = -p, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
        }
        equals(e) {
          const t = this.elements, i = e.elements;
          for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return false;
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
        }
      }
      const Mr = new T(), Gi = new ge(), w_ = new T(0, 0, 0), b_ = new T(1, 1, 1), Ln = new T(), ba = new T(), bi = new T(), Pd = new ge(), Ld = new At();
      class Ht {
        constructor(e = 0, t = 0, i = 0, n = Ht.DEFAULT_ORDER) {
          this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = n;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          this._order = e, this._onChangeCallback();
        }
        set(e, t, i, n = this._order) {
          return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, i = true) {
          const n = e.elements, r = n[0], a = n[4], o = n[8], c = n[1], l = n[5], h = n[9], d = n[2], u = n[6], f = n[10];
          switch (t) {
            case "XYZ":
              this._y = Math.asin(He(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(u, l), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-He(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, f), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-d, r), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(He(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(c, r));
              break;
            case "ZYX":
              this._y = Math.asin(-He(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(u, f), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-a, l));
              break;
            case "YZX":
              this._z = Math.asin(He(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-h, l), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(o, f));
              break;
            case "XZY":
              this._z = Math.asin(-He(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, r)) : (this._x = Math.atan2(-h, f), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
          }
          return this._order = t, i === true && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, i) {
          return Pd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Pd, t, i);
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return Ld.setFromEuler(this), this.setFromQuaternion(Ld, e);
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
          return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      Ht.DEFAULT_ORDER = "XYZ";
      class vh {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e | 0;
        }
        disable(e) {
          this.mask &= ~(1 << e | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & (1 << e | 0)) !== 0;
        }
      }
      let y_ = 0;
      const Fd = new T(), Tr = new At(), fn = new ge(), ya = new T(), gs = new T(), x_ = new T(), E_ = new At(), kd = new T(1, 0, 0), Ud = new T(0, 1, 0), Nd = new T(0, 0, 1), Qd = {
        type: "added"
      }, v_ = {
        type: "removed"
      }, Rr = {
        type: "childadded",
        child: null
      }, hc = {
        type: "childremoved",
        child: null
      };
      class ct extends jn {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", {
            value: y_++
          }), this.uuid = $i(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ct.DEFAULT_UP.clone();
          const e = new T(), t = new Ht(), i = new At(), n = new T(1, 1, 1);
          function r() {
            i.setFromEuler(t, false);
          }
          function a() {
            t.setFromQuaternion(i, void 0, false);
          }
          t._onChange(r), i._onChange(a), Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: e
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: t
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: n
            },
            modelViewMatrix: {
              value: new ge()
            },
            normalMatrix: {
              value: new Oe()
            }
          }), this.matrix = new ge(), this.matrixWorld = new ge(), this.matrixAutoUpdate = ct.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new vh(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
        }
        onBeforeShadow() {
        }
        onAfterShadow() {
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, true);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return Tr.setFromAxisAngle(e, t), this.quaternion.multiply(Tr), this;
        }
        rotateOnWorldAxis(e, t) {
          return Tr.setFromAxisAngle(e, t), this.quaternion.premultiply(Tr), this;
        }
        rotateX(e) {
          return this.rotateOnAxis(kd, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(Ud, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(Nd, e);
        }
        translateOnAxis(e, t) {
          return Fd.copy(e).applyQuaternion(this.quaternion), this.position.add(Fd.multiplyScalar(t)), this;
        }
        translateX(e) {
          return this.translateOnAxis(kd, e);
        }
        translateY(e) {
          return this.translateOnAxis(Ud, e);
        }
        translateZ(e) {
          return this.translateOnAxis(Nd, e);
        }
        localToWorld(e) {
          return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return this.updateWorldMatrix(true, false), e.applyMatrix4(fn.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, i) {
          e.isVector3 ? ya.copy(e) : ya.set(e, t, i);
          const n = this.parent;
          this.updateWorldMatrix(true, false), gs.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? fn.lookAt(gs, ya, this.up) : fn.lookAt(ya, gs, this.up), this.quaternion.setFromRotationMatrix(fn), n && (fn.extractRotation(n.matrixWorld), Tr.setFromRotationMatrix(fn), this.quaternion.premultiply(Tr.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Qd), Rr.child = e, this.dispatchEvent(Rr), Rr.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const t = this.children.indexOf(e);
          return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(v_), hc.child = e, this.dispatchEvent(hc), hc.child = null), this;
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(e) {
          return this.updateWorldMatrix(true, false), fn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), fn.multiply(e.parent.matrixWorld)), e.applyMatrix4(fn), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(Qd), Rr.child = e, this.dispatchEvent(Rr), Rr.child = null, this;
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let i = 0, n = this.children.length; i < n; i++) {
            const a = this.children[i].getObjectByProperty(e, t);
            if (a !== void 0) return a;
          }
        }
        getObjectsByProperty(e, t, i = []) {
          this[e] === t && i.push(this);
          const n = this.children;
          for (let r = 0, a = n.length; r < a; r++) n[r].getObjectsByProperty(e, t, i);
          return i;
        }
        getWorldPosition(e) {
          return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(gs, e, x_), e;
        }
        getWorldScale(e) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(gs, E_, e), e;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(true, false);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {
        }
        traverse(e) {
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === false) return;
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, e = true);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const i = this.parent;
          if (e === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === true) {
            const n = this.children;
            for (let r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(false, true);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string", i = {};
          t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const n = {};
          n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === true && (n.castShadow = true), this.receiveShadow === true && (n.receiveShadow = true), this.visible === false && (n.visible = false), this.frustumCulled === false && (n.frustumCulled = false), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === false && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((o) => ({
            boxInitialized: o.boxInitialized,
            boxMin: o.box.min.toArray(),
            boxMax: o.box.max.toArray(),
            sphereInitialized: o.sphereInitialized,
            sphereRadius: o.sphere.radius,
            sphereCenter: o.sphere.center.toArray()
          })), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (n.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (n.boundingSphere = {
            center: n.boundingSphere.center.toArray(),
            radius: n.boundingSphere.radius
          }), this.boundingBox !== null && (n.boundingBox = {
            min: n.boundingBox.min.toArray(),
            max: n.boundingBox.max.toArray()
          }));
          function r(o, c) {
            return o[c.uuid] === void 0 && (o[c.uuid] = c.toJSON(e)), c.uuid;
          }
          if (this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (n.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = r(e.geometries, this.geometry);
            const o = this.geometry.parameters;
            if (o !== void 0 && o.shapes !== void 0) {
              const c = o.shapes;
              if (Array.isArray(c)) for (let l = 0, h = c.length; l < h; l++) {
                const d = c[l];
                r(e.shapes, d);
              }
              else r(e.shapes, c);
            }
          }
          if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const o = [];
            for (let c = 0, l = this.material.length; c < l; c++) o.push(r(e.materials, this.material[c]));
            n.material = o;
          } else n.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            n.children = [];
            for (let o = 0; o < this.children.length; o++) n.children.push(this.children[o].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            n.animations = [];
            for (let o = 0; o < this.animations.length; o++) {
              const c = this.animations[o];
              n.animations.push(r(e.animations, c));
            }
          }
          if (t) {
            const o = a(e.geometries), c = a(e.materials), l = a(e.textures), h = a(e.images), d = a(e.shapes), u = a(e.skeletons), f = a(e.animations), p = a(e.nodes);
            o.length > 0 && (i.geometries = o), c.length > 0 && (i.materials = c), l.length > 0 && (i.textures = l), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), u.length > 0 && (i.skeletons = u), f.length > 0 && (i.animations = f), p.length > 0 && (i.nodes = p);
          }
          return i.object = n, i;
          function a(o) {
            const c = [];
            for (const l in o) {
              const h = o[l];
              delete h.metadata, c.push(h);
            }
            return c;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = true) {
          if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
            const n = e.children[i];
            this.add(n.clone());
          }
          return this;
        }
      }
      ct.DEFAULT_UP = new T(0, 1, 0);
      ct.DEFAULT_MATRIX_AUTO_UPDATE = true;
      ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      const Hi = new T(), pn = new T(), dc = new T(), An = new T(), Br = new T(), Dr = new T(), Od = new T(), uc = new T(), fc = new T(), pc = new T(), Ac = new je(), gc = new je(), _c = new je();
      let _s = class zr {
        constructor(e = new T(), t = new T(), i = new T()) {
          this.a = e, this.b = t, this.c = i;
        }
        static getNormal(e, t, i, n) {
          n.subVectors(i, t), Hi.subVectors(e, t), n.cross(Hi);
          const r = n.lengthSq();
          return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
        }
        static getBarycoord(e, t, i, n, r) {
          Hi.subVectors(n, t), pn.subVectors(i, t), dc.subVectors(e, t);
          const a = Hi.dot(Hi), o = Hi.dot(pn), c = Hi.dot(dc), l = pn.dot(pn), h = pn.dot(dc), d = a * l - o * o;
          if (d === 0) return r.set(0, 0, 0), null;
          const u = 1 / d, f = (l * c - o * h) * u, p = (a * h - o * c) * u;
          return r.set(1 - f - p, p, f);
        }
        static containsPoint(e, t, i, n) {
          return this.getBarycoord(e, t, i, n, An) === null ? false : An.x >= 0 && An.y >= 0 && An.x + An.y <= 1;
        }
        static getInterpolation(e, t, i, n, r, a, o, c) {
          return this.getBarycoord(e, t, i, n, An) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(r, An.x), c.addScaledVector(a, An.y), c.addScaledVector(o, An.z), c);
        }
        static getInterpolatedAttribute(e, t, i, n, r, a) {
          return Ac.setScalar(0), gc.setScalar(0), _c.setScalar(0), Ac.fromBufferAttribute(e, t), gc.fromBufferAttribute(e, i), _c.fromBufferAttribute(e, n), a.setScalar(0), a.addScaledVector(Ac, r.x), a.addScaledVector(gc, r.y), a.addScaledVector(_c, r.z), a;
        }
        static isFrontFacing(e, t, i, n) {
          return Hi.subVectors(i, t), pn.subVectors(e, t), Hi.cross(pn).dot(n) < 0;
        }
        set(e, t, i) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
        }
        setFromPointsAndIndices(e, t, i, n) {
          return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
        }
        setFromAttributeAndIndices(e, t, i, n) {
          return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return Hi.subVectors(this.c, this.b), pn.subVectors(this.a, this.b), Hi.cross(pn).length() * 0.5;
        }
        getMidpoint(e) {
          return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return zr.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return zr.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, i, n, r) {
          return zr.getInterpolation(e, this.a, this.b, this.c, t, i, n, r);
        }
        containsPoint(e) {
          return zr.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return zr.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a, n = this.b, r = this.c;
          let a, o;
          Br.subVectors(n, i), Dr.subVectors(r, i), uc.subVectors(e, i);
          const c = Br.dot(uc), l = Dr.dot(uc);
          if (c <= 0 && l <= 0) return t.copy(i);
          fc.subVectors(e, n);
          const h = Br.dot(fc), d = Dr.dot(fc);
          if (h >= 0 && d <= h) return t.copy(n);
          const u = c * d - h * l;
          if (u <= 0 && c >= 0 && h <= 0) return a = c / (c - h), t.copy(i).addScaledVector(Br, a);
          pc.subVectors(e, r);
          const f = Br.dot(pc), p = Dr.dot(pc);
          if (p >= 0 && f <= p) return t.copy(r);
          const m = f * l - c * p;
          if (m <= 0 && l >= 0 && p <= 0) return o = l / (l - p), t.copy(i).addScaledVector(Dr, o);
          const g = h * p - f * d;
          if (g <= 0 && d - h >= 0 && f - p >= 0) return Od.subVectors(r, n), o = (d - h) / (d - h + (f - p)), t.copy(n).addScaledVector(Od, o);
          const A = 1 / (g + m + u);
          return a = m * A, o = u * A, t.copy(i).addScaledVector(Br, a).addScaledVector(Dr, o);
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      };
      const ip = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      }, Fn = {
        h: 0,
        s: 0,
        l: 0
      }, xa = {
        h: 0,
        s: 0,
        l: 0
      };
      function mc(s, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
      }
      class ue {
        constructor(e, t, i) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
        }
        set(e, t, i) {
          if (t === void 0 && i === void 0) {
            const n = e;
            n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
          } else this.setRGB(e, t, i);
          return this;
        }
        setScalar(e) {
          return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = nt) {
          return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, ze.toWorkingColorSpace(this, t), this;
        }
        setRGB(e, t, i, n = ze.workingColorSpace) {
          return this.r = e, this.g = t, this.b = i, ze.toWorkingColorSpace(this, n), this;
        }
        setHSL(e, t, i, n = ze.workingColorSpace) {
          if (e = xh(e, 1), t = He(t, 0, 1), i = He(i, 0, 1), t === 0) this.r = this.g = this.b = i;
          else {
            const r = i <= 0.5 ? i * (1 + t) : i + t - i * t, a = 2 * i - r;
            this.r = mc(a, r, e + 1 / 3), this.g = mc(a, r, e), this.b = mc(a, r, e - 1 / 3);
          }
          return ze.toWorkingColorSpace(this, n), this;
        }
        setStyle(e, t = nt) {
          function i(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
          }
          let n;
          if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const a = n[1], o = n[2];
            switch (a) {
              case "rgb":
              case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                break;
              case "hsl":
              case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = n[1], a = r.length;
            if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (a === 6) return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = nt) {
          const i = ip[e.toLowerCase()];
          return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
          return this.r = En(e.r), this.g = En(e.g), this.b = En(e.b), this;
        }
        copyLinearToSRGB(e) {
          return this.r = Yr(e.r), this.g = Yr(e.g), this.b = Yr(e.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = nt) {
          return ze.fromWorkingColorSpace(ai.copy(this), e), Math.round(He(ai.r * 255, 0, 255)) * 65536 + Math.round(He(ai.g * 255, 0, 255)) * 256 + Math.round(He(ai.b * 255, 0, 255));
        }
        getHexString(e = nt) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = ze.workingColorSpace) {
          ze.fromWorkingColorSpace(ai.copy(this), t);
          const i = ai.r, n = ai.g, r = ai.b, a = Math.max(i, n, r), o = Math.min(i, n, r);
          let c, l;
          const h = (o + a) / 2;
          if (o === a) c = 0, l = 0;
          else {
            const d = a - o;
            switch (l = h <= 0.5 ? d / (a + o) : d / (2 - a - o), a) {
              case i:
                c = (n - r) / d + (n < r ? 6 : 0);
                break;
              case n:
                c = (r - i) / d + 2;
                break;
              case r:
                c = (i - n) / d + 4;
                break;
            }
            c /= 6;
          }
          return e.h = c, e.s = l, e.l = h, e;
        }
        getRGB(e, t = ze.workingColorSpace) {
          return ze.fromWorkingColorSpace(ai.copy(this), t), e.r = ai.r, e.g = ai.g, e.b = ai.b, e;
        }
        getStyle(e = nt) {
          ze.fromWorkingColorSpace(ai.copy(this), e);
          const t = ai.r, i = ai.g, n = ai.b;
          return e !== nt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
        }
        offsetHSL(e, t, i) {
          return this.getHSL(Fn), this.setHSL(Fn.h + e, Fn.s + t, Fn.l + i);
        }
        add(e) {
          return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
          return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
          return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
          return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
          return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
          return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
          return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, i) {
          return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
        }
        lerpHSL(e, t) {
          this.getHSL(Fn), e.getHSL(xa);
          const i = Ps(Fn.h, xa.h, t), n = Ps(Fn.s, xa.s, t), r = Ps(Fn.l, xa.l, t);
          return this.setHSL(i, n, r), this;
        }
        setFromVector3(e) {
          return this.r = e.x, this.g = e.y, this.b = e.z, this;
        }
        applyMatrix3(e) {
          const t = this.r, i = this.g, n = this.b, r = e.elements;
          return this.r = r[0] * t + r[3] * i + r[6] * n, this.g = r[1] * t + r[4] * i + r[7] * n, this.b = r[2] * t + r[5] * i + r[8] * n, this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
          return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const ai = new ue();
      ue.NAMES = ip;
      let S_ = 0;
      class Fi extends jn {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", {
            value: S_++
          }), this.uuid = $i(), this.name = "", this.type = "Material", this.blending = Xr, this.side = Sn, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = dl, this.blendDst = ul, this.blendEquation = cr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ue(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Zr, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Cd, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Er, this.stencilZFail = Er, this.stencilZPass = Er, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.allowOverride = true, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0) for (const t in e) {
            const i = e[t];
            if (i === void 0) {
              console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
              continue;
            }
            const n = this[t];
            if (n === void 0) {
              console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
              continue;
            }
            n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = {
            textures: {},
            images: {}
          });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Xr && (i.blending = this.blending), this.side !== Sn && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== dl && (i.blendSrc = this.blendSrc), this.blendDst !== ul && (i.blendDst = this.blendDst), this.blendEquation !== cr && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Zr && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Cd && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Er && (i.stencilFail = this.stencilFail), this.stencilZFail !== Er && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Er && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function n(r) {
            const a = [];
            for (const o in r) {
              const c = r[o];
              delete c.metadata, a.push(c);
            }
            return a;
          }
          if (t) {
            const r = n(e.textures), a = n(e.images);
            r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
          const t = e.clippingPlanes;
          let i = null;
          if (t !== null) {
            const n = t.length;
            i = new Array(n);
            for (let r = 0; r !== n; ++r) i[r] = t[r].clone();
          }
          return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class Zi extends Fi {
        constructor(e) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ht(), this.combine = Do, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
      }
      const Ft = new T(), Ea = new oe();
      let C_ = 0;
      class ni {
        constructor(e, t, i = false) {
          if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, Object.defineProperty(this, "id", {
            value: C_++
          }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Ol, this.updateRanges = [], this.gpuType = ii, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({
            start: e,
            count: t
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
        }
        copyAt(e, t, i) {
          e *= this.itemSize, i *= t.itemSize;
          for (let n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) Ea.fromBufferAttribute(this, t), Ea.applyMatrix3(e), this.setXY(t, Ea.x, Ea.y);
          else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.applyMatrix3(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.applyMatrix4(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.applyNormalMatrix(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) Ft.fromBufferAttribute(this, t), Ft.transformDirection(e), this.setXYZ(t, Ft.x, Ft.y, Ft.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.itemSize + t];
          return this.normalized && (i = Ki(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = ft(i, this.array)), this.array[e * this.itemSize + t] = i, this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        setX(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        setY(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        setZ(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        setW(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, i) {
          return e *= this.itemSize, this.normalized && (t = ft(t, this.array), i = ft(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
        }
        setXYZ(e, t, i, n) {
          return e *= this.itemSize, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), n = ft(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
        }
        setXYZW(e, t, i, n, r) {
          return e *= this.itemSize, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), n = ft(n, this.array), r = ft(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return this.name !== "" && (e.name = this.name), this.usage !== Ol && (e.usage = this.usage), e;
        }
      }
      class ko extends ni {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class np extends ni {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class _t extends ni {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let I_ = 0;
      const Ti = new ge(), wc = new ct(), Pr = new T(), yi = new on(), ms = new on(), Yt = new T();
      class Qt extends jn {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
            value: I_++
          }), this.uuid = $i(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return Array.isArray(e) ? this.index = new (Zf(e) ? np : ko)(e, 1) : this.index = e, this;
        }
        setIndirect(e) {
          return this.indirect = e, this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, i = 0) {
          this.groups.push({
            start: e,
            count: t,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
          const i = this.attributes.normal;
          if (i !== void 0) {
            const r = new Oe().getNormalMatrix(e);
            i.applyNormalMatrix(r), i.needsUpdate = true;
          }
          const n = this.attributes.tangent;
          return n !== void 0 && (n.transformDirection(e), n.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
          return Ti.makeRotationFromQuaternion(e), this.applyMatrix4(Ti), this;
        }
        rotateX(e) {
          return Ti.makeRotationX(e), this.applyMatrix4(Ti), this;
        }
        rotateY(e) {
          return Ti.makeRotationY(e), this.applyMatrix4(Ti), this;
        }
        rotateZ(e) {
          return Ti.makeRotationZ(e), this.applyMatrix4(Ti), this;
        }
        translate(e, t, i) {
          return Ti.makeTranslation(e, t, i), this.applyMatrix4(Ti), this;
        }
        scale(e, t, i) {
          return Ti.makeScale(e, t, i), this.applyMatrix4(Ti), this;
        }
        lookAt(e) {
          return wc.lookAt(e), wc.updateMatrix(), this.applyMatrix4(wc.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(Pr).negate(), this.translate(Pr.x, Pr.y, Pr.z), this;
        }
        setFromPoints(e) {
          const t = this.getAttribute("position");
          if (t === void 0) {
            const i = [];
            for (let n = 0, r = e.length; n < r; n++) {
              const a = e[n];
              i.push(a.x, a.y, a.z || 0);
            }
            this.setAttribute("position", new _t(i, 3));
          } else {
            const i = Math.min(e.length, t.count);
            for (let n = 0; n < i; n++) {
              const r = e[n];
              t.setXYZ(n, r.x, r.y, r.z || 0);
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = true;
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new on());
          const e = this.attributes.position, t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new T(-1 / 0, -1 / 0, -1 / 0), new T(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, n = t.length; i < n; i++) {
              const r = t[i];
              yi.setFromBufferAttribute(r), this.morphTargetsRelative ? (Yt.addVectors(this.boundingBox.min, yi.min), this.boundingBox.expandByPoint(Yt), Yt.addVectors(this.boundingBox.max, yi.max), this.boundingBox.expandByPoint(Yt)) : (this.boundingBox.expandByPoint(yi.min), this.boundingBox.expandByPoint(yi.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new cn());
          const e = this.attributes.position, t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new T(), 1 / 0);
            return;
          }
          if (e) {
            const i = this.boundingSphere.center;
            if (yi.setFromBufferAttribute(e), t) for (let r = 0, a = t.length; r < a; r++) {
              const o = t[r];
              ms.setFromBufferAttribute(o), this.morphTargetsRelative ? (Yt.addVectors(yi.min, ms.min), yi.expandByPoint(Yt), Yt.addVectors(yi.max, ms.max), yi.expandByPoint(Yt)) : (yi.expandByPoint(ms.min), yi.expandByPoint(ms.max));
            }
            yi.getCenter(i);
            let n = 0;
            for (let r = 0, a = e.count; r < a; r++) Yt.fromBufferAttribute(e, r), n = Math.max(n, i.distanceToSquared(Yt));
            if (t) for (let r = 0, a = t.length; r < a; r++) {
              const o = t[r], c = this.morphTargetsRelative;
              for (let l = 0, h = o.count; l < h; l++) Yt.fromBufferAttribute(o, l), c && (Pr.fromBufferAttribute(e, l), Yt.add(Pr)), n = Math.max(n, i.distanceToSquared(Yt));
            }
            this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const e = this.index, t = this.attributes;
          if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = t.position, n = t.normal, r = t.uv;
          this.hasAttribute("tangent") === false && this.setAttribute("tangent", new ni(new Float32Array(4 * i.count), 4));
          const a = this.getAttribute("tangent"), o = [], c = [];
          for (let D = 0; D < i.count; D++) o[D] = new T(), c[D] = new T();
          const l = new T(), h = new T(), d = new T(), u = new oe(), f = new oe(), p = new oe(), m = new T(), g = new T();
          function A(D, S, E) {
            l.fromBufferAttribute(i, D), h.fromBufferAttribute(i, S), d.fromBufferAttribute(i, E), u.fromBufferAttribute(r, D), f.fromBufferAttribute(r, S), p.fromBufferAttribute(r, E), h.sub(l), d.sub(l), f.sub(u), p.sub(u);
            const P = 1 / (f.x * p.y - p.x * f.y);
            isFinite(P) && (m.copy(h).multiplyScalar(p.y).addScaledVector(d, -f.y).multiplyScalar(P), g.copy(d).multiplyScalar(f.x).addScaledVector(h, -p.x).multiplyScalar(P), o[D].add(m), o[S].add(m), o[E].add(m), c[D].add(g), c[S].add(g), c[E].add(g));
          }
          let x = this.groups;
          x.length === 0 && (x = [
            {
              start: 0,
              count: e.count
            }
          ]);
          for (let D = 0, S = x.length; D < S; ++D) {
            const E = x[D], P = E.start, j = E.count;
            for (let H = P, Y = P + j; H < Y; H += 3) A(e.getX(H + 0), e.getX(H + 1), e.getX(H + 2));
          }
          const b = new T(), y = new T(), I = new T(), M = new T();
          function R(D) {
            I.fromBufferAttribute(n, D), M.copy(I);
            const S = o[D];
            b.copy(S), b.sub(I.multiplyScalar(I.dot(S))).normalize(), y.crossVectors(M, S);
            const P = y.dot(c[D]) < 0 ? -1 : 1;
            a.setXYZW(D, b.x, b.y, b.z, P);
          }
          for (let D = 0, S = x.length; D < S; ++D) {
            const E = x[D], P = E.start, j = E.count;
            for (let H = P, Y = P + j; H < Y; H += 3) R(e.getX(H + 0)), R(e.getX(H + 1)), R(e.getX(H + 2));
          }
        }
        computeVertexNormals() {
          const e = this.index, t = this.getAttribute("position");
          if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new ni(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
            else for (let u = 0, f = i.count; u < f; u++) i.setXYZ(u, 0, 0, 0);
            const n = new T(), r = new T(), a = new T(), o = new T(), c = new T(), l = new T(), h = new T(), d = new T();
            if (e) for (let u = 0, f = e.count; u < f; u += 3) {
              const p = e.getX(u + 0), m = e.getX(u + 1), g = e.getX(u + 2);
              n.fromBufferAttribute(t, p), r.fromBufferAttribute(t, m), a.fromBufferAttribute(t, g), h.subVectors(a, r), d.subVectors(n, r), h.cross(d), o.fromBufferAttribute(i, p), c.fromBufferAttribute(i, m), l.fromBufferAttribute(i, g), o.add(h), c.add(h), l.add(h), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(m, c.x, c.y, c.z), i.setXYZ(g, l.x, l.y, l.z);
            }
            else for (let u = 0, f = t.count; u < f; u += 3) n.fromBufferAttribute(t, u + 0), r.fromBufferAttribute(t, u + 1), a.fromBufferAttribute(t, u + 2), h.subVectors(a, r), d.subVectors(n, r), h.cross(d), i.setXYZ(u + 0, h.x, h.y, h.z), i.setXYZ(u + 1, h.x, h.y, h.z), i.setXYZ(u + 2, h.x, h.y, h.z);
            this.normalizeNormals(), i.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++) Yt.fromBufferAttribute(e, t), Yt.normalize(), e.setXYZ(t, Yt.x, Yt.y, Yt.z);
        }
        toNonIndexed() {
          function e(o, c) {
            const l = o.array, h = o.itemSize, d = o.normalized, u = new l.constructor(c.length * h);
            let f = 0, p = 0;
            for (let m = 0, g = c.length; m < g; m++) {
              o.isInterleavedBufferAttribute ? f = c[m] * o.data.stride + o.offset : f = c[m] * h;
              for (let A = 0; A < h; A++) u[p++] = l[f++];
            }
            return new ni(u, h, d);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const t = new Qt(), i = this.index.array, n = this.attributes;
          for (const o in n) {
            const c = n[o], l = e(c, i);
            t.setAttribute(o, l);
          }
          const r = this.morphAttributes;
          for (const o in r) {
            const c = [], l = r[o];
            for (let h = 0, d = l.length; h < d; h++) {
              const u = l[h], f = e(u, i);
              c.push(f);
            }
            t.morphAttributes[o] = c;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let o = 0, c = a.length; o < c; o++) {
            const l = a[o];
            t.addGroup(l.start, l.count, l.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const c = this.parameters;
            for (const l in c) c[l] !== void 0 && (e[l] = c[l]);
            return e;
          }
          e.data = {
            attributes: {}
          };
          const t = this.index;
          t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
          });
          const i = this.attributes;
          for (const c in i) {
            const l = i[c];
            e.data.attributes[c] = l.toJSON(e.data);
          }
          const n = {};
          let r = false;
          for (const c in this.morphAttributes) {
            const l = this.morphAttributes[c], h = [];
            for (let d = 0, u = l.length; d < u; d++) {
              const f = l[d];
              h.push(f.toJSON(e.data));
            }
            h.length > 0 && (n[c] = h, r = true);
          }
          r && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
          const a = this.groups;
          a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
          const o = this.boundingSphere;
          return o !== null && (e.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
          }), e;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const t = {};
          this.name = e.name;
          const i = e.index;
          i !== null && this.setIndex(i.clone());
          const n = e.attributes;
          for (const l in n) {
            const h = n[l];
            this.setAttribute(l, h.clone(t));
          }
          const r = e.morphAttributes;
          for (const l in r) {
            const h = [], d = r[l];
            for (let u = 0, f = d.length; u < f; u++) h.push(d[u].clone(t));
            this.morphAttributes[l] = h;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const a = e.groups;
          for (let l = 0, h = a.length; l < h; l++) {
            const d = a[l];
            this.addGroup(d.start, d.count, d.materialIndex);
          }
          const o = e.boundingBox;
          o !== null && (this.boundingBox = o.clone());
          const c = e.boundingSphere;
          return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const zd = new ge(), Jn = new os(), va = new cn(), Gd = new T(), Sa = new T(), Ca = new T(), Ia = new T(), bc = new T(), Ma = new T(), Hd = new T(), Ta = new T();
      class yt extends ct {
        constructor(e = new Qt(), t = new Zi()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes, i = Object.keys(t);
          if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const o = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const i = this.geometry, n = i.attributes.position, r = i.morphAttributes.position, a = i.morphTargetsRelative;
          t.fromBufferAttribute(n, e);
          const o = this.morphTargetInfluences;
          if (r && o) {
            Ma.set(0, 0, 0);
            for (let c = 0, l = r.length; c < l; c++) {
              const h = o[c], d = r[c];
              h !== 0 && (bc.fromBufferAttribute(d, e), a ? Ma.addScaledVector(bc, h) : Ma.addScaledVector(bc.sub(t), h));
            }
            t.add(Ma);
          }
          return t;
        }
        raycast(e, t) {
          const i = this.geometry, n = this.material, r = this.matrixWorld;
          n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), va.copy(i.boundingSphere), va.applyMatrix4(r), Jn.copy(e.ray).recast(e.near), !(va.containsPoint(Jn.origin) === false && (Jn.intersectSphere(va, Gd) === null || Jn.origin.distanceToSquared(Gd) > (e.far - e.near) ** 2)) && (zd.copy(r).invert(), Jn.copy(e.ray).applyMatrix4(zd), !(i.boundingBox !== null && Jn.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, Jn)));
        }
        _computeIntersections(e, t, i) {
          let n;
          const r = this.geometry, a = this.material, o = r.index, c = r.attributes.position, l = r.attributes.uv, h = r.attributes.uv1, d = r.attributes.normal, u = r.groups, f = r.drawRange;
          if (o !== null) if (Array.isArray(a)) for (let p = 0, m = u.length; p < m; p++) {
            const g = u[p], A = a[g.materialIndex], x = Math.max(g.start, f.start), b = Math.min(o.count, Math.min(g.start + g.count, f.start + f.count));
            for (let y = x, I = b; y < I; y += 3) {
              const M = o.getX(y), R = o.getX(y + 1), D = o.getX(y + 2);
              n = Ra(this, A, e, i, l, h, d, M, R, D), n && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = g.materialIndex, t.push(n));
            }
          }
          else {
            const p = Math.max(0, f.start), m = Math.min(o.count, f.start + f.count);
            for (let g = p, A = m; g < A; g += 3) {
              const x = o.getX(g), b = o.getX(g + 1), y = o.getX(g + 2);
              n = Ra(this, a, e, i, l, h, d, x, b, y), n && (n.faceIndex = Math.floor(g / 3), t.push(n));
            }
          }
          else if (c !== void 0) if (Array.isArray(a)) for (let p = 0, m = u.length; p < m; p++) {
            const g = u[p], A = a[g.materialIndex], x = Math.max(g.start, f.start), b = Math.min(c.count, Math.min(g.start + g.count, f.start + f.count));
            for (let y = x, I = b; y < I; y += 3) {
              const M = y, R = y + 1, D = y + 2;
              n = Ra(this, A, e, i, l, h, d, M, R, D), n && (n.faceIndex = Math.floor(y / 3), n.face.materialIndex = g.materialIndex, t.push(n));
            }
          }
          else {
            const p = Math.max(0, f.start), m = Math.min(c.count, f.start + f.count);
            for (let g = p, A = m; g < A; g += 3) {
              const x = g, b = g + 1, y = g + 2;
              n = Ra(this, a, e, i, l, h, d, x, b, y), n && (n.faceIndex = Math.floor(g / 3), t.push(n));
            }
          }
        }
      }
      function M_(s, e, t, i, n, r, a, o) {
        let c;
        if (e.side === _i ? c = i.intersectTriangle(a, r, n, true, o) : c = i.intersectTriangle(n, r, a, e.side === Sn, o), c === null) return null;
        Ta.copy(o), Ta.applyMatrix4(s.matrixWorld);
        const l = t.ray.origin.distanceTo(Ta);
        return l < t.near || l > t.far ? null : {
          distance: l,
          point: Ta.clone(),
          object: s
        };
      }
      function Ra(s, e, t, i, n, r, a, o, c, l) {
        s.getVertexPosition(o, Sa), s.getVertexPosition(c, Ca), s.getVertexPosition(l, Ia);
        const h = M_(s, e, t, i, Sa, Ca, Ia, Hd);
        if (h) {
          const d = new T();
          _s.getBarycoord(Hd, Sa, Ca, Ia, d), n && (h.uv = _s.getInterpolatedAttribute(n, o, c, l, d, new oe())), r && (h.uv1 = _s.getInterpolatedAttribute(r, o, c, l, d, new oe())), a && (h.normal = _s.getInterpolatedAttribute(a, o, c, l, d, new T()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
          const u = {
            a: o,
            b: c,
            c: l,
            normal: new T(),
            materialIndex: 0
          };
          _s.getNormal(Sa, Ca, Ia, u.normal), h.face = u, h.barycoord = d;
        }
        return h;
      }
      class cs extends Qt {
        constructor(e = 1, t = 1, i = 1, n = 1, r = 1, a = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
          };
          const o = this;
          n = Math.floor(n), r = Math.floor(r), a = Math.floor(a);
          const c = [], l = [], h = [], d = [];
          let u = 0, f = 0;
          p("z", "y", "x", -1, -1, i, t, e, a, r, 0), p("z", "y", "x", 1, -1, i, t, -e, a, r, 1), p("x", "z", "y", 1, 1, e, i, t, n, a, 2), p("x", "z", "y", 1, -1, e, i, -t, n, a, 3), p("x", "y", "z", 1, -1, e, t, i, n, r, 4), p("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(c), this.setAttribute("position", new _t(l, 3)), this.setAttribute("normal", new _t(h, 3)), this.setAttribute("uv", new _t(d, 2));
          function p(m, g, A, x, b, y, I, M, R, D, S) {
            const E = y / R, P = I / D, j = y / 2, H = I / 2, Y = M / 2, te = R + 1, q = D + 1;
            let Z = 0, V = 0;
            const re = new T();
            for (let he = 0; he < q; he++) {
              const ve = he * P - H;
              for (let Pe = 0; Pe < te; Pe++) {
                const Ve = Pe * E - j;
                re[m] = Ve * x, re[g] = ve * b, re[A] = Y, l.push(re.x, re.y, re.z), re[m] = 0, re[g] = 0, re[A] = M > 0 ? 1 : -1, h.push(re.x, re.y, re.z), d.push(Pe / R), d.push(1 - he / D), Z += 1;
              }
            }
            for (let he = 0; he < D; he++) for (let ve = 0; ve < R; ve++) {
              const Pe = u + ve + te * he, Ve = u + ve + te * (he + 1), K = u + (ve + 1) + te * (he + 1), ae = u + (ve + 1) + te * he;
              c.push(Pe, Ve, ae), c.push(Ve, K, ae), V += 6;
            }
            o.addGroup(f, V, S), f += V, u += Z;
          }
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new cs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
      }
      function ts(s) {
        const e = {};
        for (const t in s) {
          e[t] = {};
          for (const i in s[t]) {
            const n = s[t][i];
            n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
          }
        }
        return e;
      }
      function di(s) {
        const e = {};
        for (let t = 0; t < s.length; t++) {
          const i = ts(s[t]);
          for (const n in i) e[n] = i[n];
        }
        return e;
      }
      function T_(s) {
        const e = [];
        for (let t = 0; t < s.length; t++) e.push(s[t].clone());
        return e;
      }
      function rp(s) {
        const e = s.getRenderTarget();
        return e === null ? s.outputColorSpace : e.isXRRenderTarget === true ? e.texture.colorSpace : ze.workingColorSpace;
      }
      const Uo = {
        clone: ts,
        merge: di
      };
      var R_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, B_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class ki extends Fi {
        constructor(e) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = R_, this.fragmentShader = B_, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
            clipCullDistance: false,
            multiDraw: false
          }, this.defaultAttributeValues = {
            color: [
              1,
              1,
              1
            ],
            uv: [
              0,
              0
            ],
            uv1: [
              0,
              0
            ]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ts(e.uniforms), this.uniformsGroups = T_(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.glslVersion = this.glslVersion, t.uniforms = {};
          for (const n in this.uniforms) {
            const a = this.uniforms[n].value;
            a && a.isTexture ? t.uniforms[n] = {
              type: "t",
              value: a.toJSON(e).uuid
            } : a && a.isColor ? t.uniforms[n] = {
              type: "c",
              value: a.getHex()
            } : a && a.isVector2 ? t.uniforms[n] = {
              type: "v2",
              value: a.toArray()
            } : a && a.isVector3 ? t.uniforms[n] = {
              type: "v3",
              value: a.toArray()
            } : a && a.isVector4 ? t.uniforms[n] = {
              type: "v4",
              value: a.toArray()
            } : a && a.isMatrix3 ? t.uniforms[n] = {
              type: "m3",
              value: a.toArray()
            } : a && a.isMatrix4 ? t.uniforms[n] = {
              type: "m4",
              value: a.toArray()
            } : t.uniforms[n] = {
              value: a
            };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
          const i = {};
          for (const n in this.extensions) this.extensions[n] === true && (i[n] = true);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }
      }
      class yo extends ct {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new ge(), this.projectionMatrix = new ge(), this.projectionMatrixInverse = new ge(), this.coordinateSystem = xn;
        }
        copy(e, t) {
          return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
        }
        getWorldDirection(e) {
          return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const kn = new T(), Vd = new oe(), Wd = new oe();
      class Vt extends yo {
        constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
          const t = 0.5 * this.getFilmHeight() / e;
          this.fov = es * 2 * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(Ds * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
          return es * 2 * Math.atan(Math.tan(Ds * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, i) {
          kn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(kn.x, kn.y).multiplyScalar(-e / kn.z), kn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(kn.x, kn.y).multiplyScalar(-e / kn.z);
        }
        getViewSize(e, t) {
          return this.getViewBounds(e, Vd, Wd), t.subVectors(Wd, Vd);
        }
        setViewOffset(e, t, i, n, r, a) {
          this.aspect = e / t, this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = e * Math.tan(Ds * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -0.5 * n;
          const a = this.view;
          if (this.view !== null && this.view.enabled) {
            const c = a.fullWidth, l = a.fullHeight;
            r += a.offsetX * n / c, t -= a.offsetY * i / l, n *= a.width / c, i *= a.height / l;
          }
          const o = this.filmOffset;
          o !== 0 && (r += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
      }
      const Lr = -90, Fr = 1;
      class D_ extends ct {
        constructor(e, t, i) {
          super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
          const n = new Vt(Lr, Fr, e, t);
          n.layers = this.layers, this.add(n);
          const r = new Vt(Lr, Fr, e, t);
          r.layers = this.layers, this.add(r);
          const a = new Vt(Lr, Fr, e, t);
          a.layers = this.layers, this.add(a);
          const o = new Vt(Lr, Fr, e, t);
          o.layers = this.layers, this.add(o);
          const c = new Vt(Lr, Fr, e, t);
          c.layers = this.layers, this.add(c);
          const l = new Vt(Lr, Fr, e, t);
          l.layers = this.layers, this.add(l);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem, t = this.children.concat(), [i, n, r, a, o, c] = t;
          for (const l of t) this.remove(l);
          if (e === xn) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
          else if (e === bo) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
          for (const l of t) this.add(l), l.updateMatrixWorld();
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: n } = this;
          this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
          const [r, a, o, c, l, h] = this.children, d = e.getRenderTarget(), u = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), p = e.xr.enabled;
          e.xr.enabled = false;
          const m = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, n), e.render(t, r), e.setRenderTarget(i, 1, n), e.render(t, a), e.setRenderTarget(i, 2, n), e.render(t, o), e.setRenderTarget(i, 3, n), e.render(t, c), e.setRenderTarget(i, 4, n), e.render(t, l), i.texture.generateMipmaps = m, e.setRenderTarget(i, 5, n), e.render(t, h), e.setRenderTarget(d, u, f), e.xr.enabled = p, i.texture.needsPMREMUpdate = true;
        }
      }
      class Sh extends Nt {
        constructor(e = [], t = pr, i, n, r, a, o, c, l, h) {
          super(e, t, i, n, r, a, o, c, l, h), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class P_ extends Cn {
        constructor(e = 1, t = {}) {
          super(e, e, t), this.isWebGLCubeRenderTarget = true;
          const i = {
            width: e,
            height: e,
            depth: 1
          }, n = [
            i,
            i,
            i,
            i,
            i,
            i
          ];
          this.texture = new Sh(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Rt;
        }
        fromEquirectangularTexture(e, t) {
          this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
          const i = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          }, n = new cs(5, 5, 5), r = new ki({
            name: "CubemapFromEquirect",
            uniforms: ts(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: _i,
            blending: zn
          });
          r.uniforms.tEquirect.value = t;
          const a = new yt(n, r), o = t.minFilter;
          return t.minFilter === Ji && (t.minFilter = Rt), new D_(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(e, t = true, i = true, n = true) {
          const r = e.getRenderTarget();
          for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, n);
          e.setRenderTarget(r);
        }
      }
      class Li extends ct {
        constructor() {
          super(), this.isGroup = true, this.type = "Group";
        }
      }
      const L_ = {
        type: "move"
      };
      class yc {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return this._hand === null && (this._hand = new Li(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
            pinching: false
          }), this._hand;
        }
        getTargetRaySpace() {
          return this._targetRay === null && (this._targetRay = new Li(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new T(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new T()), this._targetRay;
        }
        getGripSpace() {
          return this._grip === null && (this._grip = new Li(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new T(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new T()), this._grip;
        }
        dispatchEvent(e) {
          return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
          }
          return this.dispatchEvent({
            type: "connected",
            data: e
          }), this;
        }
        disconnect(e) {
          return this.dispatchEvent({
            type: "disconnected",
            data: e
          }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
        }
        update(e, t, i) {
          let n = null, r = null, a = null;
          const o = this._targetRay, c = this._grip, l = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred") {
            if (l && e.hand) {
              a = true;
              for (const m of e.hand.values()) {
                const g = t.getJointPose(m, i), A = this._getHandJoint(l, m);
                g !== null && (A.matrix.fromArray(g.transform.matrix), A.matrix.decompose(A.position, A.rotation, A.scale), A.matrixWorldNeedsUpdate = true, A.jointRadius = g.radius), A.visible = g !== null;
              }
              const h = l.joints["index-finger-tip"], d = l.joints["thumb-tip"], u = h.position.distanceTo(d.position), f = 0.02, p = 5e-3;
              l.inputState.pinching && u > f + p ? (l.inputState.pinching = false, this.dispatchEvent({
                type: "pinchend",
                handedness: e.handedness,
                target: this
              })) : !l.inputState.pinching && u <= f - p && (l.inputState.pinching = true, this.dispatchEvent({
                type: "pinchstart",
                handedness: e.handedness,
                target: this
              }));
            } else c !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = true, r.linearVelocity ? (c.hasLinearVelocity = true, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = false, r.angularVelocity ? (c.hasAngularVelocity = true, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = false));
            o !== null && (n = t.getPose(e.targetRaySpace, i), n === null && r !== null && (n = r), n !== null && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = true, n.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = false, n.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(L_)));
          }
          return o !== null && (o.visible = n !== null), c !== null && (c.visible = r !== null), l !== null && (l.visible = a !== null), this;
        }
        _getHandJoint(e, t) {
          if (e.joints[t.jointName] === void 0) {
            const i = new Li();
            i.matrixAutoUpdate = false, i.visible = false, e.joints[t.jointName] = i, e.add(i);
          }
          return e.joints[t.jointName];
        }
      }
      class Ch {
        constructor(e, t = 25e-5) {
          this.isFogExp2 = true, this.name = "", this.color = new ue(e), this.density = t;
        }
        clone() {
          return new Ch(this.color, this.density);
        }
        toJSON() {
          return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
          };
        }
      }
      class ao extends ct {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Ht(), this.environmentIntensity = 1, this.environmentRotation = new Ht(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(e, t) {
          return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
        }
      }
      class F_ {
        constructor(e, t) {
          this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Ol, this.updateRanges = [], this.version = 0, this.uuid = $i();
        }
        onUploadCallback() {
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({
            start: e,
            count: t
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, i) {
          e *= this.stride, i *= t.stride;
          for (let n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = $i()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        toJSON(e) {
          return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = $i()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      const li = new T();
      class Ih {
        constructor(e, t, i, n = false) {
          this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.data.count; t < i; t++) li.fromBufferAttribute(this, t), li.applyMatrix4(e), this.setXYZ(t, li.x, li.y, li.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) li.fromBufferAttribute(this, t), li.applyNormalMatrix(e), this.setXYZ(t, li.x, li.y, li.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) li.fromBufferAttribute(this, t), li.transformDirection(e), this.setXYZ(t, li.x, li.y, li.z);
          return this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.data.stride + this.offset + t];
          return this.normalized && (i = Ki(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = ft(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
        }
        setX(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
          return this.normalized && (t = ft(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = Ki(t, this.array)), t;
        }
        setXY(e, t, i) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = ft(t, this.array), i = ft(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
        }
        setXYZ(e, t, i, n) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), n = ft(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
        }
        setXYZW(e, t, i, n, r) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = ft(t, this.array), i = ft(i, this.array), n = ft(n, this.array), r = ft(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this;
        }
        clone(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const n = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r]);
            }
            return new ni(new this.array.constructor(t), this.itemSize, this.normalized);
          } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Ih(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const n = i * this.data.stride + this.offset;
              for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[n + r]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized
            };
          } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
      const jd = new T(), qd = new je(), Xd = new je(), k_ = new T(), Yd = new ge(), Ba = new T(), xc = new cn(), Kd = new ge(), Ec = new os();
      class Mh extends yt {
        constructor(e, t) {
          super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Sd, this.bindMatrix = new ge(), this.bindMatrixInverse = new ge(), this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
          const e = this.geometry;
          this.boundingBox === null && (this.boundingBox = new on()), this.boundingBox.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Ba), this.boundingBox.expandByPoint(Ba);
        }
        computeBoundingSphere() {
          const e = this.geometry;
          this.boundingSphere === null && (this.boundingSphere = new cn()), this.boundingSphere.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Ba), this.boundingSphere.expandByPoint(Ba);
        }
        copy(e, t) {
          return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        raycast(e, t) {
          const i = this.material, n = this.matrixWorld;
          i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), xc.copy(this.boundingSphere), xc.applyMatrix4(n), e.ray.intersectsSphere(xc) !== false && (Kd.copy(n).invert(), Ec.copy(e.ray).applyMatrix4(Kd), !(this.boundingBox !== null && Ec.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, Ec)));
        }
        getVertexPosition(e, t) {
          return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
        }
        bind(e, t) {
          this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new je(), t = this.geometry.attributes.skinWeight;
          for (let i = 0, n = t.count; i < n; i++) {
            e.fromBufferAttribute(t, i);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.bindMode === Sd ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Dg ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(e, t) {
          const i = this.skeleton, n = this.geometry;
          qd.fromBufferAttribute(n.attributes.skinIndex, e), Xd.fromBufferAttribute(n.attributes.skinWeight, e), jd.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
          for (let r = 0; r < 4; r++) {
            const a = Xd.getComponent(r);
            if (a !== 0) {
              const o = qd.getComponent(r);
              Yd.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), t.addScaledVector(k_.copy(jd).applyMatrix4(Yd), a);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class qs extends ct {
        constructor() {
          super(), this.isBone = true, this.type = "Bone";
        }
      }
      class sa extends Nt {
        constructor(e = null, t = 1, i = 1, n, r, a, o, c, l = pi, h = pi, d, u) {
          super(null, a, o, c, l, h, n, r, d, u), this.isDataTexture = true, this.image = {
            data: e,
            width: t,
            height: i
          }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      const Jd = new ge(), U_ = new ge();
      class aa {
        constructor(e = [], t = []) {
          this.uuid = $i(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
          const e = this.bones, t = this.boneInverses;
          if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new ge());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new ge();
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
          }
        }
        update() {
          const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
          for (let r = 0, a = e.length; r < a; r++) {
            const o = e[r] ? e[r].matrixWorld : U_;
            Jd.multiplyMatrices(o, t[r]), Jd.toArray(i, r * 16);
          }
          n !== null && (n.needsUpdate = true);
        }
        clone() {
          return new aa(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const i = new sa(t, e, e, Wt, ii);
          return i.needsUpdate = true, this.boneMatrices = t, this.boneTexture = i, this;
        }
        getBoneByName(e) {
          for (let t = 0, i = this.bones.length; t < i; t++) {
            const n = this.bones[t];
            if (n.name === e) return n;
          }
        }
        dispose() {
          this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let i = 0, n = e.bones.length; i < n; i++) {
            const r = e.bones[i];
            let a = t[r];
            a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new qs()), this.bones.push(a), this.boneInverses.push(new ge().fromArray(e.boneInverses[i]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          e.uuid = this.uuid;
          const t = this.bones, i = this.boneInverses;
          for (let n = 0, r = t.length; n < r; n++) {
            const a = t[n];
            e.bones.push(a.uuid);
            const o = i[n];
            e.boneInverses.push(o.toArray());
          }
          return e;
        }
      }
      class dr extends ni {
        constructor(e, t, i, n = 1) {
          super(e, t, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n;
        }
        copy(e) {
          return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
        }
      }
      const kr = new ge(), Zd = new ge(), Da = [], $d = new on(), N_ = new ge(), ws = new yt(), bs = new cn();
      class Q_ extends yt {
        constructor(e, t, i) {
          super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new dr(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
          for (let n = 0; n < i; n++) this.setMatrixAt(n, N_);
        }
        computeBoundingBox() {
          const e = this.geometry, t = this.count;
          this.boundingBox === null && (this.boundingBox = new on()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, kr), $d.copy(e.boundingBox).applyMatrix4(kr), this.boundingBox.union($d);
        }
        computeBoundingSphere() {
          const e = this.geometry, t = this.count;
          this.boundingSphere === null && (this.boundingSphere = new cn()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, kr), bs.copy(e.boundingSphere).applyMatrix4(kr), this.boundingSphere.union(bs);
        }
        copy(e, t) {
          return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
          const i = t.morphTargetInfluences, n = this.morphTexture.source.data.data, r = i.length + 1, a = e * r + 1;
          for (let o = 0; o < i.length; o++) i[o] = n[a + o];
        }
        raycast(e, t) {
          const i = this.matrixWorld, n = this.count;
          if (ws.geometry = this.geometry, ws.material = this.material, ws.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), bs.copy(this.boundingSphere), bs.applyMatrix4(i), e.ray.intersectsSphere(bs) !== false)) for (let r = 0; r < n; r++) {
            this.getMatrixAt(r, kr), Zd.multiplyMatrices(i, kr), ws.matrixWorld = Zd, ws.raycast(e, Da);
            for (let a = 0, o = Da.length; a < o; a++) {
              const c = Da[a];
              c.instanceId = r, c.object = this, t.push(c);
            }
            Da.length = 0;
          }
        }
        setColorAt(e, t) {
          this.instanceColor === null && (this.instanceColor = new dr(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
          const i = t.morphTargetInfluences, n = i.length + 1;
          this.morphTexture === null && (this.morphTexture = new sa(new Float32Array(n * this.count), n, this.count, yn, ii));
          const r = this.morphTexture.source.data.data;
          let a = 0;
          for (let l = 0; l < i.length; l++) a += i[l];
          const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, c = n * e;
          r[c] = o, r.set(i, c + 1);
        }
        updateMorphTargets() {
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
        }
      }
      const vc = new T(), O_ = new T(), z_ = new Oe();
      class Xi {
        constructor(e = new T(1, 0, 0), t = 0) {
          this.isPlane = true, this.normal = e, this.constant = t;
        }
        set(e, t) {
          return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, i, n) {
          return this.normal.set(e, t, i), this.constant = n, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, i) {
          const n = vc.subVectors(i, t).cross(O_.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const i = e.delta(vc), n = this.normal.dot(i);
          if (n === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / n;
          return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
          return t < 0 && i > 0 || i < 0 && t > 0;
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || z_.getNormalMatrix(e), n = this.coplanarPoint(vc).applyMatrix4(e), r = this.normal.applyMatrix3(i).normalize();
          return this.constant = -n.dot(r), this;
        }
        translate(e) {
          return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Zn = new cn(), Pa = new T();
      class Th {
        constructor(e = new Xi(), t = new Xi(), i = new Xi(), n = new Xi(), r = new Xi(), a = new Xi()) {
          this.planes = [
            e,
            t,
            i,
            n,
            r,
            a
          ];
        }
        set(e, t, i, n, r, a) {
          const o = this.planes;
          return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this;
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
          return this;
        }
        setFromProjectionMatrix(e, t = xn) {
          const i = this.planes, n = e.elements, r = n[0], a = n[1], o = n[2], c = n[3], l = n[4], h = n[5], d = n[6], u = n[7], f = n[8], p = n[9], m = n[10], g = n[11], A = n[12], x = n[13], b = n[14], y = n[15];
          if (i[0].setComponents(c - r, u - l, g - f, y - A).normalize(), i[1].setComponents(c + r, u + l, g + f, y + A).normalize(), i[2].setComponents(c + a, u + h, g + p, y + x).normalize(), i[3].setComponents(c - a, u - h, g - p, y - x).normalize(), i[4].setComponents(c - o, u - d, g - m, y - b).normalize(), t === xn) i[5].setComponents(c + o, u + d, g + m, y + b).normalize();
          else if (t === bo) i[5].setComponents(o, d, m, b).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
          return this;
        }
        intersectsObject(e) {
          if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Zn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), Zn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(Zn);
        }
        intersectsSprite(e) {
          return Zn.center.set(0, 0, 0), Zn.radius = 0.7071067811865476, Zn.applyMatrix4(e.matrixWorld), this.intersectsSphere(Zn);
        }
        intersectsSphere(e) {
          const t = this.planes, i = e.center, n = -e.radius;
          for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(i) < n) return false;
          return true;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const n = t[i];
            if (Pa.x = n.normal.x > 0 ? e.max.x : e.min.x, Pa.y = n.normal.y > 0 ? e.max.y : e.min.y, Pa.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Pa) < 0) return false;
          }
          return true;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class oa extends Fi {
        constructor(e) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new ue(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
      }
      const xo = new T(), Eo = new T(), eu = new ge(), ys = new os(), La = new cn(), Sc = new T(), tu = new T();
      class is extends ct {
        constructor(e = new Qt(), t = new oa()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position, i = [
              0
            ];
            for (let n = 1, r = t.count; n < r; n++) xo.fromBufferAttribute(t, n - 1), Eo.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += xo.distanceTo(Eo);
            e.setAttribute("lineDistance", new _t(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(e, t) {
          const i = this.geometry, n = this.matrixWorld, r = e.params.Line.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), La.copy(i.boundingSphere), La.applyMatrix4(n), La.radius += r, e.ray.intersectsSphere(La) === false) return;
          eu.copy(n).invert(), ys.copy(e.ray).applyMatrix4(eu);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = this.isLineSegments ? 2 : 1, h = i.index, u = i.attributes.position;
          if (h !== null) {
            const f = Math.max(0, a.start), p = Math.min(h.count, a.start + a.count);
            for (let m = f, g = p - 1; m < g; m += l) {
              const A = h.getX(m), x = h.getX(m + 1), b = Fa(this, e, ys, c, A, x, m);
              b && t.push(b);
            }
            if (this.isLineLoop) {
              const m = h.getX(p - 1), g = h.getX(f), A = Fa(this, e, ys, c, m, g, p - 1);
              A && t.push(A);
            }
          } else {
            const f = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
            for (let m = f, g = p - 1; m < g; m += l) {
              const A = Fa(this, e, ys, c, m, m + 1, m);
              A && t.push(A);
            }
            if (this.isLineLoop) {
              const m = Fa(this, e, ys, c, p - 1, f, p - 1);
              m && t.push(m);
            }
          }
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes, i = Object.keys(t);
          if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const o = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
              }
            }
          }
        }
      }
      function Fa(s, e, t, i, n, r, a) {
        const o = s.geometry.attributes.position;
        if (xo.fromBufferAttribute(o, n), Eo.fromBufferAttribute(o, r), t.distanceSqToSegment(xo, Eo, Sc, tu) > i) return;
        Sc.applyMatrix4(s.matrixWorld);
        const l = e.ray.origin.distanceTo(Sc);
        if (!(l < e.near || l > e.far)) return {
          distance: l,
          point: tu.clone().applyMatrix4(s.matrixWorld),
          index: a,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: s
        };
      }
      const iu = new T(), nu = new T();
      class sp extends is {
        constructor(e, t) {
          super(e, t), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position, i = [];
            for (let n = 0, r = t.count; n < r; n += 2) iu.fromBufferAttribute(t, n), nu.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + iu.distanceTo(nu);
            e.setAttribute("lineDistance", new _t(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class G_ extends is {
        constructor(e, t) {
          super(e, t), this.isLineLoop = true, this.type = "LineLoop";
        }
      }
      class ap extends Fi {
        constructor(e) {
          super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new ue(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
      }
      const ru = new ge(), zl = new os(), ka = new cn(), Ua = new T();
      class H_ extends ct {
        constructor(e = new Qt(), t = new ap()) {
          super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        raycast(e, t) {
          const i = this.geometry, n = this.matrixWorld, r = e.params.Points.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), ka.copy(i.boundingSphere), ka.applyMatrix4(n), ka.radius += r, e.ray.intersectsSphere(ka) === false) return;
          ru.copy(n).invert(), zl.copy(e.ray).applyMatrix4(ru);
          const o = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = o * o, l = i.index, d = i.attributes.position;
          if (l !== null) {
            const u = Math.max(0, a.start), f = Math.min(l.count, a.start + a.count);
            for (let p = u, m = f; p < m; p++) {
              const g = l.getX(p);
              Ua.fromBufferAttribute(d, g), su(Ua, g, c, n, e, t, this);
            }
          } else {
            const u = Math.max(0, a.start), f = Math.min(d.count, a.start + a.count);
            for (let p = u, m = f; p < m; p++) Ua.fromBufferAttribute(d, p), su(Ua, p, c, n, e, t, this);
          }
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes, i = Object.keys(t);
          if (i.length > 0) {
            const n = t[i[0]];
            if (n !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, a = n.length; r < a; r++) {
                const o = n[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = r;
              }
            }
          }
        }
      }
      function su(s, e, t, i, n, r, a) {
        const o = zl.distanceSqToPoint(s);
        if (o < t) {
          const c = new T();
          zl.closestPointToPoint(s, c), c.applyMatrix4(i);
          const l = n.ray.origin.distanceTo(c);
          if (l < n.near || l > n.far) return;
          r.push({
            distance: l,
            distanceToRay: Math.sqrt(o),
            point: c,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a
          });
        }
      }
      class No extends Nt {
        constructor(e, t, i, n, r, a, o, c, l, h, d, u) {
          super(null, a, o, c, l, h, n, r, d, u), this.isCompressedTexture = true, this.image = {
            width: t,
            height: i
          }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false;
        }
      }
      class V_ extends No {
        constructor(e, t, i, n, r, a) {
          super(e, t, i, r, a), this.isCompressedArrayTexture = true, this.image.depth = n, this.wrapR = fi, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class W_ extends No {
        constructor(e, t, i) {
          super(void 0, e[0].width, e[0].height, t, i, pr), this.isCompressedCubeTexture = true, this.isCubeTexture = true, this.image = e;
        }
      }
      class op extends Nt {
        constructor(e, t, i = Ar, n, r, a, o = pi, c = pi, l, h = Os) {
          if (h !== Os && h !== zs) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          super(null, n, r, a, o, c, h, i, l), this.isDepthTexture = true, this.image = {
            width: e,
            height: t
          }, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
        }
        copy(e) {
          return super.copy(e), this.source = new Eh(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
      }
      class Ni {
        constructor() {
          this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = false, this.cacheArcLengths = null;
        }
        getPoint() {
          console.warn("THREE.Curve: .getPoint() not implemented.");
        }
        getPointAt(e, t) {
          const i = this.getUtoTmapping(e);
          return this.getPoint(i, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
          this.needsUpdate = false;
          const t = [];
          let i, n = this.getPoint(0), r = 0;
          t.push(0);
          for (let a = 1; a <= e; a++) i = this.getPoint(a / e), r += i.distanceTo(n), t.push(r), n = i;
          return this.cacheArcLengths = t, t;
        }
        updateArcLengths() {
          this.needsUpdate = true, this.getLengths();
        }
        getUtoTmapping(e, t = null) {
          const i = this.getLengths();
          let n = 0;
          const r = i.length;
          let a;
          t ? a = t : a = e * i[r - 1];
          let o = 0, c = r - 1, l;
          for (; o <= c; ) if (n = Math.floor(o + (c - o) / 2), l = i[n] - a, l < 0) o = n + 1;
          else if (l > 0) c = n - 1;
          else {
            c = n;
            break;
          }
          if (n = c, i[n] === a) return n / (r - 1);
          const h = i[n], u = i[n + 1] - h, f = (a - h) / u;
          return (n + f) / (r - 1);
        }
        getTangent(e, t) {
          let n = e - 1e-4, r = e + 1e-4;
          n < 0 && (n = 0), r > 1 && (r = 1);
          const a = this.getPoint(n), o = this.getPoint(r), c = t || (a.isVector2 ? new oe() : new T());
          return c.copy(o).sub(a).normalize(), c;
        }
        getTangentAt(e, t) {
          const i = this.getUtoTmapping(e);
          return this.getTangent(i, t);
        }
        computeFrenetFrames(e, t = false) {
          const i = new T(), n = [], r = [], a = [], o = new T(), c = new ge();
          for (let f = 0; f <= e; f++) {
            const p = f / e;
            n[f] = this.getTangentAt(p, new T());
          }
          r[0] = new T(), a[0] = new T();
          let l = Number.MAX_VALUE;
          const h = Math.abs(n[0].x), d = Math.abs(n[0].y), u = Math.abs(n[0].z);
          h <= l && (l = h, i.set(1, 0, 0)), d <= l && (l = d, i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), o.crossVectors(n[0], i).normalize(), r[0].crossVectors(n[0], o), a[0].crossVectors(n[0], r[0]);
          for (let f = 1; f <= e; f++) {
            if (r[f] = r[f - 1].clone(), a[f] = a[f - 1].clone(), o.crossVectors(n[f - 1], n[f]), o.length() > Number.EPSILON) {
              o.normalize();
              const p = Math.acos(He(n[f - 1].dot(n[f]), -1, 1));
              r[f].applyMatrix4(c.makeRotationAxis(o, p));
            }
            a[f].crossVectors(n[f], r[f]);
          }
          if (t === true) {
            let f = Math.acos(He(r[0].dot(r[e]), -1, 1));
            f /= e, n[0].dot(o.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let p = 1; p <= e; p++) r[p].applyMatrix4(c.makeRotationAxis(n[p], f * p)), a[p].crossVectors(n[p], r[p]);
          }
          return {
            tangents: n,
            normals: r,
            binormals: a
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
        }
        fromJSON(e) {
          return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
      }
      class Rh extends Ni {
        constructor(e = 0, t = 0, i = 1, n = 1, r = 0, a = Math.PI * 2, o = false, c = 0) {
          super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = o, this.aRotation = c;
        }
        getPoint(e, t = new oe()) {
          const i = t, n = Math.PI * 2;
          let r = this.aEndAngle - this.aStartAngle;
          const a = Math.abs(r) < Number.EPSILON;
          for (; r < 0; ) r += n;
          for (; r > n; ) r -= n;
          r < Number.EPSILON && (a ? r = 0 : r = n), this.aClockwise === true && !a && (r === n ? r = -n : r = r - n);
          const o = this.aStartAngle + e * r;
          let c = this.aX + this.xRadius * Math.cos(o), l = this.aY + this.yRadius * Math.sin(o);
          if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), u = c - this.aX, f = l - this.aY;
            c = u * h - f * d + this.aX, l = u * d + f * h + this.aY;
          }
          return i.set(c, l);
        }
        copy(e) {
          return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
      }
      class j_ extends Rh {
        constructor(e, t, i, n, r, a) {
          super(e, t, i, i, n, r, a), this.isArcCurve = true, this.type = "ArcCurve";
        }
      }
      function Bh() {
        let s = 0, e = 0, t = 0, i = 0;
        function n(r, a, o, c) {
          s = r, e = o, t = -3 * r + 3 * a - 2 * o - c, i = 2 * r - 2 * a + o + c;
        }
        return {
          initCatmullRom: function(r, a, o, c, l) {
            n(a, o, l * (o - r), l * (c - a));
          },
          initNonuniformCatmullRom: function(r, a, o, c, l, h, d) {
            let u = (a - r) / l - (o - r) / (l + h) + (o - a) / h, f = (o - a) / h - (c - a) / (h + d) + (c - o) / d;
            u *= h, f *= h, n(a, o, u, f);
          },
          calc: function(r) {
            const a = r * r, o = a * r;
            return s + e * r + t * a + i * o;
          }
        };
      }
      const Na = new T(), Cc = new Bh(), Ic = new Bh(), Mc = new Bh();
      class cp extends Ni {
        constructor(e = [], t = false, i = "centripetal", n = 0.5) {
          super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
        }
        getPoint(e, t = new T()) {
          const i = t, n = this.points, r = n.length, a = (r - (this.closed ? 0 : 1)) * e;
          let o = Math.floor(a), c = a - o;
          this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / r) + 1) * r : c === 0 && o === r - 1 && (o = r - 2, c = 1);
          let l, h;
          this.closed || o > 0 ? l = n[(o - 1) % r] : (Na.subVectors(n[0], n[1]).add(n[0]), l = Na);
          const d = n[o % r], u = n[(o + 1) % r];
          if (this.closed || o + 2 < r ? h = n[(o + 2) % r] : (Na.subVectors(n[r - 1], n[r - 2]).add(n[r - 1]), h = Na), this.curveType === "centripetal" || this.curveType === "chordal") {
            const f = this.curveType === "chordal" ? 0.5 : 0.25;
            let p = Math.pow(l.distanceToSquared(d), f), m = Math.pow(d.distanceToSquared(u), f), g = Math.pow(u.distanceToSquared(h), f);
            m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), Cc.initNonuniformCatmullRom(l.x, d.x, u.x, h.x, p, m, g), Ic.initNonuniformCatmullRom(l.y, d.y, u.y, h.y, p, m, g), Mc.initNonuniformCatmullRom(l.z, d.z, u.z, h.z, p, m, g);
          } else this.curveType === "catmullrom" && (Cc.initCatmullRom(l.x, d.x, u.x, h.x, this.tension), Ic.initCatmullRom(l.y, d.y, u.y, h.y, this.tension), Mc.initCatmullRom(l.z, d.z, u.z, h.z, this.tension));
          return i.set(Cc.calc(c), Ic.calc(c), Mc.calc(c)), i;
        }
        copy(e) {
          super.copy(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const n = e.points[t];
            this.points.push(n.clone());
          }
          return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, i = this.points.length; t < i; t++) {
            const n = this.points[t];
            e.points.push(n.toArray());
          }
          return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const n = e.points[t];
            this.points.push(new T().fromArray(n));
          }
          return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
      }
      function au(s, e, t, i, n) {
        const r = (i - e) * 0.5, a = (n - t) * 0.5, o = s * s, c = s * o;
        return (2 * t - 2 * i + r + a) * c + (-3 * t + 3 * i - 2 * r - a) * o + r * s + t;
      }
      function q_(s, e) {
        const t = 1 - s;
        return t * t * e;
      }
      function X_(s, e) {
        return 2 * (1 - s) * s * e;
      }
      function Y_(s, e) {
        return s * s * e;
      }
      function Ls(s, e, t, i) {
        return q_(s, e) + X_(s, t) + Y_(s, i);
      }
      function K_(s, e) {
        const t = 1 - s;
        return t * t * t * e;
      }
      function J_(s, e) {
        const t = 1 - s;
        return 3 * t * t * s * e;
      }
      function Z_(s, e) {
        return 3 * (1 - s) * s * s * e;
      }
      function $_(s, e) {
        return s * s * s * e;
      }
      function Fs(s, e, t, i, n) {
        return K_(s, e) + J_(s, t) + Z_(s, i) + $_(s, n);
      }
      class lp extends Ni {
        constructor(e = new oe(), t = new oe(), i = new oe(), n = new oe()) {
          super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
        }
        getPoint(e, t = new oe()) {
          const i = t, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
          return i.set(Fs(e, n.x, r.x, a.x, o.x), Fs(e, n.y, r.y, a.y, o.y)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
      }
      class em extends Ni {
        constructor(e = new T(), t = new T(), i = new T(), n = new T()) {
          super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
        }
        getPoint(e, t = new T()) {
          const i = t, n = this.v0, r = this.v1, a = this.v2, o = this.v3;
          return i.set(Fs(e, n.x, r.x, a.x, o.x), Fs(e, n.y, r.y, a.y, o.y), Fs(e, n.z, r.z, a.z, o.z)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
      }
      class hp extends Ni {
        constructor(e = new oe(), t = new oe()) {
          super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new oe()) {
          const i = t;
          return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t = new oe()) {
          return t.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(e, t) {
          return this.getTangent(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class tm extends Ni {
        constructor(e = new T(), t = new T()) {
          super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new T()) {
          const i = t;
          return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t = new T()) {
          return t.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(e, t) {
          return this.getTangent(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class dp extends Ni {
        constructor(e = new oe(), t = new oe(), i = new oe()) {
          super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
        }
        getPoint(e, t = new oe()) {
          const i = t, n = this.v0, r = this.v1, a = this.v2;
          return i.set(Ls(e, n.x, r.x, a.x), Ls(e, n.y, r.y, a.y)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class up extends Ni {
        constructor(e = new T(), t = new T(), i = new T()) {
          super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
        }
        getPoint(e, t = new T()) {
          const i = t, n = this.v0, r = this.v1, a = this.v2;
          return i.set(Ls(e, n.x, r.x, a.x), Ls(e, n.y, r.y, a.y), Ls(e, n.z, r.z, a.z)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class fp extends Ni {
        constructor(e = []) {
          super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
        }
        getPoint(e, t = new oe()) {
          const i = t, n = this.points, r = (n.length - 1) * e, a = Math.floor(r), o = r - a, c = n[a === 0 ? a : a - 1], l = n[a], h = n[a > n.length - 2 ? n.length - 1 : a + 1], d = n[a > n.length - 3 ? n.length - 1 : a + 2];
          return i.set(au(o, c.x, l.x, h.x, d.x), au(o, c.y, l.y, h.y, d.y)), i;
        }
        copy(e) {
          super.copy(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const n = e.points[t];
            this.points.push(n.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, i = this.points.length; t < i; t++) {
            const n = this.points[t];
            e.points.push(n.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const n = e.points[t];
            this.points.push(new oe().fromArray(n));
          }
          return this;
        }
      }
      var Gl = Object.freeze({
        __proto__: null,
        ArcCurve: j_,
        CatmullRomCurve3: cp,
        CubicBezierCurve: lp,
        CubicBezierCurve3: em,
        EllipseCurve: Rh,
        LineCurve: hp,
        LineCurve3: tm,
        QuadraticBezierCurve: dp,
        QuadraticBezierCurve3: up,
        SplineCurve: fp
      });
      class im extends Ni {
        constructor() {
          super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
          if (!e.equals(t)) {
            const i = e.isVector2 === true ? "LineCurve" : "LineCurve3";
            this.curves.push(new Gl[i](t, e));
          }
          return this;
        }
        getPoint(e, t) {
          const i = e * this.getLength(), n = this.getCurveLengths();
          let r = 0;
          for (; r < n.length; ) {
            if (n[r] >= i) {
              const a = n[r] - i, o = this.curves[r], c = o.getLength(), l = c === 0 ? 0 : 1 - a / c;
              return o.getPointAt(l, t);
            }
            r++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
          return this.cacheLengths = e, e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let i;
          for (let n = 0, r = this.curves; n < r.length; n++) {
            const a = r[n], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(o);
            for (let l = 0; l < c.length; l++) {
              const h = c[l];
              i && i.equals(h) || (t.push(h), i = h);
            }
          }
          return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
        }
        copy(e) {
          super.copy(e), this.curves = [];
          for (let t = 0, i = e.curves.length; t < i; t++) {
            const n = e.curves[t];
            this.curves.push(n.clone());
          }
          return this.autoClose = e.autoClose, this;
        }
        toJSON() {
          const e = super.toJSON();
          e.autoClose = this.autoClose, e.curves = [];
          for (let t = 0, i = this.curves.length; t < i; t++) {
            const n = this.curves[t];
            e.curves.push(n.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
          for (let t = 0, i = e.curves.length; t < i; t++) {
            const n = e.curves[t];
            this.curves.push(new Gl[n.type]().fromJSON(n));
          }
          return this;
        }
      }
      class nm extends im {
        constructor(e) {
          super(), this.type = "Path", this.currentPoint = new oe(), e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const i = new hp(this.currentPoint.clone(), new oe(e, t));
          return this.curves.push(i), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, i, n) {
          const r = new dp(this.currentPoint.clone(), new oe(e, t), new oe(i, n));
          return this.curves.push(r), this.currentPoint.set(i, n), this;
        }
        bezierCurveTo(e, t, i, n, r, a) {
          const o = new lp(this.currentPoint.clone(), new oe(e, t), new oe(i, n), new oe(r, a));
          return this.curves.push(o), this.currentPoint.set(r, a), this;
        }
        splineThru(e) {
          const t = [
            this.currentPoint.clone()
          ].concat(e), i = new fp(t);
          return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
        }
        arc(e, t, i, n, r, a) {
          const o = this.currentPoint.x, c = this.currentPoint.y;
          return this.absarc(e + o, t + c, i, n, r, a), this;
        }
        absarc(e, t, i, n, r, a) {
          return this.absellipse(e, t, i, i, n, r, a), this;
        }
        ellipse(e, t, i, n, r, a, o, c) {
          const l = this.currentPoint.x, h = this.currentPoint.y;
          return this.absellipse(e + l, t + h, i, n, r, a, o, c), this;
        }
        absellipse(e, t, i, n, r, a, o, c) {
          const l = new Rh(e, t, i, n, r, a, o, c);
          if (this.curves.length > 0) {
            const d = l.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
          }
          this.curves.push(l);
          const h = l.getPoint(1);
          return this.currentPoint.copy(h), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.currentPoint = this.currentPoint.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
        }
      }
      class Dh extends Qt {
        constructor(e = [
          new oe(0, -0.5),
          new oe(0.5, 0),
          new oe(0, 0.5)
        ], t = 12, i = 0, n = Math.PI * 2) {
          super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
          }, t = Math.floor(t), n = He(n, 0, Math.PI * 2);
          const r = [], a = [], o = [], c = [], l = [], h = 1 / t, d = new T(), u = new oe(), f = new T(), p = new T(), m = new T();
          let g = 0, A = 0;
          for (let x = 0; x <= e.length - 1; x++) switch (x) {
            case 0:
              g = e[x + 1].x - e[x].x, A = e[x + 1].y - e[x].y, f.x = A * 1, f.y = -g, f.z = A * 0, m.copy(f), f.normalize(), c.push(f.x, f.y, f.z);
              break;
            case e.length - 1:
              c.push(m.x, m.y, m.z);
              break;
            default:
              g = e[x + 1].x - e[x].x, A = e[x + 1].y - e[x].y, f.x = A * 1, f.y = -g, f.z = A * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), c.push(f.x, f.y, f.z), m.copy(p);
          }
          for (let x = 0; x <= t; x++) {
            const b = i + x * h * n, y = Math.sin(b), I = Math.cos(b);
            for (let M = 0; M <= e.length - 1; M++) {
              d.x = e[M].x * y, d.y = e[M].y, d.z = e[M].x * I, a.push(d.x, d.y, d.z), u.x = x / t, u.y = M / (e.length - 1), o.push(u.x, u.y);
              const R = c[3 * M + 0] * y, D = c[3 * M + 1], S = c[3 * M + 0] * I;
              l.push(R, D, S);
            }
          }
          for (let x = 0; x < t; x++) for (let b = 0; b < e.length - 1; b++) {
            const y = b + x * e.length, I = y, M = y + e.length, R = y + e.length + 1, D = y + 1;
            r.push(I, M, D), r.push(R, D, M);
          }
          this.setIndex(r), this.setAttribute("position", new _t(a, 3)), this.setAttribute("uv", new _t(o, 2)), this.setAttribute("normal", new _t(l, 3));
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new Dh(e.points, e.segments, e.phiStart, e.phiLength);
        }
      }
      class Ph extends Dh {
        constructor(e = 1, t = 1, i = 4, n = 8) {
          const r = new nm();
          r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(i), n), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            length: t,
            capSegments: i,
            radialSegments: n
          };
        }
        static fromJSON(e) {
          return new Ph(e.radius, e.length, e.capSegments, e.radialSegments);
        }
      }
      function rm(s, e, t = 2) {
        const i = e && e.length, n = i ? e[0] * t : s.length;
        let r = pp(s, 0, n, t, true);
        const a = [];
        if (!r || r.next === r.prev) return a;
        let o, c, l;
        if (i && (r = lm(s, e, r, t)), s.length > 80 * t) {
          o = 1 / 0, c = 1 / 0;
          let h = -1 / 0, d = -1 / 0;
          for (let u = t; u < n; u += t) {
            const f = s[u], p = s[u + 1];
            f < o && (o = f), p < c && (c = p), f > h && (h = f), p > d && (d = p);
          }
          l = Math.max(h - o, d - c), l = l !== 0 ? 32767 / l : 0;
        }
        return Xs(r, a, t, o, c, l, 0), a;
      }
      function pp(s, e, t, i, n) {
        let r;
        if (n === bm(s, e, t, i) > 0) for (let a = e; a < t; a += i) r = ou(a / i | 0, s[a], s[a + 1], r);
        else for (let a = t - i; a >= e; a -= i) r = ou(a / i | 0, s[a], s[a + 1], r);
        return r && ns(r, r.next) && (Ks(r), r = r.next), r;
      }
      function gr(s, e) {
        if (!s) return s;
        e || (e = s);
        let t = s, i;
        do
          if (i = false, !t.steiner && (ns(t, t.next) || Tt(t.prev, t, t.next) === 0)) {
            if (Ks(t), t = e = t.prev, t === t.next) break;
            i = true;
          } else t = t.next;
        while (i || t !== e);
        return e;
      }
      function Xs(s, e, t, i, n, r, a) {
        if (!s) return;
        !a && r && pm(s, i, n, r);
        let o = s;
        for (; s.prev !== s.next; ) {
          const c = s.prev, l = s.next;
          if (r ? am(s, i, n, r) : sm(s)) {
            e.push(c.i, s.i, l.i), Ks(s), s = l.next, o = l.next;
            continue;
          }
          if (s = l, s === o) {
            a ? a === 1 ? (s = om(gr(s), e), Xs(s, e, t, i, n, r, 2)) : a === 2 && cm(s, e, t, i, n, r) : Xs(gr(s), e, t, i, n, r, 1);
            break;
          }
        }
      }
      function sm(s) {
        const e = s.prev, t = s, i = s.next;
        if (Tt(e, t, i) >= 0) return false;
        const n = e.x, r = t.x, a = i.x, o = e.y, c = t.y, l = i.y, h = Math.min(n, r, a), d = Math.min(o, c, l), u = Math.max(n, r, a), f = Math.max(o, c, l);
        let p = i.next;
        for (; p !== e; ) {
          if (p.x >= h && p.x <= u && p.y >= d && p.y <= f && Cs(n, o, r, c, a, l, p.x, p.y) && Tt(p.prev, p, p.next) >= 0) return false;
          p = p.next;
        }
        return true;
      }
      function am(s, e, t, i) {
        const n = s.prev, r = s, a = s.next;
        if (Tt(n, r, a) >= 0) return false;
        const o = n.x, c = r.x, l = a.x, h = n.y, d = r.y, u = a.y, f = Math.min(o, c, l), p = Math.min(h, d, u), m = Math.max(o, c, l), g = Math.max(h, d, u), A = Hl(f, p, e, t, i), x = Hl(m, g, e, t, i);
        let b = s.prevZ, y = s.nextZ;
        for (; b && b.z >= A && y && y.z <= x; ) {
          if (b.x >= f && b.x <= m && b.y >= p && b.y <= g && b !== n && b !== a && Cs(o, h, c, d, l, u, b.x, b.y) && Tt(b.prev, b, b.next) >= 0 || (b = b.prevZ, y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== a && Cs(o, h, c, d, l, u, y.x, y.y) && Tt(y.prev, y, y.next) >= 0)) return false;
          y = y.nextZ;
        }
        for (; b && b.z >= A; ) {
          if (b.x >= f && b.x <= m && b.y >= p && b.y <= g && b !== n && b !== a && Cs(o, h, c, d, l, u, b.x, b.y) && Tt(b.prev, b, b.next) >= 0) return false;
          b = b.prevZ;
        }
        for (; y && y.z <= x; ) {
          if (y.x >= f && y.x <= m && y.y >= p && y.y <= g && y !== n && y !== a && Cs(o, h, c, d, l, u, y.x, y.y) && Tt(y.prev, y, y.next) >= 0) return false;
          y = y.nextZ;
        }
        return true;
      }
      function om(s, e) {
        let t = s;
        do {
          const i = t.prev, n = t.next.next;
          !ns(i, n) && gp(i, t, t.next, n) && Ys(i, n) && Ys(n, i) && (e.push(i.i, t.i, n.i), Ks(t), Ks(t.next), t = s = n), t = t.next;
        } while (t !== s);
        return gr(t);
      }
      function cm(s, e, t, i, n, r) {
        let a = s;
        do {
          let o = a.next.next;
          for (; o !== a.prev; ) {
            if (a.i !== o.i && _m(a, o)) {
              let c = _p(a, o);
              a = gr(a, a.next), c = gr(c, c.next), Xs(a, e, t, i, n, r, 0), Xs(c, e, t, i, n, r, 0);
              return;
            }
            o = o.next;
          }
          a = a.next;
        } while (a !== s);
      }
      function lm(s, e, t, i) {
        const n = [];
        for (let r = 0, a = e.length; r < a; r++) {
          const o = e[r] * i, c = r < a - 1 ? e[r + 1] * i : s.length, l = pp(s, o, c, i, false);
          l === l.next && (l.steiner = true), n.push(gm(l));
        }
        n.sort(hm);
        for (let r = 0; r < n.length; r++) t = dm(n[r], t);
        return t;
      }
      function hm(s, e) {
        let t = s.x - e.x;
        if (t === 0 && (t = s.y - e.y, t === 0)) {
          const i = (s.next.y - s.y) / (s.next.x - s.x), n = (e.next.y - e.y) / (e.next.x - e.x);
          t = i - n;
        }
        return t;
      }
      function dm(s, e) {
        const t = um(s, e);
        if (!t) return e;
        const i = _p(t, s);
        return gr(i, i.next), gr(t, t.next);
      }
      function um(s, e) {
        let t = e;
        const i = s.x, n = s.y;
        let r = -1 / 0, a;
        if (ns(s, t)) return t;
        do {
          if (ns(s, t.next)) return t.next;
          if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
            const d = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (d <= i && d > r && (r = d, a = t.x < t.next.x ? t : t.next, d === i)) return a;
          }
          t = t.next;
        } while (t !== e);
        if (!a) return null;
        const o = a, c = a.x, l = a.y;
        let h = 1 / 0;
        t = a;
        do {
          if (i >= t.x && t.x >= c && i !== t.x && Ap(n < l ? i : r, n, c, l, n < l ? r : i, n, t.x, t.y)) {
            const d = Math.abs(n - t.y) / (i - t.x);
            Ys(t, s) && (d < h || d === h && (t.x > a.x || t.x === a.x && fm(a, t))) && (a = t, h = d);
          }
          t = t.next;
        } while (t !== o);
        return a;
      }
      function fm(s, e) {
        return Tt(s.prev, s, e.prev) < 0 && Tt(e.next, s, s.next) < 0;
      }
      function pm(s, e, t, i) {
        let n = s;
        do
          n.z === 0 && (n.z = Hl(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
        while (n !== s);
        n.prevZ.nextZ = null, n.prevZ = null, Am(n);
      }
      function Am(s) {
        let e, t = 1;
        do {
          let i = s, n;
          s = null;
          let r = null;
          for (e = 0; i; ) {
            e++;
            let a = i, o = 0;
            for (let l = 0; l < t && (o++, a = a.nextZ, !!a); l++) ;
            let c = t;
            for (; o > 0 || c > 0 && a; ) o !== 0 && (c === 0 || !a || i.z <= a.z) ? (n = i, i = i.nextZ, o--) : (n = a, a = a.nextZ, c--), r ? r.nextZ = n : s = n, n.prevZ = r, r = n;
            i = a;
          }
          r.nextZ = null, t *= 2;
        } while (e > 1);
        return s;
      }
      function Hl(s, e, t, i, n) {
        return s = (s - t) * n | 0, e = (e - i) * n | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
      }
      function gm(s) {
        let e = s, t = s;
        do
          (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
        while (e !== s);
        return t;
      }
      function Ap(s, e, t, i, n, r, a, o) {
        return (n - a) * (e - o) >= (s - a) * (r - o) && (s - a) * (i - o) >= (t - a) * (e - o) && (t - a) * (r - o) >= (n - a) * (i - o);
      }
      function Cs(s, e, t, i, n, r, a, o) {
        return !(s === a && e === o) && Ap(s, e, t, i, n, r, a, o);
      }
      function _m(s, e) {
        return s.next.i !== e.i && s.prev.i !== e.i && !mm(s, e) && (Ys(s, e) && Ys(e, s) && wm(s, e) && (Tt(s.prev, s, e.prev) || Tt(s, e.prev, e)) || ns(s, e) && Tt(s.prev, s, s.next) > 0 && Tt(e.prev, e, e.next) > 0);
      }
      function Tt(s, e, t) {
        return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
      }
      function ns(s, e) {
        return s.x === e.x && s.y === e.y;
      }
      function gp(s, e, t, i) {
        const n = Oa(Tt(s, e, t)), r = Oa(Tt(s, e, i)), a = Oa(Tt(t, i, s)), o = Oa(Tt(t, i, e));
        return !!(n !== r && a !== o || n === 0 && Qa(s, t, e) || r === 0 && Qa(s, i, e) || a === 0 && Qa(t, s, i) || o === 0 && Qa(t, e, i));
      }
      function Qa(s, e, t) {
        return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
      }
      function Oa(s) {
        return s > 0 ? 1 : s < 0 ? -1 : 0;
      }
      function mm(s, e) {
        let t = s;
        do {
          if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && gp(t, t.next, s, e)) return true;
          t = t.next;
        } while (t !== s);
        return false;
      }
      function Ys(s, e) {
        return Tt(s.prev, s, s.next) < 0 ? Tt(s, e, s.next) >= 0 && Tt(s, s.prev, e) >= 0 : Tt(s, e, s.prev) < 0 || Tt(s, s.next, e) < 0;
      }
      function wm(s, e) {
        let t = s, i = false;
        const n = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
        do
          t.y > r != t.next.y > r && t.next.y !== t.y && n < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
        while (t !== s);
        return i;
      }
      function _p(s, e) {
        const t = Vl(s.i, s.x, s.y), i = Vl(e.i, e.x, e.y), n = s.next, r = e.prev;
        return s.next = e, e.prev = s, t.next = n, n.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i;
      }
      function ou(s, e, t, i) {
        const n = Vl(s, e, t);
        return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
      }
      function Ks(s) {
        s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
      }
      function Vl(s, e, t) {
        return {
          i: s,
          x: e,
          y: t,
          prev: null,
          next: null,
          z: 0,
          prevZ: null,
          nextZ: null,
          steiner: false
        };
      }
      function bm(s, e, t, i) {
        let n = 0;
        for (let r = e, a = t - i; r < t; r += i) n += (s[a] - s[r]) * (s[r + 1] + s[a + 1]), a = r;
        return n;
      }
      class ym {
        static triangulate(e, t, i = 2) {
          return rm(e, t, i);
        }
      }
      class Lh {
        static area(e) {
          const t = e.length;
          let i = 0;
          for (let n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y;
          return i * 0.5;
        }
        static isClockWise(e) {
          return Lh.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const i = [], n = [], r = [];
          cu(e), lu(i, e);
          let a = e.length;
          t.forEach(cu);
          for (let c = 0; c < t.length; c++) n.push(a), a += t[c].length, lu(i, t[c]);
          const o = ym.triangulate(i, n);
          for (let c = 0; c < o.length; c += 3) r.push(o.slice(c, c + 3));
          return r;
        }
      }
      function cu(s) {
        const e = s.length;
        e > 2 && s[e - 1].equals(s[0]) && s.pop();
      }
      function lu(s, e) {
        for (let t = 0; t < e.length; t++) s.push(e[t].x), s.push(e[t].y);
      }
      class yr extends Qt {
        constructor(e = 1, t = 1, i = 1, n = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
          };
          const r = e / 2, a = t / 2, o = Math.floor(i), c = Math.floor(n), l = o + 1, h = c + 1, d = e / o, u = t / c, f = [], p = [], m = [], g = [];
          for (let A = 0; A < h; A++) {
            const x = A * u - a;
            for (let b = 0; b < l; b++) {
              const y = b * d - r;
              p.push(y, -x, 0), m.push(0, 0, 1), g.push(b / o), g.push(1 - A / c);
            }
          }
          for (let A = 0; A < c; A++) for (let x = 0; x < o; x++) {
            const b = x + l * A, y = x + l * (A + 1), I = x + 1 + l * (A + 1), M = x + 1 + l * A;
            f.push(b, y, M), f.push(y, I, M);
          }
          this.setIndex(f), this.setAttribute("position", new _t(p, 3)), this.setAttribute("normal", new _t(m, 3)), this.setAttribute("uv", new _t(g, 2));
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new yr(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      class Fh extends Qt {
        constructor(e = new up(new T(-1, -1, 0), new T(-1, 1, 0), new T(1, 1, 0)), t = 64, i = 1, n = 8, r = false) {
          super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
          };
          const a = e.computeFrenetFrames(t, r);
          this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
          const o = new T(), c = new T(), l = new oe();
          let h = new T();
          const d = [], u = [], f = [], p = [];
          m(), this.setIndex(p), this.setAttribute("position", new _t(d, 3)), this.setAttribute("normal", new _t(u, 3)), this.setAttribute("uv", new _t(f, 2));
          function m() {
            for (let b = 0; b < t; b++) g(b);
            g(r === false ? t : 0), x(), A();
          }
          function g(b) {
            h = e.getPointAt(b / t, h);
            const y = a.normals[b], I = a.binormals[b];
            for (let M = 0; M <= n; M++) {
              const R = M / n * Math.PI * 2, D = Math.sin(R), S = -Math.cos(R);
              c.x = S * y.x + D * I.x, c.y = S * y.y + D * I.y, c.z = S * y.z + D * I.z, c.normalize(), u.push(c.x, c.y, c.z), o.x = h.x + i * c.x, o.y = h.y + i * c.y, o.z = h.z + i * c.z, d.push(o.x, o.y, o.z);
            }
          }
          function A() {
            for (let b = 1; b <= t; b++) for (let y = 1; y <= n; y++) {
              const I = (n + 1) * (b - 1) + (y - 1), M = (n + 1) * b + (y - 1), R = (n + 1) * b + y, D = (n + 1) * (b - 1) + y;
              p.push(I, M, D), p.push(M, R, D);
            }
          }
          function x() {
            for (let b = 0; b <= t; b++) for (let y = 0; y <= n; y++) l.x = b / t, l.y = y / n, f.push(l.x, l.y);
          }
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.path = this.parameters.path.toJSON(), e;
        }
        static fromJSON(e) {
          return new Fh(new Gl[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
        }
      }
      class xm extends ki {
        constructor(e) {
          super(e), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
        }
      }
      class Ei extends Fi {
        constructor(e) {
          super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
            STANDARD: ""
          }, this.color = new ue(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fo, this.normalScale = new oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ht(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: ""
          }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class ln extends Ei {
        constructor(e) {
          super(), this.isMeshPhysicalMaterial = true, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new oe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
              return He(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(t) {
              this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
            }
          }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
            100,
            400
          ], this.iridescenceThicknessMap = null, this.sheenColor = new ue(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ue(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ue(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(e) {
          this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
            ...e.iridescenceThicknessRange
          ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
      }
      class za extends Fi {
        constructor(e) {
          super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new ue(16777215), this.specular = new ue(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fo, this.normalScale = new oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ht(), this.combine = Do, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class Em extends Fi {
        constructor(e) {
          super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new ue(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ue(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Fo, this.normalScale = new oe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ht(), this.combine = Do, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class vm extends Fi {
        constructor(e) {
          super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Ug, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
        }
      }
      class Sm extends Fi {
        constructor(e) {
          super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
        }
      }
      function Ga(s, e) {
        return !s || s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
      }
      function Cm(s) {
        return ArrayBuffer.isView(s) && !(s instanceof DataView);
      }
      function Im(s) {
        function e(n, r) {
          return s[n] - s[r];
        }
        const t = s.length, i = new Array(t);
        for (let n = 0; n !== t; ++n) i[n] = n;
        return i.sort(e), i;
      }
      function hu(s, e, t) {
        const i = s.length, n = new s.constructor(i);
        for (let r = 0, a = 0; a !== i; ++r) {
          const o = t[r] * e;
          for (let c = 0; c !== e; ++c) n[a++] = s[o + c];
        }
        return n;
      }
      function mp(s, e, t, i) {
        let n = 1, r = s[0];
        for (; r !== void 0 && r[i] === void 0; ) r = s[n++];
        if (r === void 0) return;
        let a = r[i];
        if (a !== void 0) if (Array.isArray(a)) do
          a = r[i], a !== void 0 && (e.push(r.time), t.push(...a)), r = s[n++];
        while (r !== void 0);
        else if (a.toArray !== void 0) do
          a = r[i], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = s[n++];
        while (r !== void 0);
        else do
          a = r[i], a !== void 0 && (e.push(r.time), t.push(a)), r = s[n++];
        while (r !== void 0);
      }
      class ca {
        constructor(e, t, i, n) {
          this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex, n = t[i], r = t[i - 1];
          e: {
            t: {
              let a;
              i: {
                n: if (!(e < n)) {
                  for (let o = i + 2; ; ) {
                    if (n === void 0) {
                      if (e < r) break n;
                      return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
                    }
                    if (i === o) break;
                    if (r = n, n = t[++i], e < n) break t;
                  }
                  a = t.length;
                  break i;
                }
                if (!(e >= r)) {
                  const o = t[1];
                  e < o && (i = 2, r = o);
                  for (let c = i - 2; ; ) {
                    if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i === c) break;
                    if (n = r, r = t[--i - 1], e >= r) break t;
                  }
                  a = i, i = 0;
                  break i;
                }
                break e;
              }
              for (; i < a; ) {
                const o = i + a >>> 1;
                e < t[o] ? a = o : i = o + 1;
              }
              if (n = t[i], r = t[i - 1], r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
            }
            this._cachedIndex = i, this.intervalChanged_(i, r, n);
          }
          return this.interpolate_(i, r, e, n);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n;
          for (let a = 0; a !== n; ++a) t[a] = i[r + a];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      class Mm extends ca {
        constructor(e, t, i, n) {
          super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Hr,
            endingEnd: Hr
          };
        }
        intervalChanged_(e, t, i) {
          const n = this.parameterPositions;
          let r = e - 2, a = e + 1, o = n[r], c = n[a];
          if (o === void 0) switch (this.getSettings_().endingStart) {
            case Vr:
              r = e, o = 2 * t - i;
              break;
            case mo:
              r = n.length - 2, o = t + n[r] - n[r + 1];
              break;
            default:
              r = e, o = i;
          }
          if (c === void 0) switch (this.getSettings_().endingEnd) {
            case Vr:
              a = e, c = 2 * i - t;
              break;
            case mo:
              a = 1, c = i + n[1] - n[0];
              break;
            default:
              a = e - 1, c = t;
          }
          const l = (i - t) * 0.5, h = this.valueSize;
          this._weightPrev = l / (t - o), this._weightNext = l / (c - i), this._offsetPrev = r * h, this._offsetNext = a * h;
        }
        interpolate_(e, t, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = e * o, l = c - o, h = this._offsetPrev, d = this._offsetNext, u = this._weightPrev, f = this._weightNext, p = (i - t) / (n - t), m = p * p, g = m * p, A = -u * g + 2 * u * m - u * p, x = (1 + u) * g + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1, b = (-1 - f) * g + (1.5 + f) * m + 0.5 * p, y = f * g - f * m;
          for (let I = 0; I !== o; ++I) r[I] = A * a[h + I] + x * a[l + I] + b * a[c + I] + y * a[d + I];
          return r;
        }
      }
      class wp extends ca {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        interpolate_(e, t, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = e * o, l = c - o, h = (i - t) / (n - t), d = 1 - h;
          for (let u = 0; u !== o; ++u) r[u] = a[l + u] * d + a[c + u] * h;
          return r;
        }
      }
      class Tm extends ca {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class nn {
        constructor(e, t, i, n) {
          if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
          this.name = e, this.times = Ga(t, this.TimeBufferType), this.values = Ga(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON) i = t.toJSON(e);
          else {
            i = {
              name: e.name,
              times: Ga(e.times, Array),
              values: Ga(e.values, Array)
            };
            const n = e.getInterpolation();
            n !== e.DefaultInterpolation && (i.interpolation = n);
          }
          return i.type = e.ValueTypeName, i;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new Tm(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new wp(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new Mm(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Vs:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case Ws:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case tc:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
            else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this;
          }
          return this.createInterpolant = t, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Vs;
            case this.InterpolantFactoryMethodLinear:
              return Ws;
            case this.InterpolantFactoryMethodSmooth:
              return tc;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
          }
          return this;
        }
        trim(e, t) {
          const i = this.times, n = i.length;
          let r = 0, a = n - 1;
          for (; r !== n && i[r] < e; ) ++r;
          for (; a !== -1 && i[a] > t; ) --a;
          if (++a, r !== 0 || a !== n) {
            r >= a && (a = Math.max(a, 1), r = a - 1);
            const o = this.getValueSize();
            this.times = i.slice(r, a), this.values = this.values.slice(r * o, a * o);
          }
          return this;
        }
        validate() {
          let e = true;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
          const i = this.times, n = this.values, r = i.length;
          r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
          let a = null;
          for (let o = 0; o !== r; o++) {
            const c = i[o];
            if (typeof c == "number" && isNaN(c)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, c), e = false;
              break;
            }
            if (a !== null && a > c) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, o, c, a), e = false;
              break;
            }
            a = c;
          }
          if (n !== void 0 && Cm(n)) for (let o = 0, c = n.length; o !== c; ++o) {
            const l = n[o];
            if (isNaN(l)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, l), e = false;
              break;
            }
          }
          return e;
        }
        optimize() {
          const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), n = this.getInterpolation() === tc, r = e.length - 1;
          let a = 1;
          for (let o = 1; o < r; ++o) {
            let c = false;
            const l = e[o], h = e[o + 1];
            if (l !== h && (o !== 1 || l !== e[0])) if (n) c = true;
            else {
              const d = o * i, u = d - i, f = d + i;
              for (let p = 0; p !== i; ++p) {
                const m = t[d + p];
                if (m !== t[u + p] || m !== t[f + p]) {
                  c = true;
                  break;
                }
              }
            }
            if (c) {
              if (o !== a) {
                e[a] = e[o];
                const d = o * i, u = a * i;
                for (let f = 0; f !== i; ++f) t[u + f] = t[d + f];
              }
              ++a;
            }
          }
          if (r > 0) {
            e[a] = e[r];
            for (let o = r * i, c = a * i, l = 0; l !== i; ++l) t[c + l] = t[o + l];
            ++a;
          }
          return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this;
        }
        clone() {
          const e = this.times.slice(), t = this.values.slice(), i = this.constructor, n = new i(this.name, e, t);
          return n.createInterpolant = this.createInterpolant, n;
        }
      }
      nn.prototype.ValueTypeName = "";
      nn.prototype.TimeBufferType = Float32Array;
      nn.prototype.ValueBufferType = Float32Array;
      nn.prototype.DefaultInterpolation = Ws;
      class ls extends nn {
        constructor(e, t, i) {
          super(e, t, i);
        }
      }
      ls.prototype.ValueTypeName = "bool";
      ls.prototype.ValueBufferType = Array;
      ls.prototype.DefaultInterpolation = Vs;
      ls.prototype.InterpolantFactoryMethodLinear = void 0;
      ls.prototype.InterpolantFactoryMethodSmooth = void 0;
      class bp extends nn {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
      }
      bp.prototype.ValueTypeName = "color";
      class _r extends nn {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
      }
      _r.prototype.ValueTypeName = "number";
      class Rm extends ca {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        interpolate_(e, t, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = (i - t) / (n - t);
          let l = e * o;
          for (let h = l + o; l !== h; l += 4) At.slerpFlat(r, 0, a, l - o, a, l, c);
          return r;
        }
      }
      class Hn extends nn {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        InterpolantFactoryMethodLinear(e) {
          return new Rm(this.times, this.values, this.getValueSize(), e);
        }
      }
      Hn.prototype.ValueTypeName = "quaternion";
      Hn.prototype.InterpolantFactoryMethodSmooth = void 0;
      class hs extends nn {
        constructor(e, t, i) {
          super(e, t, i);
        }
      }
      hs.prototype.ValueTypeName = "string";
      hs.prototype.ValueBufferType = Array;
      hs.prototype.DefaultInterpolation = Vs;
      hs.prototype.InterpolantFactoryMethodLinear = void 0;
      hs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class mr extends nn {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
      }
      mr.prototype.ValueTypeName = "vector";
      class vo {
        constructor(e = "", t = -1, i = [], n = yh) {
          this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = $i(), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [], i = e.tracks, n = 1 / (e.fps || 1);
          for (let a = 0, o = i.length; a !== o; ++a) t.push(Dm(i[a]).scale(n));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return r.uuid = e.uuid, r;
        }
        static toJSON(e) {
          const t = [], i = e.tracks, n = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
          };
          for (let r = 0, a = i.length; r !== a; ++r) t.push(nn.toJSON(i[r]));
          return n;
        }
        static CreateFromMorphTargetSequence(e, t, i, n) {
          const r = t.length, a = [];
          for (let o = 0; o < r; o++) {
            let c = [], l = [];
            c.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
            const h = Im(c);
            c = hu(c, 1, h), l = hu(l, 1, h), !n && c[0] === 0 && (c.push(r), l.push(l[0])), a.push(new _r(".morphTargetInfluences[" + t[o].name + "]", c, l).scale(1 / i));
          }
          return new this(e, -1, a);
        }
        static findByName(e, t) {
          let i = e;
          if (!Array.isArray(e)) {
            const n = e;
            i = n.geometry && n.geometry.animations || n.animations;
          }
          for (let n = 0; n < i.length; n++) if (i[n].name === t) return i[n];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, i) {
          const n = {}, r = /^([\w-]*?)([\d]+)$/;
          for (let o = 0, c = e.length; o < c; o++) {
            const l = e[o], h = l.name.match(r);
            if (h && h.length > 1) {
              const d = h[1];
              let u = n[d];
              u || (n[d] = u = []), u.push(l);
            }
          }
          const a = [];
          for (const o in n) a.push(this.CreateFromMorphTargetSequence(o, n[o], t, i));
          return a;
        }
        static parseAnimation(e, t) {
          if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const i = function(d, u, f, p, m) {
            if (f.length !== 0) {
              const g = [], A = [];
              mp(f, g, A, p), g.length !== 0 && m.push(new d(u, g, A));
            }
          }, n = [], r = e.name || "default", a = e.fps || 30, o = e.blendMode;
          let c = e.length || -1;
          const l = e.hierarchy || [];
          for (let d = 0; d < l.length; d++) {
            const u = l[d].keys;
            if (!(!u || u.length === 0)) if (u[0].morphTargets) {
              const f = {};
              let p;
              for (p = 0; p < u.length; p++) if (u[p].morphTargets) for (let m = 0; m < u[p].morphTargets.length; m++) f[u[p].morphTargets[m]] = -1;
              for (const m in f) {
                const g = [], A = [];
                for (let x = 0; x !== u[p].morphTargets.length; ++x) {
                  const b = u[p];
                  g.push(b.time), A.push(b.morphTarget === m ? 1 : 0);
                }
                n.push(new _r(".morphTargetInfluence[" + m + "]", g, A));
              }
              c = f.length * a;
            } else {
              const f = ".bones[" + t[d].name + "]";
              i(mr, f + ".position", u, "pos", n), i(Hn, f + ".quaternion", u, "rot", n), i(mr, f + ".scale", u, "scl", n);
            }
          }
          return n.length === 0 ? null : new this(r, c, n, o);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let i = 0, n = e.length; i !== n; ++i) {
            const r = this.tracks[i];
            t = Math.max(t, r.times[r.times.length - 1]);
          }
          return this.duration = t, this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = true;
          for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
          return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Bm(s) {
        switch (s.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return _r;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return mr;
          case "color":
            return bp;
          case "quaternion":
            return Hn;
          case "bool":
          case "boolean":
            return ls;
          case "string":
            return hs;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
      }
      function Dm(s) {
        if (s.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = Bm(s.type);
        if (s.times === void 0) {
          const t = [], i = [];
          mp(s.keys, t, i, "value"), s.times = t, s.values = i;
        }
        return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
      }
      const On = {
        enabled: false,
        files: {},
        add: function(s, e) {
          this.enabled !== false && (this.files[s] = e);
        },
        get: function(s) {
          if (this.enabled !== false) return this.files[s];
        },
        remove: function(s) {
          delete this.files[s];
        },
        clear: function() {
          this.files = {};
        }
      };
      class yp {
        constructor(e, t, i) {
          const n = this;
          let r = false, a = 0, o = 0, c;
          const l = [];
          this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(h) {
            o++, r === false && n.onStart !== void 0 && n.onStart(h, a, o), r = true;
          }, this.itemEnd = function(h) {
            a++, n.onProgress !== void 0 && n.onProgress(h, a, o), a === o && (r = false, n.onLoad !== void 0 && n.onLoad());
          }, this.itemError = function(h) {
            n.onError !== void 0 && n.onError(h);
          }, this.resolveURL = function(h) {
            return c ? c(h) : h;
          }, this.setURLModifier = function(h) {
            return c = h, this;
          }, this.addHandler = function(h, d) {
            return l.push(h, d), this;
          }, this.removeHandler = function(h) {
            const d = l.indexOf(h);
            return d !== -1 && l.splice(d, 2), this;
          }, this.getHandler = function(h) {
            for (let d = 0, u = l.length; d < u; d += 2) {
              const f = l[d], p = l[d + 1];
              if (f.global && (f.lastIndex = 0), f.test(h)) return p;
            }
            return null;
          };
        }
      }
      const Pm = new yp();
      class Ui {
        constructor(e) {
          this.manager = e !== void 0 ? e : Pm, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {
        }
        loadAsync(e, t) {
          const i = this;
          return new Promise(function(n, r) {
            i.load(e, n, t, r);
          });
        }
        parse() {
        }
        setCrossOrigin(e) {
          return this.crossOrigin = e, this;
        }
        setWithCredentials(e) {
          return this.withCredentials = e, this;
        }
        setPath(e) {
          return this.path = e, this;
        }
        setResourcePath(e) {
          return this.resourcePath = e, this;
        }
        setRequestHeader(e) {
          return this.requestHeader = e, this;
        }
      }
      Ui.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      const gn = {};
      class Lm extends Error {
        constructor(e, t) {
          super(e), this.response = t;
        }
      }
      class fr extends Ui {
        constructor(e) {
          super(e), this.mimeType = "", this.responseType = "";
        }
        load(e, t, i, n) {
          e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
          const r = On.get(e);
          if (r !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            t && t(r), this.manager.itemEnd(e);
          }, 0), r;
          if (gn[e] !== void 0) {
            gn[e].push({
              onLoad: t,
              onProgress: i,
              onError: n
            });
            return;
          }
          gn[e] = [], gn[e].push({
            onLoad: t,
            onProgress: i,
            onError: n
          });
          const a = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          }), o = this.mimeType, c = this.responseType;
          fetch(a).then((l) => {
            if (l.status === 200 || l.status === 0) {
              if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
              const h = gn[e], d = l.body.getReader(), u = l.headers.get("X-File-Size") || l.headers.get("Content-Length"), f = u ? parseInt(u) : 0, p = f !== 0;
              let m = 0;
              const g = new ReadableStream({
                start(A) {
                  x();
                  function x() {
                    d.read().then(({ done: b, value: y }) => {
                      if (b) A.close();
                      else {
                        m += y.byteLength;
                        const I = new ProgressEvent("progress", {
                          lengthComputable: p,
                          loaded: m,
                          total: f
                        });
                        for (let M = 0, R = h.length; M < R; M++) {
                          const D = h[M];
                          D.onProgress && D.onProgress(I);
                        }
                        A.enqueue(y), x();
                      }
                    }, (b) => {
                      A.error(b);
                    });
                  }
                }
              });
              return new Response(g);
            } else throw new Lm(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l);
          }).then((l) => {
            switch (c) {
              case "arraybuffer":
                return l.arrayBuffer();
              case "blob":
                return l.blob();
              case "document":
                return l.text().then((h) => new DOMParser().parseFromString(h, o));
              case "json":
                return l.json();
              default:
                if (o === "") return l.text();
                {
                  const d = /charset="?([^;"\s]*)"?/i.exec(o), u = d && d[1] ? d[1].toLowerCase() : void 0, f = new TextDecoder(u);
                  return l.arrayBuffer().then((p) => f.decode(p));
                }
            }
          }).then((l) => {
            On.add(e, l);
            const h = gn[e];
            delete gn[e];
            for (let d = 0, u = h.length; d < u; d++) {
              const f = h[d];
              f.onLoad && f.onLoad(l);
            }
          }).catch((l) => {
            const h = gn[e];
            if (h === void 0) throw this.manager.itemError(e), l;
            delete gn[e];
            for (let d = 0, u = h.length; d < u; d++) {
              const f = h[d];
              f.onError && f.onError(l);
            }
            this.manager.itemError(e);
          }).finally(() => {
            this.manager.itemEnd(e);
          }), this.manager.itemStart(e);
        }
        setResponseType(e) {
          return this.responseType = e, this;
        }
        setMimeType(e) {
          return this.mimeType = e, this;
        }
      }
      class xp extends Ui {
        constructor(e) {
          super(e);
        }
        load(e, t, i, n) {
          this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
          const r = this, a = On.get(e);
          if (a !== void 0) return r.manager.itemStart(e), setTimeout(function() {
            t && t(a), r.manager.itemEnd(e);
          }, 0), a;
          const o = js("img");
          function c() {
            h(), On.add(e, this), t && t(this), r.manager.itemEnd(e);
          }
          function l(d) {
            h(), n && n(d), r.manager.itemError(e), r.manager.itemEnd(e);
          }
          function h() {
            o.removeEventListener("load", c, false), o.removeEventListener("error", l, false);
          }
          return o.addEventListener("load", c, false), o.addEventListener("error", l, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(e), o.src = e, o;
        }
      }
      class Fm extends Ui {
        constructor(e) {
          super(e);
        }
        load(e, t, i, n) {
          const r = new Sh();
          r.colorSpace = nt;
          const a = new xp(this.manager);
          a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
          let o = 0;
          function c(l) {
            a.load(e[l], function(h) {
              r.images[l] = h, o++, o === 6 && (r.needsUpdate = true, t && t(r));
            }, void 0, n);
          }
          for (let l = 0; l < e.length; ++l) c(l);
          return r;
        }
      }
      class Si extends Ui {
        constructor(e) {
          super(e);
        }
        load(e, t, i, n) {
          const r = new Nt(), a = new xp(this.manager);
          return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
            r.image = o, r.needsUpdate = true, t !== void 0 && t(r);
          }, i, n), r;
        }
      }
      class Qo extends ct {
        constructor(e, t = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new ue(e), this.intensity = t;
        }
        dispose() {
        }
        copy(e, t) {
          return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
        }
      }
      const Tc = new ge(), du = new T(), uu = new T();
      class kh {
        constructor(e) {
          this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new oe(512, 512), this.map = null, this.mapPass = null, this.matrix = new ge(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Th(), this._frameExtents = new oe(1, 1), this._viewportCount = 1, this._viewports = [
            new je(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera, i = this.matrix;
          du.setFromMatrixPosition(e.matrixWorld), t.position.copy(du), uu.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(uu), t.updateMatrixWorld(), Tc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Tc), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(Tc);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
        }
      }
      class km extends kh {
        constructor() {
          super(new Vt(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
        }
        updateMatrices(e) {
          const t = this.camera, i = es * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
          (i !== t.fov || n !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), this.focus = e.focus, this;
        }
      }
      class Ep extends Qo {
        constructor(e, t, i = 0, n = Math.PI / 3, r = 0, a = 2) {
          super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(ct.DEFAULT_UP), this.updateMatrix(), this.target = new ct(), this.distance = i, this.angle = n, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new km();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      const fu = new ge(), xs = new T(), Rc = new T();
      class Um extends kh {
        constructor() {
          super(new Vt(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new oe(4, 2), this._viewportCount = 6, this._viewports = [
            new je(2, 1, 1, 1),
            new je(0, 1, 1, 1),
            new je(3, 1, 1, 1),
            new je(1, 1, 1, 1),
            new je(3, 0, 1, 1),
            new je(1, 0, 1, 1)
          ], this._cubeDirections = [
            new T(1, 0, 0),
            new T(-1, 0, 0),
            new T(0, 0, 1),
            new T(0, 0, -1),
            new T(0, 1, 0),
            new T(0, -1, 0)
          ], this._cubeUps = [
            new T(0, 1, 0),
            new T(0, 1, 0),
            new T(0, 1, 0),
            new T(0, 1, 0),
            new T(0, 0, 1),
            new T(0, 0, -1)
          ];
        }
        updateMatrices(e, t = 0) {
          const i = this.camera, n = this.matrix, r = e.distance || i.far;
          r !== i.far && (i.far = r, i.updateProjectionMatrix()), xs.setFromMatrixPosition(e.matrixWorld), i.position.copy(xs), Rc.copy(i.position), Rc.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(Rc), i.updateMatrixWorld(), n.makeTranslation(-xs.x, -xs.y, -xs.z), fu.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fu);
        }
      }
      class Wl extends Qo {
        constructor(e, t, i = 0, n = 2) {
          super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new Um();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
      }
      class Uh extends yo {
        constructor(e = -1, t = 1, i = 1, n = -1, r = 0.1, a = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = r, this.far = a, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, i, n, r, a) {
          this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
          let r = i - e, a = i + e, o = n + t, c = n - t;
          if (this.view !== null && this.view.enabled) {
            const l = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += l * this.view.offsetX, a = r + l * this.view.width, o -= h * this.view.offsetY, c = o - h * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(r, a, o, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
        }
      }
      class Nm extends kh {
        constructor() {
          super(new Uh(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
        }
      }
      let Oo = class extends Qo {
        constructor(e, t) {
          super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(ct.DEFAULT_UP), this.updateMatrix(), this.target = new ct(), this.shadow = new Nm();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      };
      class Nh extends Qo {
        constructor(e, t) {
          super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
        }
      }
      class Kr {
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
      }
      class Qm extends Qt {
        constructor() {
          super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
        }
        copy(e) {
          return super.copy(e), this.instanceCount = e.instanceCount, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = true, e;
        }
      }
      class Om extends Ui {
        constructor(e) {
          super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(e) {
          return this.options = e, this;
        }
        load(e, t, i, n) {
          e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
          const r = this, a = On.get(e);
          if (a !== void 0) {
            if (r.manager.itemStart(e), a.then) {
              a.then((l) => {
                t && t(l), r.manager.itemEnd(e);
              }).catch((l) => {
                n && n(l);
              });
              return;
            }
            return setTimeout(function() {
              t && t(a), r.manager.itemEnd(e);
            }, 0), a;
          }
          const o = {};
          o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
          const c = fetch(e, o).then(function(l) {
            return l.blob();
          }).then(function(l) {
            return createImageBitmap(l, Object.assign(r.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(l) {
            return On.add(e, l), t && t(l), r.manager.itemEnd(e), l;
          }).catch(function(l) {
            n && n(l), On.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
          });
          On.add(e, c), r.manager.itemStart(e);
        }
      }
      let Ha;
      class vp {
        static getContext() {
          return Ha === void 0 && (Ha = new (window.AudioContext || window.webkitAudioContext)()), Ha;
        }
        static setContext(e) {
          Ha = e;
        }
      }
      class zm extends Ui {
        constructor(e) {
          super(e);
        }
        load(e, t, i, n) {
          const r = this, a = new fr(this.manager);
          a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(c) {
            try {
              const l = c.slice(0);
              vp.getContext().decodeAudioData(l, function(d) {
                t(d);
              }).catch(o);
            } catch (l) {
              o(l);
            }
          }, i, n);
          function o(c) {
            n ? n(c) : console.error(c), r.manager.itemError(e);
          }
        }
      }
      class Gm extends Vt {
        constructor(e = []) {
          super(), this.isArrayCamera = true, this.cameras = e, this.index = 0;
        }
      }
      class Sp {
        constructor(e = true) {
          this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        start() {
          this.startTime = pu(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }
        stop() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = pu();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
          }
          return e;
        }
      }
      function pu() {
        return performance.now();
      }
      const $n = new T(), Au = new At(), Hm = new T(), er = new T();
      class Vm extends ct {
        constructor() {
          super(), this.type = "AudioListener", this.context = vp.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Sp();
        }
        getInput() {
          return this.gain;
        }
        removeFilter() {
          return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
        }
        getFilter() {
          return this.filter;
        }
        setFilter(e) {
          return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
        }
        getMasterVolume() {
          return this.gain.gain.value;
        }
        setMasterVolume(e) {
          return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e);
          const t = this.context.listener, i = this.up;
          if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose($n, Au, Hm), er.set(0, 0, -1).applyQuaternion(Au), t.positionX) {
            const n = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime($n.x, n), t.positionY.linearRampToValueAtTime($n.y, n), t.positionZ.linearRampToValueAtTime($n.z, n), t.forwardX.linearRampToValueAtTime(er.x, n), t.forwardY.linearRampToValueAtTime(er.y, n), t.forwardZ.linearRampToValueAtTime(er.z, n), t.upX.linearRampToValueAtTime(i.x, n), t.upY.linearRampToValueAtTime(i.y, n), t.upZ.linearRampToValueAtTime(i.z, n);
          } else t.setPosition($n.x, $n.y, $n.z), t.setOrientation(er.x, er.y, er.z, i.x, i.y, i.z);
        }
      }
      let Ri = class extends ct {
        constructor(e) {
          super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
        }
        getOutput() {
          return this.gain;
        }
        setNodeSource(e) {
          return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this;
        }
        setMediaElementSource(e) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
        }
        setMediaStreamSource(e) {
          return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
        }
        setBuffer(e) {
          return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
        }
        play(e = 0) {
          if (this.isPlaying === true) {
            console.warn("THREE.Audio: Audio is already playing.");
            return;
          }
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          this._startedAt = this.context.currentTime + e;
          const t = this.context.createBufferSource();
          return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
        }
        pause() {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
        }
        stop(e = 0) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = false, this;
        }
        connect() {
          if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
          } else this.source.connect(this.getOutput());
          return this._connected = true, this;
        }
        disconnect() {
          if (this._connected !== false) {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
              this.filters[this.filters.length - 1].disconnect(this.getOutput());
            } else this.source.disconnect(this.getOutput());
            return this._connected = false, this;
          }
        }
        getFilters() {
          return this.filters;
        }
        setFilters(e) {
          return e || (e = []), this._connected === true ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
        }
        setDetune(e) {
          return this.detune = e, this.isPlaying === true && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
        }
        getDetune() {
          return this.detune;
        }
        getFilter() {
          return this.getFilters()[0];
        }
        setFilter(e) {
          return this.setFilters(e ? [
            e
          ] : []);
        }
        setPlaybackRate(e) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this.playbackRate = e, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
        }
        getPlaybackRate() {
          return this.playbackRate;
        }
        onEnded() {
          this.isPlaying = false, this._progress = 0;
        }
        getLoop() {
          return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
        }
        setLoop(e) {
          if (this.hasPlaybackControl === false) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return;
          }
          return this.loop = e, this.isPlaying === true && (this.source.loop = this.loop), this;
        }
        setLoopStart(e) {
          return this.loopStart = e, this;
        }
        setLoopEnd(e) {
          return this.loopEnd = e, this;
        }
        getVolume() {
          return this.gain.gain.value;
        }
        setVolume(e) {
          return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
        }
        copy(e, t) {
          return super.copy(e, t), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
        }
        clone(e) {
          return new this.constructor(this.listener).copy(this, e);
        }
      };
      const tr = new T(), gu = new At(), Wm = new T(), ir = new T();
      class _u extends Ri {
        constructor(e) {
          super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
        }
        connect() {
          return super.connect(), this.panner.connect(this.gain), this;
        }
        disconnect() {
          return super.disconnect(), this.panner.disconnect(this.gain), this;
        }
        getOutput() {
          return this.panner;
        }
        getRefDistance() {
          return this.panner.refDistance;
        }
        setRefDistance(e) {
          return this.panner.refDistance = e, this;
        }
        getRolloffFactor() {
          return this.panner.rolloffFactor;
        }
        setRolloffFactor(e) {
          return this.panner.rolloffFactor = e, this;
        }
        getDistanceModel() {
          return this.panner.distanceModel;
        }
        setDistanceModel(e) {
          return this.panner.distanceModel = e, this;
        }
        getMaxDistance() {
          return this.panner.maxDistance;
        }
        setMaxDistance(e) {
          return this.panner.maxDistance = e, this;
        }
        setDirectionalCone(e, t, i) {
          return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
        }
        updateMatrixWorld(e) {
          if (super.updateMatrixWorld(e), this.hasPlaybackControl === true && this.isPlaying === false) return;
          this.matrixWorld.decompose(tr, gu, Wm), ir.set(0, 0, 1).applyQuaternion(gu);
          const t = this.panner;
          if (t.positionX) {
            const i = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(tr.x, i), t.positionY.linearRampToValueAtTime(tr.y, i), t.positionZ.linearRampToValueAtTime(tr.z, i), t.orientationX.linearRampToValueAtTime(ir.x, i), t.orientationY.linearRampToValueAtTime(ir.y, i), t.orientationZ.linearRampToValueAtTime(ir.z, i);
          } else t.setPosition(tr.x, tr.y, tr.z), t.setOrientation(ir.x, ir.y, ir.z);
        }
      }
      class jm {
        constructor(e, t, i) {
          this.binding = e, this.valueSize = i;
          let n, r, a;
          switch (t) {
            case "quaternion":
              n = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
              break;
            case "string":
            case "bool":
              n = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
              break;
            default:
              n = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
          }
          this._mixBufferRegion = n, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
        }
        accumulate(e, t) {
          const i = this.buffer, n = this.valueSize, r = e * n + n;
          let a = this.cumulativeWeight;
          if (a === 0) {
            for (let o = 0; o !== n; ++o) i[r + o] = i[o];
            a = t;
          } else {
            a += t;
            const o = t / a;
            this._mixBufferRegion(i, r, 0, o, n);
          }
          this.cumulativeWeight = a;
        }
        accumulateAdditive(e) {
          const t = this.buffer, i = this.valueSize, n = i * this._addIndex;
          this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, n, 0, e, i), this.cumulativeWeightAdditive += e;
        }
        apply(e) {
          const t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, a = this.cumulativeWeightAdditive, o = this.binding;
          if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
            const c = t * this._origIndex;
            this._mixBufferRegion(i, n, c, 1 - r, t);
          }
          a > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
          for (let c = t, l = t + t; c !== l; ++c) if (i[c] !== i[c + t]) {
            o.setValue(i, n);
            break;
          }
        }
        saveOriginalState() {
          const e = this.binding, t = this.buffer, i = this.valueSize, n = i * this._origIndex;
          e.getValue(t, n);
          for (let r = i, a = n; r !== a; ++r) t[r] = t[n + r % i];
          this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
        }
        restoreOriginalState() {
          const e = this.valueSize * 3;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize, t = e + this.valueSize;
          for (let i = e; i < t; i++) this.buffer[i] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
          for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i];
        }
        _select(e, t, i, n, r) {
          if (n >= 0.5) for (let a = 0; a !== r; ++a) e[t + a] = e[i + a];
        }
        _slerp(e, t, i, n) {
          At.slerpFlat(e, t, e, t, e, i, n);
        }
        _slerpAdditive(e, t, i, n, r) {
          const a = this._workIndex * r;
          At.multiplyQuaternionsFlat(e, a, e, t, e, i), At.slerpFlat(e, t, e, t, e, a, n);
        }
        _lerp(e, t, i, n, r) {
          const a = 1 - n;
          for (let o = 0; o !== r; ++o) {
            const c = t + o;
            e[c] = e[c] * a + e[i + o] * n;
          }
        }
        _lerpAdditive(e, t, i, n, r) {
          for (let a = 0; a !== r; ++a) {
            const o = t + a;
            e[o] = e[o] + e[i + a] * n;
          }
        }
      }
      const Qh = "\\[\\]\\.:\\/", qm = new RegExp("[" + Qh + "]", "g"), Oh = "[^" + Qh + "]", Xm = "[^" + Qh.replace("\\.", "") + "]", Ym = /((?:WC+[\/:])*)/.source.replace("WC", Oh), Km = /(WCOD+)?/.source.replace("WCOD", Xm), Jm = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Oh), Zm = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Oh), $m = new RegExp("^" + Ym + Km + Jm + Zm + "$"), ew = [
        "material",
        "materials",
        "bones",
        "map"
      ];
      class tw {
        constructor(e, t, i) {
          const n = i || tt.parseTrackName(t);
          this._targetGroup = e, this._bindings = e.subscribe_(t, n);
        }
        getValue(e, t) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
          n !== void 0 && n.getValue(e, t);
        }
        setValue(e, t) {
          const i = this._bindings;
          for (let n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
        }
      }
      class tt {
        constructor(e, t, i) {
          this.path = t, this.parsedPath = i || tt.parseTrackName(t), this.node = tt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e, t, i) {
          return e && e.isAnimationObjectGroup ? new tt.Composite(e, t, i) : new tt(e, t, i);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(qm, "");
        }
        static parseTrackName(e) {
          const t = $m.exec(e);
          if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
          }, n = i.nodeName && i.nodeName.lastIndexOf(".");
          if (n !== void 0 && n !== -1) {
            const r = i.nodeName.substring(n + 1);
            ew.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r);
          }
          if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
          return i;
        }
        static findNode(e, t) {
          if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
          if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i;
          }
          if (e.children) {
            const i = function(r) {
              for (let a = 0; a < r.length; a++) {
                const o = r[a];
                if (o.name === t || o.uuid === t) return o;
                const c = i(o.children);
                if (c) return c;
              }
              return null;
            }, n = i(e.children);
            if (n) return n;
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) e[t++] = i[n];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath, i = t.objectName, n = t.propertyName;
          let r = t.propertyIndex;
          if (e || (e = tt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return;
          }
          if (i) {
            let l = t.objectIndex;
            switch (i) {
              case "materials":
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++) if (e[h].name === l) {
                  l = h;
                  break;
                }
                break;
              case "map":
                if ("map" in e) {
                  e = e.map;
                  break;
                }
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                e = e.material.map;
                break;
              default:
                if (e[i] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                e = e[i];
            }
            if (l !== void 0) {
              if (e[l] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                return;
              }
              e = e[l];
            }
          }
          const a = e[n];
          if (a === void 0) {
            const l = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + n + " but it wasn't found.", e);
            return;
          }
          let o = this.Versioning.None;
          this.targetObject = e, e.isMaterial === true ? o = this.Versioning.NeedsUpdate : e.isObject3D === true && (o = this.Versioning.MatrixWorldNeedsUpdate);
          let c = this.BindingType.Direct;
          if (r !== void 0) {
            if (n === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!e.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
            }
            c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r;
          } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
          this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][o];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      tt.Composite = tw;
      tt.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      tt.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      tt.prototype.GetterByBindingType = [
        tt.prototype._getValue_direct,
        tt.prototype._getValue_array,
        tt.prototype._getValue_arrayElement,
        tt.prototype._getValue_toArray
      ];
      tt.prototype.SetterByBindingTypeAndVersioning = [
        [
          tt.prototype._setValue_direct,
          tt.prototype._setValue_direct_setNeedsUpdate,
          tt.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
          tt.prototype._setValue_array,
          tt.prototype._setValue_array_setNeedsUpdate,
          tt.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
          tt.prototype._setValue_arrayElement,
          tt.prototype._setValue_arrayElement_setNeedsUpdate,
          tt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
          tt.prototype._setValue_fromArray,
          tt.prototype._setValue_fromArray_setNeedsUpdate,
          tt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
      ];
      class iw {
        constructor(e, t, i = null, n = t.blendMode) {
          this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = n;
          const r = t.tracks, a = r.length, o = new Array(a), c = {
            endingStart: Hr,
            endingEnd: Hr
          };
          for (let l = 0; l !== a; ++l) {
            const h = r[l].createInterpolant(null);
            o[l] = h, h.settings = c;
          }
          this._interpolantSettings = c, this._interpolants = o, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Pg, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
        }
        isRunning() {
          return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return this._startTime = e, this;
        }
        setLoop(e, t) {
          return this.loop = e, this.repetitions = t, this;
        }
        setEffectiveWeight(e) {
          return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, i = false) {
          if (e.fadeOut(t), this.fadeIn(t), i === true) {
            const n = this._clip.duration, r = e._clip.duration, a = r / n, o = n / r;
            e.warp(1, a, t), this.warp(o, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, i = false) {
          return e.crossFadeFrom(this, t, i);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        setEffectiveTimeScale(e) {
          return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return this.timeScale = this._clip.duration / e, this.stopWarping();
        }
        syncWith(e) {
          return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, i) {
          const n = this._mixer, r = n.time, a = this.timeScale;
          let o = this._timeScaleInterpolant;
          o === null && (o = n._lendControlInterpolant(), this._timeScaleInterpolant = o);
          const c = o.parameterPositions, l = o.sampleValues;
          return c[0] = r, c[1] = r + i, l[0] = e / a, l[1] = t / a, this;
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, i, n) {
          if (!this.enabled) {
            this._updateWeight(e);
            return;
          }
          const r = this._startTime;
          if (r !== null) {
            const c = (e - r) * i;
            c < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * c);
          }
          t *= this._updateTimeScale(e);
          const a = this._updateTime(t), o = this._updateWeight(e);
          if (o > 0) {
            const c = this._interpolants, l = this._propertyBindings;
            switch (this.blendMode) {
              case Fg:
                for (let h = 0, d = c.length; h !== d; ++h) c[h].evaluate(a), l[h].accumulateAdditive(o);
                break;
              case yh:
              default:
                for (let h = 0, d = c.length; h !== d; ++h) c[h].evaluate(a), l[h].accumulate(n, o);
            }
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const i = this._weightInterpolant;
            if (i !== null) {
              const n = i.evaluate(e)[0];
              t *= n, e > i.parameterPositions[1] && (this.stopFading(), n === 0 && (this.enabled = false));
            }
          }
          return this._effectiveWeight = t, t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const i = this._timeScaleInterpolant;
            if (i !== null) {
              const n = i.evaluate(e)[0];
              t *= n, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = true : this.timeScale = t);
            }
          }
          return this._effectiveTimeScale = t, t;
        }
        _updateTime(e) {
          const t = this._clip.duration, i = this.loop;
          let n = this.time + e, r = this._loopCount;
          const a = i === Lg;
          if (e === 0) return r === -1 ? n : a && (r & 1) === 1 ? t - n : n;
          if (i === Lo) {
            r === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
            e: {
              if (n >= t) n = t;
              else if (n < 0) n = 0;
              else {
                this.time = n;
                break e;
              }
              this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = n, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e < 0 ? -1 : 1
              });
            }
          } else {
            if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(true, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, true, a)), n >= t || n < 0) {
              const o = Math.floor(n / t);
              n -= t * o, r += Math.abs(o);
              const c = this.repetitions - r;
              if (c <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, n = e > 0 ? t : 0, this.time = n, this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: e > 0 ? 1 : -1
              });
              else {
                if (c === 1) {
                  const l = e < 0;
                  this._setEndings(l, !l, a);
                } else this._setEndings(false, false, a);
                this._loopCount = r, this.time = n, this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: o
                });
              }
            } else this.time = n;
            if (a && (r & 1) === 1) return t - n;
          }
          return n;
        }
        _setEndings(e, t, i) {
          const n = this._interpolantSettings;
          i ? (n.endingStart = Vr, n.endingEnd = Vr) : (e ? n.endingStart = this.zeroSlopeAtStart ? Vr : Hr : n.endingStart = mo, t ? n.endingEnd = this.zeroSlopeAtEnd ? Vr : Hr : n.endingEnd = mo);
        }
        _scheduleFading(e, t, i) {
          const n = this._mixer, r = n.time;
          let a = this._weightInterpolant;
          a === null && (a = n._lendControlInterpolant(), this._weightInterpolant = a);
          const o = a.parameterPositions, c = a.sampleValues;
          return o[0] = r, c[0] = t, o[1] = r + e, c[1] = i, this;
        }
      }
      const nw = new Float32Array(1);
      class rw extends jn {
        constructor(e) {
          super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
        }
        _bindAction(e, t) {
          const i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, a = e._propertyBindings, o = e._interpolants, c = i.uuid, l = this._bindingsByRootAndName;
          let h = l[c];
          h === void 0 && (h = {}, l[c] = h);
          for (let d = 0; d !== r; ++d) {
            const u = n[d], f = u.name;
            let p = h[f];
            if (p !== void 0) ++p.referenceCount, a[d] = p;
            else {
              if (p = a[d], p !== void 0) {
                p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, c, f));
                continue;
              }
              const m = t && t._propertyBindings[d].binding.parsedPath;
              p = new jm(tt.create(i, f, m), u.ValueTypeName, u.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, c, f), a[d] = p;
            }
            o[d].resultBuffer = p.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
              const i = (e._localRoot || this._root).uuid, n = e._clip.uuid, r = this._actionsByClip[n];
              this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, n, i);
            }
            const t = e._propertyBindings;
            for (let i = 0, n = t.length; i !== n; ++i) {
              const r = t[i];
              r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let i = 0, n = t.length; i !== n; ++i) {
              const r = t[i];
              --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              }
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              }
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              }
            }
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return t !== null && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, i) {
          const n = this._actions, r = this._actionsByClip;
          let a = r[t];
          if (a === void 0) a = {
            knownActions: [
              e
            ],
            actionByRoot: {}
          }, e._byClipCacheIndex = 0, r[t] = a;
          else {
            const o = a.knownActions;
            e._byClipCacheIndex = o.length, o.push(e);
          }
          e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e;
        }
        _removeInactiveAction(e) {
          const t = this._actions, i = t[t.length - 1], n = e._cacheIndex;
          i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null;
          const r = e._clip.uuid, a = this._actionsByClip, o = a[r], c = o.knownActions, l = c[c.length - 1], h = e._byClipCacheIndex;
          l._byClipCacheIndex = h, c[h] = l, c.pop(), e._byClipCacheIndex = null;
          const d = o.actionByRoot, u = (e._localRoot || this._root).uuid;
          delete d[u], c.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let i = 0, n = t.length; i !== n; ++i) {
            const r = t[i];
            --r.referenceCount === 0 && this._removeInactiveBinding(r);
          }
        }
        _lendAction(e) {
          const t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n];
          e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
        }
        _takeBackAction(e) {
          const t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n];
          e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
        }
        _addInactiveBinding(e, t, i) {
          const n = this._bindingsByRootAndName, r = this._bindings;
          let a = n[t];
          a === void 0 && (a = {}, n[t] = a), a[i] = e, e._cacheIndex = r.length, r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, o = a[n], c = t[t.length - 1], l = e._cacheIndex;
          c._cacheIndex = l, t[l] = c, t.pop(), delete o[r], Object.keys(o).length === 0 && delete a[n];
        }
        _lendBinding(e) {
          const t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n];
          e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
        }
        _takeBackBinding(e) {
          const t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n];
          e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r;
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
          let i = e[t];
          return i === void 0 && (i = new wp(new Float32Array(2), new Float32Array(2), 1, nw), i.__cacheIndex = t, e[t] = i), i;
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n];
          e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r;
        }
        clipAction(e, t, i) {
          const n = t || this._root, r = n.uuid;
          let a = typeof e == "string" ? vo.findByName(n, e) : e;
          const o = a !== null ? a.uuid : e, c = this._actionsByClip[o];
          let l = null;
          if (i === void 0 && (a !== null ? i = a.blendMode : i = yh), c !== void 0) {
            const d = c.actionByRoot[r];
            if (d !== void 0 && d.blendMode === i) return d;
            l = c.knownActions[0], a === null && (a = l._clip);
          }
          if (a === null) return null;
          const h = new iw(this, a, t, i);
          return this._bindAction(h, l), this._addInactiveAction(h, o, r), h;
        }
        existingAction(e, t) {
          const i = t || this._root, n = i.uuid, r = typeof e == "string" ? vo.findByName(i, e) : e, a = r ? r.uuid : e, o = this._actionsByClip[a];
          return o !== void 0 && o.actionByRoot[n] || null;
        }
        stopAllAction() {
          const e = this._actions, t = this._nActiveActions;
          for (let i = t - 1; i >= 0; --i) e[i].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1;
          for (let l = 0; l !== i; ++l) t[l]._update(n, e, r, a);
          const o = this._bindings, c = this._nActiveBindings;
          for (let l = 0; l !== c; ++l) o[l].apply(a);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i];
          if (r !== void 0) {
            const a = r.knownActions;
            for (let o = 0, c = a.length; o !== c; ++o) {
              const l = a[o];
              this._deactivateAction(l);
              const h = l._cacheIndex, d = t[t.length - 1];
              l._cacheIndex = null, l._byClipCacheIndex = null, d._cacheIndex = h, t[h] = d, t.pop(), this._removeInactiveBindingsForAction(l);
            }
            delete n[i];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid, i = this._actionsByClip;
          for (const a in i) {
            const o = i[a].actionByRoot, c = o[t];
            c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
          }
          const n = this._bindingsByRootAndName, r = n[t];
          if (r !== void 0) for (const a in r) {
            const o = r[a];
            o.restoreOriginalState(), this._removeInactiveBinding(o);
          }
        }
        uncacheAction(e, t) {
          const i = this.existingAction(e, t);
          i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
        }
      }
      const mu = new ge();
      class sw {
        constructor(e, t, i = 0, n = 1 / 0) {
          this.ray = new os(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new vh(), this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
        }
        setFromXRController(e) {
          return mu.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(mu), this;
        }
        intersectObject(e, t = true, i = []) {
          return jl(e, this, i, t), i.sort(wu), i;
        }
        intersectObjects(e, t = true, i = []) {
          for (let n = 0, r = e.length; n < r; n++) jl(e[n], this, i, t);
          return i.sort(wu), i;
        }
      }
      function wu(s, e) {
        return s.distance - e.distance;
      }
      function jl(s, e, t, i) {
        let n = true;
        if (s.layers.test(e.layers) && s.raycast(e, t) === false && (n = false), n === true && i === true) {
          const r = s.children;
          for (let a = 0, o = r.length; a < o; a++) jl(r[a], e, t, true);
        }
      }
      class bu {
        constructor(e = 1, t = 0, i = 0) {
          this.radius = e, this.phi = t, this.theta = i;
        }
        set(e, t, i) {
          return this.radius = e, this.phi = t, this.theta = i, this;
        }
        copy(e) {
          return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
        }
        makeSafe() {
          return this.phi = He(this.phi, 1e-6, Math.PI - 1e-6), this;
        }
        setFromVector3(e) {
          return this.setFromCartesianCoords(e.x, e.y, e.z);
        }
        setFromCartesianCoords(e, t, i) {
          return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(He(t / this.radius, -1, 1))), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Un = new T(), Va = new ge(), Bc = new ge();
      class aw extends sp {
        constructor(e) {
          const t = Cp(e), i = new Qt(), n = [], r = [], a = new ue(0, 0, 1), o = new ue(0, 1, 0);
          for (let l = 0; l < t.length; l++) {
            const h = t[l];
            h.parent && h.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
          }
          i.setAttribute("position", new _t(n, 3)), i.setAttribute("color", new _t(r, 3));
          const c = new oa({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
          });
          super(i, c), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
        }
        updateMatrixWorld(e) {
          const t = this.bones, i = this.geometry, n = i.getAttribute("position");
          Bc.copy(this.root.matrixWorld).invert();
          for (let r = 0, a = 0; r < t.length; r++) {
            const o = t[r];
            o.parent && o.parent.isBone && (Va.multiplyMatrices(Bc, o.matrixWorld), Un.setFromMatrixPosition(Va), n.setXYZ(a, Un.x, Un.y, Un.z), Va.multiplyMatrices(Bc, o.parent.matrixWorld), Un.setFromMatrixPosition(Va), n.setXYZ(a + 1, Un.x, Un.y, Un.z), a += 2);
          }
          i.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e);
        }
        dispose() {
          this.geometry.dispose(), this.material.dispose();
        }
      }
      function Cp(s) {
        const e = [];
        s.isBone === true && e.push(s);
        for (let t = 0; t < s.children.length; t++) e.push(...Cp(s.children[t]));
        return e;
      }
      const yu = new T(), Wa = new T(), xu = new T();
      class ow extends ct {
        constructor(e, t, i) {
          super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
          let n = new Qt();
          n.setAttribute("position", new _t([
            -t,
            t,
            0,
            t,
            t,
            0,
            t,
            -t,
            0,
            -t,
            -t,
            0,
            -t,
            t,
            0
          ], 3));
          const r = new oa({
            fog: false,
            toneMapped: false
          });
          this.lightPlane = new is(n, r), this.add(this.lightPlane), n = new Qt(), n.setAttribute("position", new _t([
            0,
            0,
            0,
            0,
            0,
            1
          ], 3)), this.targetLine = new is(n, r), this.add(this.targetLine), this.update();
        }
        dispose() {
          this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
        }
        update() {
          this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), yu.setFromMatrixPosition(this.light.matrixWorld), Wa.setFromMatrixPosition(this.light.target.matrixWorld), xu.subVectors(Wa, yu), this.lightPlane.lookAt(Wa), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Wa), this.targetLine.scale.z = xu.length();
        }
      }
      class cw extends jn {
        constructor(e, t = null) {
          super(), this.object = e, this.domElement = t, this.enabled = true, this.state = -1, this.keys = {}, this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
          }, this.touches = {
            ONE: null,
            TWO: null
          };
        }
        connect(e) {
          if (e === void 0) {
            console.warn("THREE.Controls: connect() now requires an element.");
            return;
          }
          this.domElement !== null && this.disconnect(), this.domElement = e;
        }
        disconnect() {
        }
        dispose() {
        }
        update() {
        }
      }
      function Eu(s, e, t, i) {
        const n = lw(i);
        switch (t) {
          case Wf:
            return s * e;
          case qf:
            return s * e;
          case Xf:
            return s * e * 2;
          case yn:
            return s * e / n.components * n.byteLength;
          case mh:
            return s * e / n.components * n.byteLength;
          case hr:
            return s * e * 2 / n.components * n.byteLength;
          case wh:
            return s * e * 2 / n.components * n.byteLength;
          case jf:
            return s * e * 3 / n.components * n.byteLength;
          case Wt:
            return s * e * 4 / n.components * n.byteLength;
          case bh:
            return s * e * 4 / n.components * n.byteLength;
          case no:
          case Ts:
            return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case ro:
          case Rs:
            return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case yl:
          case xl:
            return Math.max(s, 16) * Math.max(e, 8) / 4;
          case uo:
          case fo:
            return Math.max(s, 8) * Math.max(e, 8) / 2;
          case po:
          case Ao:
            return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case go:
            return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case Gs:
            return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case El:
            return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
          case vl:
            return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
          case Sl:
            return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
          case Hs:
            return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
          case Cl:
            return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
          case Il:
            return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
          case Ml:
            return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
          case Tl:
            return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
          case Rl:
            return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
          case Bl:
            return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
          case Dl:
            return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
          case Pl:
            return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
          case Ll:
            return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
          case Bs:
          case Fl:
          case _o:
            return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
          case Yf:
          case kl:
            return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
          case Ul:
          case Nl:
            return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`);
      }
      function lw(s) {
        switch (s) {
          case Jt:
          case Gf:
            return {
              byteLength: 1,
              components: 1
            };
          case Ns:
          case Hf:
          case vi:
            return {
              byteLength: 2,
              components: 1
            };
          case gh:
          case _h:
            return {
              byteLength: 2,
              components: 4
            };
          case Ar:
          case Ah:
          case ii:
            return {
              byteLength: 4,
              components: 1
            };
          case Vf:
            return {
              byteLength: 4,
              components: 3
            };
        }
        throw new Error(`Unknown texture type ${s}.`);
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: ph
        }
      }));
      typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ph);
      function Ip() {
        let s = null, e = false, t = null, i = null;
        function n(r, a) {
          t(r, a), i = s.requestAnimationFrame(n);
        }
        return {
          start: function() {
            e !== true && t !== null && (i = s.requestAnimationFrame(n), e = true);
          },
          stop: function() {
            s.cancelAnimationFrame(i), e = false;
          },
          setAnimationLoop: function(r) {
            t = r;
          },
          setContext: function(r) {
            s = r;
          }
        };
      }
      function hw(s) {
        const e = /* @__PURE__ */ new WeakMap();
        function t(o, c) {
          const l = o.array, h = o.usage, d = l.byteLength, u = s.createBuffer();
          s.bindBuffer(c, u), s.bufferData(c, l, h), o.onUploadCallback();
          let f;
          if (l instanceof Float32Array) f = s.FLOAT;
          else if (l instanceof Uint16Array) o.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
          else if (l instanceof Int16Array) f = s.SHORT;
          else if (l instanceof Uint32Array) f = s.UNSIGNED_INT;
          else if (l instanceof Int32Array) f = s.INT;
          else if (l instanceof Int8Array) f = s.BYTE;
          else if (l instanceof Uint8Array) f = s.UNSIGNED_BYTE;
          else if (l instanceof Uint8ClampedArray) f = s.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + l);
          return {
            buffer: u,
            type: f,
            bytesPerElement: l.BYTES_PER_ELEMENT,
            version: o.version,
            size: d
          };
        }
        function i(o, c, l) {
          const h = c.array, d = c.updateRanges;
          if (s.bindBuffer(l, o), d.length === 0) s.bufferSubData(l, 0, h);
          else {
            d.sort((f, p) => f.start - p.start);
            let u = 0;
            for (let f = 1; f < d.length; f++) {
              const p = d[u], m = d[f];
              m.start <= p.start + p.count + 1 ? p.count = Math.max(p.count, m.start + m.count - p.start) : (++u, d[u] = m);
            }
            d.length = u + 1;
            for (let f = 0, p = d.length; f < p; f++) {
              const m = d[f];
              s.bufferSubData(l, m.start * h.BYTES_PER_ELEMENT, h, m.start, m.count);
            }
            c.clearUpdateRanges();
          }
          c.onUploadCallback();
        }
        function n(o) {
          return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
        }
        function r(o) {
          o.isInterleavedBufferAttribute && (o = o.data);
          const c = e.get(o);
          c && (s.deleteBuffer(c.buffer), e.delete(o));
        }
        function a(o, c) {
          if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
            const h = e.get(o);
            (!h || h.version < o.version) && e.set(o, {
              buffer: o.buffer,
              type: o.type,
              bytesPerElement: o.elementSize,
              version: o.version
            });
            return;
          }
          const l = e.get(o);
          if (l === void 0) e.set(o, t(o, c));
          else if (l.version < o.version) {
            if (l.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(l.buffer, o, c), l.version = o.version;
          }
        }
        return {
          get: n,
          remove: r,
          update: a
        };
      }
      var dw = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, uw = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, fw = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, pw = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Aw = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, gw = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, _w = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, mw = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, ww = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, bw = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, yw = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, xw = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Ew = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, vw = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Sw = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Cw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Iw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Mw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Tw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Rw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, Bw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Dw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, Pw = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, Lw = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Fw = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, kw = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Uw = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Nw = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Qw = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Ow = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, zw = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Gw = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Hw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Vw = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Ww = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, jw = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, qw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Xw = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Yw = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Kw = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Jw = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Zw = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, $w = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, eb = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, tb = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, ib = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, nb = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, rb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, sb = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, ab = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, ob = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, cb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, lb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, hb = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, db = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, ub = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, fb = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, pb = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Ab = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, gb = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, _b = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, mb = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, wb = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, bb = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, yb = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, xb = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Eb = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, vb = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Sb = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Cb = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Ib = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Mb = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Tb = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Rb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Bb = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Db = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Pb = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, Lb = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Fb = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, kb = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Ub = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Nb = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Qb = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Ob = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, zb = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Gb = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Hb = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Vb = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Wb = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, jb = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, qb = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Xb = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Yb = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Kb = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Jb = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Zb = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, $b = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, ey = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ty = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, iy = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, ny = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, ry = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, sy = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, ay = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, oy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, cy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, ly = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const hy = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, dy = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, uy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, fy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, py = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Ay = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, gy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, _y = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, my = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, wy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, by = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, yy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, xy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Ey = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, vy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Sy = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Cy = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Iy = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, My = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Ty = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ry = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, By = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Dy = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Py = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ly = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Fy = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ky = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Uy = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ny = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Qy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Oy = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, zy = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Gy = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Hy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Qe = {
        alphahash_fragment: dw,
        alphahash_pars_fragment: uw,
        alphamap_fragment: fw,
        alphamap_pars_fragment: pw,
        alphatest_fragment: Aw,
        alphatest_pars_fragment: gw,
        aomap_fragment: _w,
        aomap_pars_fragment: mw,
        batching_pars_vertex: ww,
        batching_vertex: bw,
        begin_vertex: yw,
        beginnormal_vertex: xw,
        bsdfs: Ew,
        iridescence_fragment: vw,
        bumpmap_pars_fragment: Sw,
        clipping_planes_fragment: Cw,
        clipping_planes_pars_fragment: Iw,
        clipping_planes_pars_vertex: Mw,
        clipping_planes_vertex: Tw,
        color_fragment: Rw,
        color_pars_fragment: Bw,
        color_pars_vertex: Dw,
        color_vertex: Pw,
        common: Lw,
        cube_uv_reflection_fragment: Fw,
        defaultnormal_vertex: kw,
        displacementmap_pars_vertex: Uw,
        displacementmap_vertex: Nw,
        emissivemap_fragment: Qw,
        emissivemap_pars_fragment: Ow,
        colorspace_fragment: zw,
        colorspace_pars_fragment: Gw,
        envmap_fragment: Hw,
        envmap_common_pars_fragment: Vw,
        envmap_pars_fragment: Ww,
        envmap_pars_vertex: jw,
        envmap_physical_pars_fragment: nb,
        envmap_vertex: qw,
        fog_vertex: Xw,
        fog_pars_vertex: Yw,
        fog_fragment: Kw,
        fog_pars_fragment: Jw,
        gradientmap_pars_fragment: Zw,
        lightmap_pars_fragment: $w,
        lights_lambert_fragment: eb,
        lights_lambert_pars_fragment: tb,
        lights_pars_begin: ib,
        lights_toon_fragment: rb,
        lights_toon_pars_fragment: sb,
        lights_phong_fragment: ab,
        lights_phong_pars_fragment: ob,
        lights_physical_fragment: cb,
        lights_physical_pars_fragment: lb,
        lights_fragment_begin: hb,
        lights_fragment_maps: db,
        lights_fragment_end: ub,
        logdepthbuf_fragment: fb,
        logdepthbuf_pars_fragment: pb,
        logdepthbuf_pars_vertex: Ab,
        logdepthbuf_vertex: gb,
        map_fragment: _b,
        map_pars_fragment: mb,
        map_particle_fragment: wb,
        map_particle_pars_fragment: bb,
        metalnessmap_fragment: yb,
        metalnessmap_pars_fragment: xb,
        morphinstance_vertex: Eb,
        morphcolor_vertex: vb,
        morphnormal_vertex: Sb,
        morphtarget_pars_vertex: Cb,
        morphtarget_vertex: Ib,
        normal_fragment_begin: Mb,
        normal_fragment_maps: Tb,
        normal_pars_fragment: Rb,
        normal_pars_vertex: Bb,
        normal_vertex: Db,
        normalmap_pars_fragment: Pb,
        clearcoat_normal_fragment_begin: Lb,
        clearcoat_normal_fragment_maps: Fb,
        clearcoat_pars_fragment: kb,
        iridescence_pars_fragment: Ub,
        opaque_fragment: Nb,
        packing: Qb,
        premultiplied_alpha_fragment: Ob,
        project_vertex: zb,
        dithering_fragment: Gb,
        dithering_pars_fragment: Hb,
        roughnessmap_fragment: Vb,
        roughnessmap_pars_fragment: Wb,
        shadowmap_pars_fragment: jb,
        shadowmap_pars_vertex: qb,
        shadowmap_vertex: Xb,
        shadowmask_pars_fragment: Yb,
        skinbase_vertex: Kb,
        skinning_pars_vertex: Jb,
        skinning_vertex: Zb,
        skinnormal_vertex: $b,
        specularmap_fragment: ey,
        specularmap_pars_fragment: ty,
        tonemapping_fragment: iy,
        tonemapping_pars_fragment: ny,
        transmission_fragment: ry,
        transmission_pars_fragment: sy,
        uv_pars_fragment: ay,
        uv_pars_vertex: oy,
        uv_vertex: cy,
        worldpos_vertex: ly,
        background_vert: hy,
        background_frag: dy,
        backgroundCube_vert: uy,
        backgroundCube_frag: fy,
        cube_vert: py,
        cube_frag: Ay,
        depth_vert: gy,
        depth_frag: _y,
        distanceRGBA_vert: my,
        distanceRGBA_frag: wy,
        equirect_vert: by,
        equirect_frag: yy,
        linedashed_vert: xy,
        linedashed_frag: Ey,
        meshbasic_vert: vy,
        meshbasic_frag: Sy,
        meshlambert_vert: Cy,
        meshlambert_frag: Iy,
        meshmatcap_vert: My,
        meshmatcap_frag: Ty,
        meshnormal_vert: Ry,
        meshnormal_frag: By,
        meshphong_vert: Dy,
        meshphong_frag: Py,
        meshphysical_vert: Ly,
        meshphysical_frag: Fy,
        meshtoon_vert: ky,
        meshtoon_frag: Uy,
        points_vert: Ny,
        points_frag: Qy,
        shadow_vert: Oy,
        shadow_frag: zy,
        sprite_vert: Gy,
        sprite_frag: Hy
      }, ce = {
        common: {
          diffuse: {
            value: new ue(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Oe()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Oe()
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          },
          specularMapTransform: {
            value: new Oe()
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          envMapRotation: {
            value: new Oe()
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          },
          aoMapTransform: {
            value: new Oe()
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          },
          lightMapTransform: {
            value: new Oe()
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpMapTransform: {
            value: new Oe()
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalMapTransform: {
            value: new Oe()
          },
          normalScale: {
            value: new oe(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementMapTransform: {
            value: new Oe()
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          },
          emissiveMapTransform: {
            value: new Oe()
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          },
          metalnessMapTransform: {
            value: new Oe()
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          },
          roughnessMapTransform: {
            value: new Oe()
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new ue(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotLightMap: {
            value: []
          },
          spotShadowMap: {
            value: []
          },
          spotLightMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new ue(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Oe()
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Oe()
          }
        },
        sprite: {
          diffuse: {
            value: new ue(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new oe(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new Oe()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new Oe()
          },
          alphaTest: {
            value: 0
          }
        }
      }, sn = {
        basic: {
          uniforms: di([
            ce.common,
            ce.specularmap,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.fog
          ]),
          vertexShader: Qe.meshbasic_vert,
          fragmentShader: Qe.meshbasic_frag
        },
        lambert: {
          uniforms: di([
            ce.common,
            ce.specularmap,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new ue(0)
              }
            }
          ]),
          vertexShader: Qe.meshlambert_vert,
          fragmentShader: Qe.meshlambert_frag
        },
        phong: {
          uniforms: di([
            ce.common,
            ce.specularmap,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new ue(0)
              },
              specular: {
                value: new ue(1118481)
              },
              shininess: {
                value: 30
              }
            }
          ]),
          vertexShader: Qe.meshphong_vert,
          fragmentShader: Qe.meshphong_frag
        },
        standard: {
          uniforms: di([
            ce.common,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.roughnessmap,
            ce.metalnessmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new ue(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }
          ]),
          vertexShader: Qe.meshphysical_vert,
          fragmentShader: Qe.meshphysical_frag
        },
        toon: {
          uniforms: di([
            ce.common,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.gradientmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new ue(0)
              }
            }
          ]),
          vertexShader: Qe.meshtoon_vert,
          fragmentShader: Qe.meshtoon_frag
        },
        matcap: {
          uniforms: di([
            ce.common,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.fog,
            {
              matcap: {
                value: null
              }
            }
          ]),
          vertexShader: Qe.meshmatcap_vert,
          fragmentShader: Qe.meshmatcap_frag
        },
        points: {
          uniforms: di([
            ce.points,
            ce.fog
          ]),
          vertexShader: Qe.points_vert,
          fragmentShader: Qe.points_frag
        },
        dashed: {
          uniforms: di([
            ce.common,
            ce.fog,
            {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }
          ]),
          vertexShader: Qe.linedashed_vert,
          fragmentShader: Qe.linedashed_frag
        },
        depth: {
          uniforms: di([
            ce.common,
            ce.displacementmap
          ]),
          vertexShader: Qe.depth_vert,
          fragmentShader: Qe.depth_frag
        },
        normal: {
          uniforms: di([
            ce.common,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            {
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Qe.meshnormal_vert,
          fragmentShader: Qe.meshnormal_frag
        },
        sprite: {
          uniforms: di([
            ce.sprite,
            ce.fog
          ]),
          vertexShader: Qe.sprite_vert,
          fragmentShader: Qe.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Oe()
            },
            t2D: {
              value: null
            },
            backgroundIntensity: {
              value: 1
            }
          },
          vertexShader: Qe.background_vert,
          fragmentShader: Qe.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            },
            backgroundBlurriness: {
              value: 0
            },
            backgroundIntensity: {
              value: 1
            },
            backgroundRotation: {
              value: new Oe()
            }
          },
          vertexShader: Qe.backgroundCube_vert,
          fragmentShader: Qe.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: {
              value: null
            },
            tFlip: {
              value: -1
            },
            opacity: {
              value: 1
            }
          },
          vertexShader: Qe.cube_vert,
          fragmentShader: Qe.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: Qe.equirect_vert,
          fragmentShader: Qe.equirect_frag
        },
        distanceRGBA: {
          uniforms: di([
            ce.common,
            ce.displacementmap,
            {
              referencePosition: {
                value: new T()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }
          ]),
          vertexShader: Qe.distanceRGBA_vert,
          fragmentShader: Qe.distanceRGBA_frag
        },
        shadow: {
          uniforms: di([
            ce.lights,
            ce.fog,
            {
              color: {
                value: new ue(0)
              },
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Qe.shadow_vert,
          fragmentShader: Qe.shadow_frag
        }
      };
      sn.physical = {
        uniforms: di([
          sn.standard.uniforms,
          {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatMapTransform: {
              value: new Oe()
            },
            clearcoatNormalMap: {
              value: null
            },
            clearcoatNormalMapTransform: {
              value: new Oe()
            },
            clearcoatNormalScale: {
              value: new oe(1, 1)
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatRoughnessMapTransform: {
              value: new Oe()
            },
            dispersion: {
              value: 0
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceMapTransform: {
              value: new Oe()
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            iridescenceThicknessMapTransform: {
              value: new Oe()
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: new ue(0)
            },
            sheenColorMap: {
              value: null
            },
            sheenColorMapTransform: {
              value: new Oe()
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            sheenRoughnessMapTransform: {
              value: new Oe()
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionMapTransform: {
              value: new Oe()
            },
            transmissionSamplerSize: {
              value: new oe()
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            thicknessMapTransform: {
              value: new Oe()
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: new ue(0)
            },
            specularColor: {
              value: new ue(1, 1, 1)
            },
            specularColorMap: {
              value: null
            },
            specularColorMapTransform: {
              value: new Oe()
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularIntensityMapTransform: {
              value: new Oe()
            },
            anisotropyVector: {
              value: new oe()
            },
            anisotropyMap: {
              value: null
            },
            anisotropyMapTransform: {
              value: new Oe()
            }
          }
        ]),
        vertexShader: Qe.meshphysical_vert,
        fragmentShader: Qe.meshphysical_frag
      };
      const ja = {
        r: 0,
        b: 0,
        g: 0
      }, nr = new Ht(), Vy = new ge();
      function Wy(s, e, t, i, n, r, a) {
        const o = new ue(0);
        let c = r === true ? 0 : 1, l, h, d = null, u = 0, f = null;
        function p(b) {
          let y = b.isScene === true ? b.background : null;
          return y && y.isTexture && (y = (b.backgroundBlurriness > 0 ? t : e).get(y)), y;
        }
        function m(b) {
          let y = false;
          const I = p(b);
          I === null ? A(o, c) : I && I.isColor && (A(I, 1), y = true);
          const M = s.xr.getEnvironmentBlendMode();
          M === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : M === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || y) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
        }
        function g(b, y) {
          const I = p(y);
          I && (I.isCubeTexture || I.mapping === Po) ? (h === void 0 && (h = new yt(new cs(1, 1, 1), new ki({
            name: "BackgroundCubeMaterial",
            uniforms: ts(sn.backgroundCube.uniforms),
            vertexShader: sn.backgroundCube.vertexShader,
            fragmentShader: sn.backgroundCube.fragmentShader,
            side: _i,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(M, R, D) {
            this.matrixWorld.copyPosition(D.matrixWorld);
          }, Object.defineProperty(h.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          }), n.update(h)), nr.copy(y.backgroundRotation), nr.x *= -1, nr.y *= -1, nr.z *= -1, I.isCubeTexture && I.isRenderTargetTexture === false && (nr.y *= -1, nr.z *= -1), h.material.uniforms.envMap.value = I, h.material.uniforms.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, h.material.uniforms.backgroundRotation.value.setFromMatrix4(Vy.makeRotationFromEuler(nr)), h.material.toneMapped = ze.getTransfer(I.colorSpace) !== pt, (d !== I || u !== I.version || f !== s.toneMapping) && (h.material.needsUpdate = true, d = I, u = I.version, f = s.toneMapping), h.layers.enableAll(), b.unshift(h, h.geometry, h.material, 0, 0, null)) : I && I.isTexture && (l === void 0 && (l = new yt(new yr(2, 2), new ki({
            name: "BackgroundMaterial",
            uniforms: ts(sn.background.uniforms),
            vertexShader: sn.background.vertexShader,
            fragmentShader: sn.background.fragmentShader,
            side: Sn,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          }), n.update(l)), l.material.uniforms.t2D.value = I, l.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, l.material.toneMapped = ze.getTransfer(I.colorSpace) !== pt, I.matrixAutoUpdate === true && I.updateMatrix(), l.material.uniforms.uvTransform.value.copy(I.matrix), (d !== I || u !== I.version || f !== s.toneMapping) && (l.material.needsUpdate = true, d = I, u = I.version, f = s.toneMapping), l.layers.enableAll(), b.unshift(l, l.geometry, l.material, 0, 0, null));
        }
        function A(b, y) {
          b.getRGB(ja, rp(s)), i.buffers.color.setClear(ja.r, ja.g, ja.b, y, a);
        }
        function x() {
          h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0), l !== void 0 && (l.geometry.dispose(), l.material.dispose(), l = void 0);
        }
        return {
          getClearColor: function() {
            return o;
          },
          setClearColor: function(b, y = 1) {
            o.set(b), c = y, A(o, c);
          },
          getClearAlpha: function() {
            return c;
          },
          setClearAlpha: function(b) {
            c = b, A(o, c);
          },
          render: m,
          addToRenderList: g,
          dispose: x
        };
      }
      function jy(s, e) {
        const t = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, n = u(null);
        let r = n, a = false;
        function o(E, P, j, H, Y) {
          let te = false;
          const q = d(H, j, P);
          r !== q && (r = q, l(r.object)), te = f(E, H, j, Y), te && p(E, H, j, Y), Y !== null && e.update(Y, s.ELEMENT_ARRAY_BUFFER), (te || a) && (a = false, y(E, P, j, H), Y !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(Y).buffer));
        }
        function c() {
          return s.createVertexArray();
        }
        function l(E) {
          return s.bindVertexArray(E);
        }
        function h(E) {
          return s.deleteVertexArray(E);
        }
        function d(E, P, j) {
          const H = j.wireframe === true;
          let Y = i[E.id];
          Y === void 0 && (Y = {}, i[E.id] = Y);
          let te = Y[P.id];
          te === void 0 && (te = {}, Y[P.id] = te);
          let q = te[H];
          return q === void 0 && (q = u(c()), te[H] = q), q;
        }
        function u(E) {
          const P = [], j = [], H = [];
          for (let Y = 0; Y < t; Y++) P[Y] = 0, j[Y] = 0, H[Y] = 0;
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: P,
            enabledAttributes: j,
            attributeDivisors: H,
            object: E,
            attributes: {},
            index: null
          };
        }
        function f(E, P, j, H) {
          const Y = r.attributes, te = P.attributes;
          let q = 0;
          const Z = j.getAttributes();
          for (const V in Z) if (Z[V].location >= 0) {
            const he = Y[V];
            let ve = te[V];
            if (ve === void 0 && (V === "instanceMatrix" && E.instanceMatrix && (ve = E.instanceMatrix), V === "instanceColor" && E.instanceColor && (ve = E.instanceColor)), he === void 0 || he.attribute !== ve || ve && he.data !== ve.data) return true;
            q++;
          }
          return r.attributesNum !== q || r.index !== H;
        }
        function p(E, P, j, H) {
          const Y = {}, te = P.attributes;
          let q = 0;
          const Z = j.getAttributes();
          for (const V in Z) if (Z[V].location >= 0) {
            let he = te[V];
            he === void 0 && (V === "instanceMatrix" && E.instanceMatrix && (he = E.instanceMatrix), V === "instanceColor" && E.instanceColor && (he = E.instanceColor));
            const ve = {};
            ve.attribute = he, he && he.data && (ve.data = he.data), Y[V] = ve, q++;
          }
          r.attributes = Y, r.attributesNum = q, r.index = H;
        }
        function m() {
          const E = r.newAttributes;
          for (let P = 0, j = E.length; P < j; P++) E[P] = 0;
        }
        function g(E) {
          A(E, 0);
        }
        function A(E, P) {
          const j = r.newAttributes, H = r.enabledAttributes, Y = r.attributeDivisors;
          j[E] = 1, H[E] === 0 && (s.enableVertexAttribArray(E), H[E] = 1), Y[E] !== P && (s.vertexAttribDivisor(E, P), Y[E] = P);
        }
        function x() {
          const E = r.newAttributes, P = r.enabledAttributes;
          for (let j = 0, H = P.length; j < H; j++) P[j] !== E[j] && (s.disableVertexAttribArray(j), P[j] = 0);
        }
        function b(E, P, j, H, Y, te, q) {
          q === true ? s.vertexAttribIPointer(E, P, j, Y, te) : s.vertexAttribPointer(E, P, j, H, Y, te);
        }
        function y(E, P, j, H) {
          m();
          const Y = H.attributes, te = j.getAttributes(), q = P.defaultAttributeValues;
          for (const Z in te) {
            const V = te[Z];
            if (V.location >= 0) {
              let re = Y[Z];
              if (re === void 0 && (Z === "instanceMatrix" && E.instanceMatrix && (re = E.instanceMatrix), Z === "instanceColor" && E.instanceColor && (re = E.instanceColor)), re !== void 0) {
                const he = re.normalized, ve = re.itemSize, Pe = e.get(re);
                if (Pe === void 0) continue;
                const Ve = Pe.buffer, K = Pe.type, ae = Pe.bytesPerElement, be = K === s.INT || K === s.UNSIGNED_INT || re.gpuType === Ah;
                if (re.isInterleavedBufferAttribute) {
                  const le = re.data, Te = le.stride, Ze = re.offset;
                  if (le.isInstancedInterleavedBuffer) {
                    for (let Le = 0; Le < V.locationSize; Le++) A(V.location + Le, le.meshPerAttribute);
                    E.isInstancedMesh !== true && H._maxInstanceCount === void 0 && (H._maxInstanceCount = le.meshPerAttribute * le.count);
                  } else for (let Le = 0; Le < V.locationSize; Le++) g(V.location + Le);
                  s.bindBuffer(s.ARRAY_BUFFER, Ve);
                  for (let Le = 0; Le < V.locationSize; Le++) b(V.location + Le, ve / V.locationSize, K, he, Te * ae, (Ze + ve / V.locationSize * Le) * ae, be);
                } else {
                  if (re.isInstancedBufferAttribute) {
                    for (let le = 0; le < V.locationSize; le++) A(V.location + le, re.meshPerAttribute);
                    E.isInstancedMesh !== true && H._maxInstanceCount === void 0 && (H._maxInstanceCount = re.meshPerAttribute * re.count);
                  } else for (let le = 0; le < V.locationSize; le++) g(V.location + le);
                  s.bindBuffer(s.ARRAY_BUFFER, Ve);
                  for (let le = 0; le < V.locationSize; le++) b(V.location + le, ve / V.locationSize, K, he, ve * ae, ve / V.locationSize * le * ae, be);
                }
              } else if (q !== void 0) {
                const he = q[Z];
                if (he !== void 0) switch (he.length) {
                  case 2:
                    s.vertexAttrib2fv(V.location, he);
                    break;
                  case 3:
                    s.vertexAttrib3fv(V.location, he);
                    break;
                  case 4:
                    s.vertexAttrib4fv(V.location, he);
                    break;
                  default:
                    s.vertexAttrib1fv(V.location, he);
                }
              }
            }
          }
          x();
        }
        function I() {
          D();
          for (const E in i) {
            const P = i[E];
            for (const j in P) {
              const H = P[j];
              for (const Y in H) h(H[Y].object), delete H[Y];
              delete P[j];
            }
            delete i[E];
          }
        }
        function M(E) {
          if (i[E.id] === void 0) return;
          const P = i[E.id];
          for (const j in P) {
            const H = P[j];
            for (const Y in H) h(H[Y].object), delete H[Y];
            delete P[j];
          }
          delete i[E.id];
        }
        function R(E) {
          for (const P in i) {
            const j = i[P];
            if (j[E.id] === void 0) continue;
            const H = j[E.id];
            for (const Y in H) h(H[Y].object), delete H[Y];
            delete j[E.id];
          }
        }
        function D() {
          S(), a = true, r !== n && (r = n, l(r.object));
        }
        function S() {
          n.geometry = null, n.program = null, n.wireframe = false;
        }
        return {
          setup: o,
          reset: D,
          resetDefaultState: S,
          dispose: I,
          releaseStatesOfGeometry: M,
          releaseStatesOfProgram: R,
          initAttributes: m,
          enableAttribute: g,
          disableUnusedAttributes: x
        };
      }
      function qy(s, e, t) {
        let i;
        function n(l) {
          i = l;
        }
        function r(l, h) {
          s.drawArrays(i, l, h), t.update(h, i, 1);
        }
        function a(l, h, d) {
          d !== 0 && (s.drawArraysInstanced(i, l, h, d), t.update(h, i, d));
        }
        function o(l, h, d) {
          if (d === 0) return;
          e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, l, 0, h, 0, d);
          let f = 0;
          for (let p = 0; p < d; p++) f += h[p];
          t.update(f, i, 1);
        }
        function c(l, h, d, u) {
          if (d === 0) return;
          const f = e.get("WEBGL_multi_draw");
          if (f === null) for (let p = 0; p < l.length; p++) a(l[p], h[p], u[p]);
          else {
            f.multiDrawArraysInstancedWEBGL(i, l, 0, h, 0, u, 0, d);
            let p = 0;
            for (let m = 0; m < d; m++) p += h[m] * u[m];
            t.update(p, i, 1);
          }
        }
        this.setMode = n, this.render = r, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = c;
      }
      function Xy(s, e, t, i) {
        let n;
        function r() {
          if (n !== void 0) return n;
          if (e.has("EXT_texture_filter_anisotropic") === true) {
            const R = e.get("EXT_texture_filter_anisotropic");
            n = s.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else n = 0;
          return n;
        }
        function a(R) {
          return !(R !== Wt && i.convert(R) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(R) {
          const D = R === vi && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
          return !(R !== Jt && i.convert(R) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && R !== ii && !D);
        }
        function c(R) {
          if (R === "highp") {
            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0) return "highp";
            R = "mediump";
          }
          return R === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let l = t.precision !== void 0 ? t.precision : "highp";
        const h = c(l);
        h !== l && (console.warn("THREE.WebGLRenderer:", l, "not supported, using", h, "instead."), l = h);
        const d = t.logarithmicDepthBuffer === true, u = t.reverseDepthBuffer === true && e.has("EXT_clip_control"), f = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), p = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_TEXTURE_SIZE), g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), A = s.getParameter(s.MAX_VERTEX_ATTRIBS), x = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), b = s.getParameter(s.MAX_VARYING_VECTORS), y = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), I = p > 0, M = s.getParameter(s.MAX_SAMPLES);
        return {
          isWebGL2: true,
          getMaxAnisotropy: r,
          getMaxPrecision: c,
          textureFormatReadable: a,
          textureTypeReadable: o,
          precision: l,
          logarithmicDepthBuffer: d,
          reverseDepthBuffer: u,
          maxTextures: f,
          maxVertexTextures: p,
          maxTextureSize: m,
          maxCubemapSize: g,
          maxAttributes: A,
          maxVertexUniforms: x,
          maxVaryings: b,
          maxFragmentUniforms: y,
          vertexTextures: I,
          maxSamples: M
        };
      }
      function Yy(s) {
        const e = this;
        let t = null, i = 0, n = false, r = false;
        const a = new Xi(), o = new Oe(), c = {
          value: null,
          needsUpdate: false
        };
        this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, u) {
          const f = d.length !== 0 || u || i !== 0 || n;
          return n = u, i = d.length, f;
        }, this.beginShadows = function() {
          r = true, h(null);
        }, this.endShadows = function() {
          r = false;
        }, this.setGlobalState = function(d, u) {
          t = h(d, u, 0);
        }, this.setState = function(d, u, f) {
          const p = d.clippingPlanes, m = d.clipIntersection, g = d.clipShadows, A = s.get(d);
          if (!n || p === null || p.length === 0 || r && !g) r ? h(null) : l();
          else {
            const x = r ? 0 : i, b = x * 4;
            let y = A.clippingState || null;
            c.value = y, y = h(p, u, b, f);
            for (let I = 0; I !== b; ++I) y[I] = t[I];
            A.clippingState = y, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += x;
          }
        };
        function l() {
          c.value !== t && (c.value = t, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
        }
        function h(d, u, f, p) {
          const m = d !== null ? d.length : 0;
          let g = null;
          if (m !== 0) {
            if (g = c.value, p !== true || g === null) {
              const A = f + m * 4, x = u.matrixWorldInverse;
              o.getNormalMatrix(x), (g === null || g.length < A) && (g = new Float32Array(A));
              for (let b = 0, y = f; b !== m; ++b, y += 4) a.copy(d[b]).applyMatrix4(x, o), a.normal.toArray(g, y), g[y + 3] = a.constant;
            }
            c.value = g, c.needsUpdate = true;
          }
          return e.numPlanes = m, e.numIntersection = 0, g;
        }
      }
      function Ky(s) {
        let e = /* @__PURE__ */ new WeakMap();
        function t(a, o) {
          return o === lo ? a.mapping = pr : o === bl && (a.mapping = $r), a;
        }
        function i(a) {
          if (a && a.isTexture) {
            const o = a.mapping;
            if (o === lo || o === bl) if (e.has(a)) {
              const c = e.get(a).texture;
              return t(c, a.mapping);
            } else {
              const c = a.image;
              if (c && c.height > 0) {
                const l = new P_(c.height);
                return l.fromEquirectangularTexture(s, a), e.set(a, l), a.addEventListener("dispose", n), t(l.texture, a.mapping);
              } else return null;
            }
          }
          return a;
        }
        function n(a) {
          const o = a.target;
          o.removeEventListener("dispose", n);
          const c = e.get(o);
          c !== void 0 && (e.delete(o), c.dispose());
        }
        function r() {
          e = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: i,
          dispose: r
        };
      }
      const Wr = 4, vu = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
      ], lr = 20, Dc = new Uh(), Su = new ue();
      let Pc = null, Lc = 0, Fc = 0, kc = false;
      const or = (1 + Math.sqrt(5)) / 2, Ur = 1 / or, Cu = [
        new T(-or, Ur, 0),
        new T(or, Ur, 0),
        new T(-Ur, 0, or),
        new T(Ur, 0, or),
        new T(0, or, -Ur),
        new T(0, or, Ur),
        new T(-1, 1, -1),
        new T(1, 1, -1),
        new T(-1, 1, 1),
        new T(1, 1, 1)
      ], Jy = new T();
      class Iu {
        constructor(e) {
          this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, i = 0.1, n = 100, r = {}) {
          const { size: a = 256, position: o = Jy } = r;
          Pc = this._renderer.getRenderTarget(), Lc = this._renderer.getActiveCubeFace(), Fc = this._renderer.getActiveMipmapLevel(), kc = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(a);
          const c = this._allocateTargets();
          return c.depthBuffer = true, this._sceneToCubeUV(e, i, n, c, o), t > 0 && this._blur(c, 0, 0, t), this._applyPMREM(c), this._cleanup(c), c;
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null && (this._cubemapMaterial = Ru(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null && (this._equirectMaterial = Tu(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(Pc, Lc, Fc), this._renderer.xr.enabled = kc, e.scissorTest = false, qa(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === pr || e.mapping === $r ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Pc = this._renderer.getRenderTarget(), Lc = this._renderer.getActiveCubeFace(), Fc = this._renderer.getActiveMipmapLevel(), kc = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
          const i = t || this._allocateTargets();
          return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
            magFilter: Rt,
            minFilter: Rt,
            generateMipmaps: false,
            type: vi,
            format: Wt,
            colorSpace: oi,
            depthBuffer: false
          }, n = Mu(e, t, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Mu(e, t, i);
            const { _lodMax: r } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Zy(r)), this._blurMaterial = $y(r, e, t);
          }
          return n;
        }
        _compileMaterial(e) {
          const t = new yt(this._lodPlanes[0], e);
          this._renderer.compile(t, Dc);
        }
        _sceneToCubeUV(e, t, i, n, r) {
          const c = new Vt(90, 1, t, i), l = [
            1,
            -1,
            1,
            1,
            1,
            1
          ], h = [
            1,
            1,
            1,
            -1,
            -1,
            -1
          ], d = this._renderer, u = d.autoClear, f = d.toneMapping;
          d.getClearColor(Su), d.toneMapping = Gn, d.autoClear = false;
          const p = new Zi({
            name: "PMREM.Background",
            side: _i,
            depthWrite: false,
            depthTest: false
          }), m = new yt(new cs(), p);
          let g = false;
          const A = e.background;
          A ? A.isColor && (p.color.copy(A), e.background = null, g = true) : (p.color.copy(Su), g = true);
          for (let x = 0; x < 6; x++) {
            const b = x % 3;
            b === 0 ? (c.up.set(0, l[x], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x + h[x], r.y, r.z)) : b === 1 ? (c.up.set(0, 0, l[x]), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y + h[x], r.z)) : (c.up.set(0, l[x], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y, r.z + h[x]));
            const y = this._cubeSize;
            qa(n, b * y, x > 2 ? y : 0, y, y), d.setRenderTarget(n), g && d.render(m, c), d.render(e, c);
          }
          m.geometry.dispose(), m.material.dispose(), d.toneMapping = f, d.autoClear = u, e.background = A;
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer, n = e.mapping === pr || e.mapping === $r;
          n ? (this._cubemapMaterial === null && (this._cubemapMaterial = Ru()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Tu());
          const r = n ? this._cubemapMaterial : this._equirectMaterial, a = new yt(this._lodPlanes[0], r), o = r.uniforms;
          o.envMap.value = e;
          const c = this._cubeSize;
          qa(t, 0, 0, 3 * c, 2 * c), i.setRenderTarget(t), i.render(a, Dc);
        }
        _applyPMREM(e) {
          const t = this._renderer, i = t.autoClear;
          t.autoClear = false;
          const n = this._lodPlanes.length;
          for (let r = 1; r < n; r++) {
            const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = Cu[(n - r - 1) % Cu.length];
            this._blur(e, r - 1, r, a, o);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, n, r) {
          const a = this._pingPongRenderTarget;
          this._halfBlur(e, a, t, i, n, "latitudinal", r), this._halfBlur(a, e, i, i, n, "longitudinal", r);
        }
        _halfBlur(e, t, i, n, r, a, o) {
          const c = this._renderer, l = this._blurMaterial;
          a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const h = 3, d = new yt(this._lodPlanes[n], l), u = l.uniforms, f = this._sizeLods[i] - 1, p = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * lr - 1), m = r / p, g = isFinite(r) ? 1 + Math.floor(h * m) : lr;
          g > lr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${lr}`);
          const A = [];
          let x = 0;
          for (let R = 0; R < lr; ++R) {
            const D = R / m, S = Math.exp(-D * D / 2);
            A.push(S), R === 0 ? x += S : R < g && (x += 2 * S);
          }
          for (let R = 0; R < A.length; R++) A[R] = A[R] / x;
          u.envMap.value = e.texture, u.samples.value = g, u.weights.value = A, u.latitudinal.value = a === "latitudinal", o && (u.poleAxis.value = o);
          const { _lodMax: b } = this;
          u.dTheta.value = p, u.mipInt.value = b - i;
          const y = this._sizeLods[n], I = 3 * y * (n > b - Wr ? n - b + Wr : 0), M = 4 * (this._cubeSize - y);
          qa(t, I, M, 3 * y, 2 * y), c.setRenderTarget(t), c.render(d, Dc);
        }
      }
      function Zy(s) {
        const e = [], t = [], i = [];
        let n = s;
        const r = s - Wr + 1 + vu.length;
        for (let a = 0; a < r; a++) {
          const o = Math.pow(2, n);
          t.push(o);
          let c = 1 / o;
          a > s - Wr ? c = vu[a - s + Wr - 1] : a === 0 && (c = 0), i.push(c);
          const l = 1 / (o - 2), h = -l, d = 1 + l, u = [
            h,
            h,
            d,
            h,
            d,
            d,
            h,
            h,
            d,
            d,
            h,
            d
          ], f = 6, p = 6, m = 3, g = 2, A = 1, x = new Float32Array(m * p * f), b = new Float32Array(g * p * f), y = new Float32Array(A * p * f);
          for (let M = 0; M < f; M++) {
            const R = M % 3 * 2 / 3 - 1, D = M > 2 ? 0 : -1, S = [
              R,
              D,
              0,
              R + 2 / 3,
              D,
              0,
              R + 2 / 3,
              D + 1,
              0,
              R,
              D,
              0,
              R + 2 / 3,
              D + 1,
              0,
              R,
              D + 1,
              0
            ];
            x.set(S, m * p * M), b.set(u, g * p * M);
            const E = [
              M,
              M,
              M,
              M,
              M,
              M
            ];
            y.set(E, A * p * M);
          }
          const I = new Qt();
          I.setAttribute("position", new ni(x, m)), I.setAttribute("uv", new ni(b, g)), I.setAttribute("faceIndex", new ni(y, A)), e.push(I), n > Wr && n--;
        }
        return {
          lodPlanes: e,
          sizeLods: t,
          sigmas: i
        };
      }
      function Mu(s, e, t) {
        const i = new Cn(s, e, t);
        return i.texture.mapping = Po, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
      }
      function qa(s, e, t, i, n) {
        s.viewport.set(e, t, i, n), s.scissor.set(e, t, i, n);
      }
      function $y(s, e, t) {
        const i = new Float32Array(lr), n = new T(0, 1, 0);
        return new ki({
          name: "SphericalGaussianBlur",
          defines: {
            n: lr,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${s}.0`
          },
          uniforms: {
            envMap: {
              value: null
            },
            samples: {
              value: 1
            },
            weights: {
              value: i
            },
            latitudinal: {
              value: false
            },
            dTheta: {
              value: 0
            },
            mipInt: {
              value: 0
            },
            poleAxis: {
              value: n
            }
          },
          vertexShader: zh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: zn,
          depthTest: false,
          depthWrite: false
        });
      }
      function Tu() {
        return new ki({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: zh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: zn,
          depthTest: false,
          depthWrite: false
        });
      }
      function Ru() {
        return new ki({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: zh(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: zn,
          depthTest: false,
          depthWrite: false
        });
      }
      function zh() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function e0(s) {
        let e = /* @__PURE__ */ new WeakMap(), t = null;
        function i(o) {
          if (o && o.isTexture) {
            const c = o.mapping, l = c === lo || c === bl, h = c === pr || c === $r;
            if (l || h) {
              let d = e.get(o);
              const u = d !== void 0 ? d.texture.pmremVersion : 0;
              if (o.isRenderTargetTexture && o.pmremVersion !== u) return t === null && (t = new Iu(s)), d = l ? t.fromEquirectangular(o, d) : t.fromCubemap(o, d), d.texture.pmremVersion = o.pmremVersion, e.set(o, d), d.texture;
              if (d !== void 0) return d.texture;
              {
                const f = o.image;
                return l && f && f.height > 0 || h && f && n(f) ? (t === null && (t = new Iu(s)), d = l ? t.fromEquirectangular(o) : t.fromCubemap(o), d.texture.pmremVersion = o.pmremVersion, e.set(o, d), o.addEventListener("dispose", r), d.texture) : null;
              }
            }
          }
          return o;
        }
        function n(o) {
          let c = 0;
          const l = 6;
          for (let h = 0; h < l; h++) o[h] !== void 0 && c++;
          return c === l;
        }
        function r(o) {
          const c = o.target;
          c.removeEventListener("dispose", r);
          const l = e.get(c);
          l !== void 0 && (e.delete(c), l.dispose());
        }
        function a() {
          e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
        }
        return {
          get: i,
          dispose: a
        };
      }
      function t0(s) {
        const e = {};
        function t(i) {
          if (e[i] !== void 0) return e[i];
          let n;
          switch (i) {
            case "WEBGL_depth_texture":
              n = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n = s.getExtension(i);
          }
          return e[i] = n, n;
        }
        return {
          has: function(i) {
            return t(i) !== null;
          },
          init: function() {
            t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
          },
          get: function(i) {
            const n = t(i);
            return n === null && so("THREE.WebGLRenderer: " + i + " extension not supported."), n;
          }
        };
      }
      function i0(s, e, t, i) {
        const n = {}, r = /* @__PURE__ */ new WeakMap();
        function a(d) {
          const u = d.target;
          u.index !== null && e.remove(u.index);
          for (const p in u.attributes) e.remove(u.attributes[p]);
          u.removeEventListener("dispose", a), delete n[u.id];
          const f = r.get(u);
          f && (e.remove(f), r.delete(u)), i.releaseStatesOfGeometry(u), u.isInstancedBufferGeometry === true && delete u._maxInstanceCount, t.memory.geometries--;
        }
        function o(d, u) {
          return n[u.id] === true || (u.addEventListener("dispose", a), n[u.id] = true, t.memory.geometries++), u;
        }
        function c(d) {
          const u = d.attributes;
          for (const f in u) e.update(u[f], s.ARRAY_BUFFER);
        }
        function l(d) {
          const u = [], f = d.index, p = d.attributes.position;
          let m = 0;
          if (f !== null) {
            const x = f.array;
            m = f.version;
            for (let b = 0, y = x.length; b < y; b += 3) {
              const I = x[b + 0], M = x[b + 1], R = x[b + 2];
              u.push(I, M, M, R, R, I);
            }
          } else if (p !== void 0) {
            const x = p.array;
            m = p.version;
            for (let b = 0, y = x.length / 3 - 1; b < y; b += 3) {
              const I = b + 0, M = b + 1, R = b + 2;
              u.push(I, M, M, R, R, I);
            }
          } else return;
          const g = new (Zf(u) ? np : ko)(u, 1);
          g.version = m;
          const A = r.get(d);
          A && e.remove(A), r.set(d, g);
        }
        function h(d) {
          const u = r.get(d);
          if (u) {
            const f = d.index;
            f !== null && u.version < f.version && l(d);
          } else l(d);
          return r.get(d);
        }
        return {
          get: o,
          update: c,
          getWireframeAttribute: h
        };
      }
      function n0(s, e, t) {
        let i;
        function n(u) {
          i = u;
        }
        let r, a;
        function o(u) {
          r = u.type, a = u.bytesPerElement;
        }
        function c(u, f) {
          s.drawElements(i, f, r, u * a), t.update(f, i, 1);
        }
        function l(u, f, p) {
          p !== 0 && (s.drawElementsInstanced(i, f, r, u * a, p), t.update(f, i, p));
        }
        function h(u, f, p) {
          if (p === 0) return;
          e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, r, u, 0, p);
          let g = 0;
          for (let A = 0; A < p; A++) g += f[A];
          t.update(g, i, 1);
        }
        function d(u, f, p, m) {
          if (p === 0) return;
          const g = e.get("WEBGL_multi_draw");
          if (g === null) for (let A = 0; A < u.length; A++) l(u[A] / a, f[A], m[A]);
          else {
            g.multiDrawElementsInstancedWEBGL(i, f, 0, r, u, 0, m, 0, p);
            let A = 0;
            for (let x = 0; x < p; x++) A += f[x] * m[x];
            t.update(A, i, 1);
          }
        }
        this.setMode = n, this.setIndex = o, this.render = c, this.renderInstances = l, this.renderMultiDraw = h, this.renderMultiDrawInstances = d;
      }
      function r0(s) {
        const e = {
          geometries: 0,
          textures: 0
        }, t = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function i(r, a, o) {
          switch (t.calls++, a) {
            case s.TRIANGLES:
              t.triangles += o * (r / 3);
              break;
            case s.LINES:
              t.lines += o * (r / 2);
              break;
            case s.LINE_STRIP:
              t.lines += o * (r - 1);
              break;
            case s.LINE_LOOP:
              t.lines += o * r;
              break;
            case s.POINTS:
              t.points += o * r;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", a);
              break;
          }
        }
        function n() {
          t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: true,
          reset: n,
          update: i
        };
      }
      function s0(s, e, t) {
        const i = /* @__PURE__ */ new WeakMap(), n = new je();
        function r(a, o, c) {
          const l = a.morphTargetInfluences, h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, d = h !== void 0 ? h.length : 0;
          let u = i.get(o);
          if (u === void 0 || u.count !== d) {
            let S = function() {
              R.dispose(), i.delete(o), o.removeEventListener("dispose", S);
            };
            u !== void 0 && u.texture.dispose();
            const f = o.morphAttributes.position !== void 0, p = o.morphAttributes.normal !== void 0, m = o.morphAttributes.color !== void 0, g = o.morphAttributes.position || [], A = o.morphAttributes.normal || [], x = o.morphAttributes.color || [];
            let b = 0;
            f === true && (b = 1), p === true && (b = 2), m === true && (b = 3);
            let y = o.attributes.position.count * b, I = 1;
            y > e.maxTextureSize && (I = Math.ceil(y / e.maxTextureSize), y = e.maxTextureSize);
            const M = new Float32Array(y * I * 4 * d), R = new $f(M, y, I, d);
            R.type = ii, R.needsUpdate = true;
            const D = b * 4;
            for (let E = 0; E < d; E++) {
              const P = g[E], j = A[E], H = x[E], Y = y * I * 4 * E;
              for (let te = 0; te < P.count; te++) {
                const q = te * D;
                f === true && (n.fromBufferAttribute(P, te), M[Y + q + 0] = n.x, M[Y + q + 1] = n.y, M[Y + q + 2] = n.z, M[Y + q + 3] = 0), p === true && (n.fromBufferAttribute(j, te), M[Y + q + 4] = n.x, M[Y + q + 5] = n.y, M[Y + q + 6] = n.z, M[Y + q + 7] = 0), m === true && (n.fromBufferAttribute(H, te), M[Y + q + 8] = n.x, M[Y + q + 9] = n.y, M[Y + q + 10] = n.z, M[Y + q + 11] = H.itemSize === 4 ? n.w : 1);
              }
            }
            u = {
              count: d,
              texture: R,
              size: new oe(y, I)
            }, i.set(o, u), o.addEventListener("dispose", S);
          }
          if (a.isInstancedMesh === true && a.morphTexture !== null) c.getUniforms().setValue(s, "morphTexture", a.morphTexture, t);
          else {
            let f = 0;
            for (let m = 0; m < l.length; m++) f += l[m];
            const p = o.morphTargetsRelative ? 1 : 1 - f;
            c.getUniforms().setValue(s, "morphTargetBaseInfluence", p), c.getUniforms().setValue(s, "morphTargetInfluences", l);
          }
          c.getUniforms().setValue(s, "morphTargetsTexture", u.texture, t), c.getUniforms().setValue(s, "morphTargetsTextureSize", u.size);
        }
        return {
          update: r
        };
      }
      function a0(s, e, t, i) {
        let n = /* @__PURE__ */ new WeakMap();
        function r(c) {
          const l = i.render.frame, h = c.geometry, d = e.get(c, h);
          if (n.get(d) !== l && (e.update(d), n.set(d, l)), c.isInstancedMesh && (c.hasEventListener("dispose", o) === false && c.addEventListener("dispose", o), n.get(c) !== l && (t.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, s.ARRAY_BUFFER), n.set(c, l))), c.isSkinnedMesh) {
            const u = c.skeleton;
            n.get(u) !== l && (u.update(), n.set(u, l));
          }
          return d;
        }
        function a() {
          n = /* @__PURE__ */ new WeakMap();
        }
        function o(c) {
          const l = c.target;
          l.removeEventListener("dispose", o), t.remove(l.instanceMatrix), l.instanceColor !== null && t.remove(l.instanceColor);
        }
        return {
          update: r,
          dispose: a
        };
      }
      const Mp = new Nt(), Bu = new op(1, 1), Tp = new $f(), Rp = new ep(), Bp = new Sh(), Du = [], Pu = [], Lu = new Float32Array(16), Fu = new Float32Array(9), ku = new Float32Array(4);
      function ds(s, e, t) {
        const i = s[0];
        if (i <= 0 || i > 0) return s;
        const n = e * t;
        let r = Du[n];
        if (r === void 0 && (r = new Float32Array(n), Du[n] = r), e !== 0) {
          i.toArray(r, 0);
          for (let a = 1, o = 0; a !== e; ++a) o += t, s[a].toArray(r, o);
        }
        return r;
      }
      function jt(s, e) {
        if (s.length !== e.length) return false;
        for (let t = 0, i = s.length; t < i; t++) if (s[t] !== e[t]) return false;
        return true;
      }
      function qt(s, e) {
        for (let t = 0, i = e.length; t < i; t++) s[t] = e[t];
      }
      function zo(s, e) {
        let t = Pu[e];
        t === void 0 && (t = new Int32Array(e), Pu[e] = t);
        for (let i = 0; i !== e; ++i) t[i] = s.allocateTextureUnit();
        return t;
      }
      function o0(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
      }
      function c0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
          if (jt(t, e)) return;
          s.uniform2fv(this.addr, e), qt(t, e);
        }
      }
      function l0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
          if (jt(t, e)) return;
          s.uniform3fv(this.addr, e), qt(t, e);
        }
      }
      function h0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
          if (jt(t, e)) return;
          s.uniform4fv(this.addr, e), qt(t, e);
        }
      }
      function d0(s, e) {
        const t = this.cache, i = e.elements;
        if (i === void 0) {
          if (jt(t, e)) return;
          s.uniformMatrix2fv(this.addr, false, e), qt(t, e);
        } else {
          if (jt(t, i)) return;
          ku.set(i), s.uniformMatrix2fv(this.addr, false, ku), qt(t, i);
        }
      }
      function u0(s, e) {
        const t = this.cache, i = e.elements;
        if (i === void 0) {
          if (jt(t, e)) return;
          s.uniformMatrix3fv(this.addr, false, e), qt(t, e);
        } else {
          if (jt(t, i)) return;
          Fu.set(i), s.uniformMatrix3fv(this.addr, false, Fu), qt(t, i);
        }
      }
      function f0(s, e) {
        const t = this.cache, i = e.elements;
        if (i === void 0) {
          if (jt(t, e)) return;
          s.uniformMatrix4fv(this.addr, false, e), qt(t, e);
        } else {
          if (jt(t, i)) return;
          Lu.set(i), s.uniformMatrix4fv(this.addr, false, Lu), qt(t, i);
        }
      }
      function p0(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
      }
      function A0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
          if (jt(t, e)) return;
          s.uniform2iv(this.addr, e), qt(t, e);
        }
      }
      function g0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
          if (jt(t, e)) return;
          s.uniform3iv(this.addr, e), qt(t, e);
        }
      }
      function _0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
          if (jt(t, e)) return;
          s.uniform4iv(this.addr, e), qt(t, e);
        }
      }
      function m0(s, e) {
        const t = this.cache;
        t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
      }
      function w0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
          if (jt(t, e)) return;
          s.uniform2uiv(this.addr, e), qt(t, e);
        }
      }
      function b0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
          if (jt(t, e)) return;
          s.uniform3uiv(this.addr, e), qt(t, e);
        }
      }
      function y0(s, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
          if (jt(t, e)) return;
          s.uniform4uiv(this.addr, e), qt(t, e);
        }
      }
      function x0(s, e, t) {
        const i = this.cache, n = t.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n);
        let r;
        this.type === s.SAMPLER_2D_SHADOW ? (Bu.compareFunction = Jf, r = Bu) : r = Mp, t.setTexture2D(e || r, n);
      }
      function E0(s, e, t) {
        const i = this.cache, n = t.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || Rp, n);
      }
      function v0(s, e, t) {
        const i = this.cache, n = t.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTextureCube(e || Bp, n);
      }
      function S0(s, e, t) {
        const i = this.cache, n = t.allocateTextureUnit();
        i[0] !== n && (s.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || Tp, n);
      }
      function C0(s) {
        switch (s) {
          case 5126:
            return o0;
          case 35664:
            return c0;
          case 35665:
            return l0;
          case 35666:
            return h0;
          case 35674:
            return d0;
          case 35675:
            return u0;
          case 35676:
            return f0;
          case 5124:
          case 35670:
            return p0;
          case 35667:
          case 35671:
            return A0;
          case 35668:
          case 35672:
            return g0;
          case 35669:
          case 35673:
            return _0;
          case 5125:
            return m0;
          case 36294:
            return w0;
          case 36295:
            return b0;
          case 36296:
            return y0;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return x0;
          case 35679:
          case 36299:
          case 36307:
            return E0;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return v0;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return S0;
        }
      }
      function I0(s, e) {
        s.uniform1fv(this.addr, e);
      }
      function M0(s, e) {
        const t = ds(e, this.size, 2);
        s.uniform2fv(this.addr, t);
      }
      function T0(s, e) {
        const t = ds(e, this.size, 3);
        s.uniform3fv(this.addr, t);
      }
      function R0(s, e) {
        const t = ds(e, this.size, 4);
        s.uniform4fv(this.addr, t);
      }
      function B0(s, e) {
        const t = ds(e, this.size, 4);
        s.uniformMatrix2fv(this.addr, false, t);
      }
      function D0(s, e) {
        const t = ds(e, this.size, 9);
        s.uniformMatrix3fv(this.addr, false, t);
      }
      function P0(s, e) {
        const t = ds(e, this.size, 16);
        s.uniformMatrix4fv(this.addr, false, t);
      }
      function L0(s, e) {
        s.uniform1iv(this.addr, e);
      }
      function F0(s, e) {
        s.uniform2iv(this.addr, e);
      }
      function k0(s, e) {
        s.uniform3iv(this.addr, e);
      }
      function U0(s, e) {
        s.uniform4iv(this.addr, e);
      }
      function N0(s, e) {
        s.uniform1uiv(this.addr, e);
      }
      function Q0(s, e) {
        s.uniform2uiv(this.addr, e);
      }
      function O0(s, e) {
        s.uniform3uiv(this.addr, e);
      }
      function z0(s, e) {
        s.uniform4uiv(this.addr, e);
      }
      function G0(s, e, t) {
        const i = this.cache, n = e.length, r = zo(t, n);
        jt(i, r) || (s.uniform1iv(this.addr, r), qt(i, r));
        for (let a = 0; a !== n; ++a) t.setTexture2D(e[a] || Mp, r[a]);
      }
      function H0(s, e, t) {
        const i = this.cache, n = e.length, r = zo(t, n);
        jt(i, r) || (s.uniform1iv(this.addr, r), qt(i, r));
        for (let a = 0; a !== n; ++a) t.setTexture3D(e[a] || Rp, r[a]);
      }
      function V0(s, e, t) {
        const i = this.cache, n = e.length, r = zo(t, n);
        jt(i, r) || (s.uniform1iv(this.addr, r), qt(i, r));
        for (let a = 0; a !== n; ++a) t.setTextureCube(e[a] || Bp, r[a]);
      }
      function W0(s, e, t) {
        const i = this.cache, n = e.length, r = zo(t, n);
        jt(i, r) || (s.uniform1iv(this.addr, r), qt(i, r));
        for (let a = 0; a !== n; ++a) t.setTexture2DArray(e[a] || Tp, r[a]);
      }
      function j0(s) {
        switch (s) {
          case 5126:
            return I0;
          case 35664:
            return M0;
          case 35665:
            return T0;
          case 35666:
            return R0;
          case 35674:
            return B0;
          case 35675:
            return D0;
          case 35676:
            return P0;
          case 5124:
          case 35670:
            return L0;
          case 35667:
          case 35671:
            return F0;
          case 35668:
          case 35672:
            return k0;
          case 35669:
          case 35673:
            return U0;
          case 5125:
            return N0;
          case 36294:
            return Q0;
          case 36295:
            return O0;
          case 36296:
            return z0;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return G0;
          case 35679:
          case 36299:
          case 36307:
            return H0;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return V0;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return W0;
        }
      }
      class q0 {
        constructor(e, t, i) {
          this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = C0(t.type);
        }
      }
      class X0 {
        constructor(e, t, i) {
          this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = j0(t.type);
        }
      }
      class Y0 {
        constructor(e) {
          this.id = e, this.seq = [], this.map = {};
        }
        setValue(e, t, i) {
          const n = this.seq;
          for (let r = 0, a = n.length; r !== a; ++r) {
            const o = n[r];
            o.setValue(e, t[o.id], i);
          }
        }
      }
      const Uc = /(\w+)(\])?(\[|\.)?/g;
      function Uu(s, e) {
        s.seq.push(e), s.map[e.id] = e;
      }
      function K0(s, e, t) {
        const i = s.name, n = i.length;
        for (Uc.lastIndex = 0; ; ) {
          const r = Uc.exec(i), a = Uc.lastIndex;
          let o = r[1];
          const c = r[2] === "]", l = r[3];
          if (c && (o = o | 0), l === void 0 || l === "[" && a + 2 === n) {
            Uu(t, l === void 0 ? new q0(o, s, e) : new X0(o, s, e));
            break;
          } else {
            let d = t.map[o];
            d === void 0 && (d = new Y0(o), Uu(t, d)), t = d;
          }
        }
      }
      class oo {
        constructor(e, t) {
          this.seq = [], this.map = {};
          const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let n = 0; n < i; ++n) {
            const r = e.getActiveUniform(t, n), a = e.getUniformLocation(t, r.name);
            K0(r, a, this);
          }
        }
        setValue(e, t, i, n) {
          const r = this.map[t];
          r !== void 0 && r.setValue(e, i, n);
        }
        setOptional(e, t, i) {
          const n = t[i];
          n !== void 0 && this.setValue(e, i, n);
        }
        static upload(e, t, i, n) {
          for (let r = 0, a = t.length; r !== a; ++r) {
            const o = t[r], c = i[o.id];
            c.needsUpdate !== false && o.setValue(e, c.value, n);
          }
        }
        static seqWithValue(e, t) {
          const i = [];
          for (let n = 0, r = e.length; n !== r; ++n) {
            const a = e[n];
            a.id in t && i.push(a);
          }
          return i;
        }
      }
      function Nu(s, e, t) {
        const i = s.createShader(e);
        return s.shaderSource(i, t), s.compileShader(i), i;
      }
      const J0 = 37297;
      let Z0 = 0;
      function $0(s, e) {
        const t = s.split(`
`), i = [], n = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
        for (let a = n; a < r; a++) {
          const o = a + 1;
          i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
        }
        return i.join(`
`);
      }
      const Qu = new Oe();
      function ex(s) {
        ze._getMatrix(Qu, ze.workingColorSpace, s);
        const e = `mat3( ${Qu.elements.map((t) => t.toFixed(4))} )`;
        switch (ze.getTransfer(s)) {
          case wo:
            return [
              e,
              "LinearTransferOETF"
            ];
          case pt:
            return [
              e,
              "sRGBTransferOETF"
            ];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [
              e,
              "LinearTransferOETF"
            ];
        }
      }
      function Ou(s, e, t) {
        const i = s.getShaderParameter(e, s.COMPILE_STATUS), n = s.getShaderInfoLog(e).trim();
        if (i && n === "") return "";
        const r = /ERROR: 0:(\d+)/.exec(n);
        if (r) {
          const a = parseInt(r[1]);
          return t.toUpperCase() + `

` + n + `

` + $0(s.getShaderSource(e), a);
        } else return n;
      }
      function tx(s, e) {
        const t = ex(e);
        return [
          `vec4 ${s}( vec4 value ) {`,
          `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
          "}"
        ].join(`
`);
      }
      function ix(s, e) {
        let t;
        switch (e) {
          case Sg:
            t = "Linear";
            break;
          case Cg:
            t = "Reinhard";
            break;
          case Ig:
            t = "Cineon";
            break;
          case Mg:
            t = "ACESFilmic";
            break;
          case Rg:
            t = "AgX";
            break;
          case Bg:
            t = "Neutral";
            break;
          case Tg:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
        }
        return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
      }
      const Xa = new T();
      function nx() {
        ze.getLuminanceCoefficients(Xa);
        const s = Xa.x.toFixed(4), e = Xa.y.toFixed(4), t = Xa.z.toFixed(4);
        return [
          "float luminance( const in vec3 rgb ) {",
          `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`,
          "	return dot( weights, rgb );",
          "}"
        ].join(`
`);
      }
      function rx(s) {
        return [
          s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
          s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(Is).join(`
`);
      }
      function sx(s) {
        const e = [];
        for (const t in s) {
          const i = s[t];
          i !== false && e.push("#define " + t + " " + i);
        }
        return e.join(`
`);
      }
      function ax(s, e) {
        const t = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
        for (let n = 0; n < i; n++) {
          const r = s.getActiveAttrib(e, n), a = r.name;
          let o = 1;
          r.type === s.FLOAT_MAT2 && (o = 2), r.type === s.FLOAT_MAT3 && (o = 3), r.type === s.FLOAT_MAT4 && (o = 4), t[a] = {
            type: r.type,
            location: s.getAttribLocation(e, a),
            locationSize: o
          };
        }
        return t;
      }
      function Is(s) {
        return s !== "";
      }
      function zu(s, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Gu(s, e) {
        return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
      }
      const ox = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function ql(s) {
        return s.replace(ox, lx);
      }
      const cx = /* @__PURE__ */ new Map();
      function lx(s, e) {
        let t = Qe[e];
        if (t === void 0) {
          const i = cx.get(e);
          if (i !== void 0) t = Qe[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
          else throw new Error("Can not resolve #include <" + e + ">");
        }
        return ql(t);
      }
      const hx = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Hu(s) {
        return s.replace(hx, dx);
      }
      function dx(s, e, t, i) {
        let n = "";
        for (let r = parseInt(e); r < parseInt(t); r++) n += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
        return n;
      }
      function Vu(s) {
        let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
        return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
      }
      function ux(s) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return s.shadowMapType === Nf ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === Qf ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === _n && (e = "SHADOWMAP_TYPE_VSM"), e;
      }
      function fx(s) {
        let e = "ENVMAP_TYPE_CUBE";
        if (s.envMap) switch (s.envMapMode) {
          case pr:
          case $r:
            e = "ENVMAP_TYPE_CUBE";
            break;
          case Po:
            e = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
        return e;
      }
      function px(s) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (s.envMap) switch (s.envMapMode) {
          case $r:
            e = "ENVMAP_MODE_REFRACTION";
            break;
        }
        return e;
      }
      function Ax(s) {
        let e = "ENVMAP_BLENDING_NONE";
        if (s.envMap) switch (s.combine) {
          case Do:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case Eg:
            e = "ENVMAP_BLENDING_MIX";
            break;
          case vg:
            e = "ENVMAP_BLENDING_ADD";
            break;
        }
        return e;
      }
      function gx(s) {
        const e = s.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2, i = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
          texelHeight: i,
          maxMip: t
        };
      }
      function _x(s, e, t, i) {
        const n = s.getContext(), r = t.defines;
        let a = t.vertexShader, o = t.fragmentShader;
        const c = ux(t), l = fx(t), h = px(t), d = Ax(t), u = gx(t), f = rx(t), p = sx(r), m = n.createProgram();
        let g, A, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (g = [
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          p
        ].filter(Is).join(`
`), g.length > 0 && (g += `
`), A = [
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          p
        ].filter(Is).join(`
`), A.length > 0 && (A += `
`)) : (g = [
          Vu(t),
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          p,
          t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          t.batching ? "#define USE_BATCHING" : "",
          t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
          t.instancing ? "#define USE_INSTANCING" : "",
          t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
          t.useFog && t.fog ? "#define USE_FOG" : "",
          t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
          t.map ? "#define USE_MAP" : "",
          t.envMap ? "#define USE_ENVMAP" : "",
          t.envMap ? "#define " + h : "",
          t.lightMap ? "#define USE_LIGHTMAP" : "",
          t.aoMap ? "#define USE_AOMAP" : "",
          t.bumpMap ? "#define USE_BUMPMAP" : "",
          t.normalMap ? "#define USE_NORMALMAP" : "",
          t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          t.anisotropy ? "#define USE_ANISOTROPY" : "",
          t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          t.specularMap ? "#define USE_SPECULARMAP" : "",
          t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          t.metalnessMap ? "#define USE_METALNESSMAP" : "",
          t.alphaMap ? "#define USE_ALPHAMAP" : "",
          t.alphaHash ? "#define USE_ALPHAHASH" : "",
          t.transmission ? "#define USE_TRANSMISSION" : "",
          t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          t.mapUv ? "#define MAP_UV " + t.mapUv : "",
          t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
          t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
          t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
          t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
          t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
          t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
          t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
          t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
          t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
          t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
          t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
          t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
          t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
          t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
          t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
          t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
          t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
          t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
          t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
          t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
          t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
          t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
          t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
          t.vertexColors ? "#define USE_COLOR" : "",
          t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          t.vertexUv1s ? "#define USE_UV1" : "",
          t.vertexUv2s ? "#define USE_UV2" : "",
          t.vertexUv3s ? "#define USE_UV3" : "",
          t.pointsUvs ? "#define USE_POINTS_UV" : "",
          t.flatShading ? "#define FLAT_SHADED" : "",
          t.skinning ? "#define USE_SKINNING" : "",
          t.morphTargets ? "#define USE_MORPHTARGETS" : "",
          t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "",
          t.morphColors ? "#define USE_MORPHCOLORS" : "",
          t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
          t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
          t.doubleSided ? "#define DOUBLE_SIDED" : "",
          t.flipSided ? "#define FLIP_SIDED" : "",
          t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          t.shadowMapEnabled ? "#define " + c : "",
          t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "#ifdef USE_INSTANCING_MORPH",
          "	uniform sampler2D morphTexture;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "	attribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "	attribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "	attribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`
        ].filter(Is).join(`
`), A = [
          Vu(t),
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          p,
          t.useFog && t.fog ? "#define USE_FOG" : "",
          t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
          t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
          t.map ? "#define USE_MAP" : "",
          t.matcap ? "#define USE_MATCAP" : "",
          t.envMap ? "#define USE_ENVMAP" : "",
          t.envMap ? "#define " + l : "",
          t.envMap ? "#define " + h : "",
          t.envMap ? "#define " + d : "",
          u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "",
          u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "",
          u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "",
          t.lightMap ? "#define USE_LIGHTMAP" : "",
          t.aoMap ? "#define USE_AOMAP" : "",
          t.bumpMap ? "#define USE_BUMPMAP" : "",
          t.normalMap ? "#define USE_NORMALMAP" : "",
          t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          t.anisotropy ? "#define USE_ANISOTROPY" : "",
          t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          t.clearcoat ? "#define USE_CLEARCOAT" : "",
          t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          t.dispersion ? "#define USE_DISPERSION" : "",
          t.iridescence ? "#define USE_IRIDESCENCE" : "",
          t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          t.specularMap ? "#define USE_SPECULARMAP" : "",
          t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          t.metalnessMap ? "#define USE_METALNESSMAP" : "",
          t.alphaMap ? "#define USE_ALPHAMAP" : "",
          t.alphaTest ? "#define USE_ALPHATEST" : "",
          t.alphaHash ? "#define USE_ALPHAHASH" : "",
          t.sheen ? "#define USE_SHEEN" : "",
          t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          t.transmission ? "#define USE_TRANSMISSION" : "",
          t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
          t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
          t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          t.vertexUv1s ? "#define USE_UV1" : "",
          t.vertexUv2s ? "#define USE_UV2" : "",
          t.vertexUv3s ? "#define USE_UV3" : "",
          t.pointsUvs ? "#define USE_POINTS_UV" : "",
          t.gradientMap ? "#define USE_GRADIENTMAP" : "",
          t.flatShading ? "#define FLAT_SHADED" : "",
          t.doubleSided ? "#define DOUBLE_SIDED" : "",
          t.flipSided ? "#define FLIP_SIDED" : "",
          t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          t.shadowMapEnabled ? "#define " + c : "",
          t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
          t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          t.toneMapping !== Gn ? "#define TONE_MAPPING" : "",
          t.toneMapping !== Gn ? Qe.tonemapping_pars_fragment : "",
          t.toneMapping !== Gn ? ix("toneMapping", t.toneMapping) : "",
          t.dithering ? "#define DITHERING" : "",
          t.opaque ? "#define OPAQUE" : "",
          Qe.colorspace_pars_fragment,
          tx("linearToOutputTexel", t.outputColorSpace),
          nx(),
          t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
          `
`
        ].filter(Is).join(`
`)), a = ql(a), a = zu(a, t), a = Gu(a, t), o = ql(o), o = zu(o, t), o = Gu(o, t), a = Hu(a), o = Hu(o), t.isRawShaderMaterial !== true && (x = `#version 300 es
`, g = [
          f,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + g, A = [
          "#define varying in",
          t.glslVersion === Id ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Id ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + A);
        const b = x + g + a, y = x + A + o, I = Nu(n, n.VERTEX_SHADER, b), M = Nu(n, n.FRAGMENT_SHADER, y);
        n.attachShader(m, I), n.attachShader(m, M), t.index0AttributeName !== void 0 ? n.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === true && n.bindAttribLocation(m, 0, "position"), n.linkProgram(m);
        function R(P) {
          if (s.debug.checkShaderErrors) {
            const j = n.getProgramInfoLog(m).trim(), H = n.getShaderInfoLog(I).trim(), Y = n.getShaderInfoLog(M).trim();
            let te = true, q = true;
            if (n.getProgramParameter(m, n.LINK_STATUS) === false) if (te = false, typeof s.debug.onShaderError == "function") s.debug.onShaderError(n, m, I, M);
            else {
              const Z = Ou(n, I, "vertex"), V = Ou(n, M, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(m, n.VALIDATE_STATUS) + `

Material Name: ` + P.name + `
Material Type: ` + P.type + `

Program Info Log: ` + j + `
` + Z + `
` + V);
            }
            else j !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", j) : (H === "" || Y === "") && (q = false);
            q && (P.diagnostics = {
              runnable: te,
              programLog: j,
              vertexShader: {
                log: H,
                prefix: g
              },
              fragmentShader: {
                log: Y,
                prefix: A
              }
            });
          }
          n.deleteShader(I), n.deleteShader(M), D = new oo(n, m), S = ax(n, m);
        }
        let D;
        this.getUniforms = function() {
          return D === void 0 && R(this), D;
        };
        let S;
        this.getAttributes = function() {
          return S === void 0 && R(this), S;
        };
        let E = t.rendererExtensionParallelShaderCompile === false;
        return this.isReady = function() {
          return E === false && (E = n.getProgramParameter(m, J0)), E;
        }, this.destroy = function() {
          i.releaseStatesOfProgram(this), n.deleteProgram(m), this.program = void 0;
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = Z0++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = I, this.fragmentShader = M, this;
      }
      let mx = 0;
      class wx {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
        }
        update(e) {
          const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), r = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
          return a.has(n) === false && (a.add(n), n.usedTimes++), a.has(r) === false && (a.add(r), r.usedTimes++), this;
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          return i === void 0 && (i = new bx(e), t.set(e, i)), i;
        }
      }
      class bx {
        constructor(e) {
          this.id = mx++, this.code = e, this.usedTimes = 0;
        }
      }
      function yx(s, e, t, i, n, r, a) {
        const o = new vh(), c = new wx(), l = /* @__PURE__ */ new Set(), h = [], d = n.logarithmicDepthBuffer, u = n.vertexTextures;
        let f = n.precision;
        const p = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function m(S) {
          return l.add(S), S === 0 ? "uv" : `uv${S}`;
        }
        function g(S, E, P, j, H) {
          const Y = j.fog, te = H.geometry, q = S.isMeshStandardMaterial ? j.environment : null, Z = (S.isMeshStandardMaterial ? t : e).get(S.envMap || q), V = Z && Z.mapping === Po ? Z.image.height : null, re = p[S.type];
          S.precision !== null && (f = n.getMaxPrecision(S.precision), f !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", f, "instead."));
          const he = te.morphAttributes.position || te.morphAttributes.normal || te.morphAttributes.color, ve = he !== void 0 ? he.length : 0;
          let Pe = 0;
          te.morphAttributes.position !== void 0 && (Pe = 1), te.morphAttributes.normal !== void 0 && (Pe = 2), te.morphAttributes.color !== void 0 && (Pe = 3);
          let Ve, K, ae, be;
          if (re) {
            const ut = sn[re];
            Ve = ut.vertexShader, K = ut.fragmentShader;
          } else Ve = S.vertexShader, K = S.fragmentShader, c.update(S), ae = c.getVertexShaderID(S), be = c.getFragmentShaderID(S);
          const le = s.getRenderTarget(), Te = s.state.buffers.depth.getReversed(), Ze = H.isInstancedMesh === true, Le = H.isBatchedMesh === true, St = !!S.map, wt = !!S.matcap, Ke = !!Z, F = !!S.aoMap, Ci = !!S.lightMap, rt = !!S.bumpMap, $e = !!S.normalMap, Ie = !!S.displacementMap, xt = !!S.emissiveMap, Ce = !!S.metalnessMap, B = !!S.roughnessMap, v = S.anisotropy > 0, z = S.clearcoat > 0, $ = S.dispersion > 0, ie = S.iridescence > 0, J = S.sheen > 0, Se = S.transmission > 0, fe = v && !!S.anisotropyMap, we = z && !!S.clearcoatMap, st = z && !!S.clearcoatNormalMap, se = z && !!S.clearcoatRoughnessMap, ye = ie && !!S.iridescenceMap, Fe = ie && !!S.iridescenceThicknessMap, Ue = J && !!S.sheenColorMap, xe = J && !!S.sheenRoughnessMap, et = !!S.specularMap, qe = !!S.specularColorMap, bt = !!S.specularIntensityMap, N = Se && !!S.transmissionMap, pe = Se && !!S.thicknessMap, X = !!S.gradientMap, ee = !!S.alphaMap, _e = S.alphaTest > 0, Ae = !!S.alphaHash, We = !!S.extensions;
          let Bt = Gn;
          S.toneMapped && (le === null || le.isXRRenderTarget === true) && (Bt = s.toneMapping);
          const ri = {
            shaderID: re,
            shaderType: S.type,
            shaderName: S.name,
            vertexShader: Ve,
            fragmentShader: K,
            defines: S.defines,
            customVertexShaderID: ae,
            customFragmentShaderID: be,
            isRawShaderMaterial: S.isRawShaderMaterial === true,
            glslVersion: S.glslVersion,
            precision: f,
            batching: Le,
            batchingColor: Le && H._colorsTexture !== null,
            instancing: Ze,
            instancingColor: Ze && H.instanceColor !== null,
            instancingMorph: Ze && H.morphTexture !== null,
            supportsVertexTextures: u,
            outputColorSpace: le === null ? s.outputColorSpace : le.isXRRenderTarget === true ? le.texture.colorSpace : oi,
            alphaToCoverage: !!S.alphaToCoverage,
            map: St,
            matcap: wt,
            envMap: Ke,
            envMapMode: Ke && Z.mapping,
            envMapCubeUVHeight: V,
            aoMap: F,
            lightMap: Ci,
            bumpMap: rt,
            normalMap: $e,
            displacementMap: u && Ie,
            emissiveMap: xt,
            normalMapObjectSpace: $e && S.normalMapType === Qg,
            normalMapTangentSpace: $e && S.normalMapType === Fo,
            metalnessMap: Ce,
            roughnessMap: B,
            anisotropy: v,
            anisotropyMap: fe,
            clearcoat: z,
            clearcoatMap: we,
            clearcoatNormalMap: st,
            clearcoatRoughnessMap: se,
            dispersion: $,
            iridescence: ie,
            iridescenceMap: ye,
            iridescenceThicknessMap: Fe,
            sheen: J,
            sheenColorMap: Ue,
            sheenRoughnessMap: xe,
            specularMap: et,
            specularColorMap: qe,
            specularIntensityMap: bt,
            transmission: Se,
            transmissionMap: N,
            thicknessMap: pe,
            gradientMap: X,
            opaque: S.transparent === false && S.blending === Xr && S.alphaToCoverage === false,
            alphaMap: ee,
            alphaTest: _e,
            alphaHash: Ae,
            combine: S.combine,
            mapUv: St && m(S.map.channel),
            aoMapUv: F && m(S.aoMap.channel),
            lightMapUv: Ci && m(S.lightMap.channel),
            bumpMapUv: rt && m(S.bumpMap.channel),
            normalMapUv: $e && m(S.normalMap.channel),
            displacementMapUv: Ie && m(S.displacementMap.channel),
            emissiveMapUv: xt && m(S.emissiveMap.channel),
            metalnessMapUv: Ce && m(S.metalnessMap.channel),
            roughnessMapUv: B && m(S.roughnessMap.channel),
            anisotropyMapUv: fe && m(S.anisotropyMap.channel),
            clearcoatMapUv: we && m(S.clearcoatMap.channel),
            clearcoatNormalMapUv: st && m(S.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: se && m(S.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ye && m(S.iridescenceMap.channel),
            iridescenceThicknessMapUv: Fe && m(S.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ue && m(S.sheenColorMap.channel),
            sheenRoughnessMapUv: xe && m(S.sheenRoughnessMap.channel),
            specularMapUv: et && m(S.specularMap.channel),
            specularColorMapUv: qe && m(S.specularColorMap.channel),
            specularIntensityMapUv: bt && m(S.specularIntensityMap.channel),
            transmissionMapUv: N && m(S.transmissionMap.channel),
            thicknessMapUv: pe && m(S.thicknessMap.channel),
            alphaMapUv: ee && m(S.alphaMap.channel),
            vertexTangents: !!te.attributes.tangent && ($e || v),
            vertexColors: S.vertexColors,
            vertexAlphas: S.vertexColors === true && !!te.attributes.color && te.attributes.color.itemSize === 4,
            pointsUvs: H.isPoints === true && !!te.attributes.uv && (St || ee),
            fog: !!Y,
            useFog: S.fog === true,
            fogExp2: !!Y && Y.isFogExp2,
            flatShading: S.flatShading === true,
            sizeAttenuation: S.sizeAttenuation === true,
            logarithmicDepthBuffer: d,
            reverseDepthBuffer: Te,
            skinning: H.isSkinnedMesh === true,
            morphTargets: te.morphAttributes.position !== void 0,
            morphNormals: te.morphAttributes.normal !== void 0,
            morphColors: te.morphAttributes.color !== void 0,
            morphTargetsCount: ve,
            morphTextureStride: Pe,
            numDirLights: E.directional.length,
            numPointLights: E.point.length,
            numSpotLights: E.spot.length,
            numSpotLightMaps: E.spotLightMap.length,
            numRectAreaLights: E.rectArea.length,
            numHemiLights: E.hemi.length,
            numDirLightShadows: E.directionalShadowMap.length,
            numPointLightShadows: E.pointShadowMap.length,
            numSpotLightShadows: E.spotShadowMap.length,
            numSpotLightShadowsWithMaps: E.numSpotLightShadowsWithMaps,
            numLightProbes: E.numLightProbes,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: S.dithering,
            shadowMapEnabled: s.shadowMap.enabled && P.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: Bt,
            decodeVideoTexture: St && S.map.isVideoTexture === true && ze.getTransfer(S.map.colorSpace) === pt,
            decodeVideoTextureEmissive: xt && S.emissiveMap.isVideoTexture === true && ze.getTransfer(S.emissiveMap.colorSpace) === pt,
            premultipliedAlpha: S.premultipliedAlpha,
            doubleSided: S.side === Yi,
            flipSided: S.side === _i,
            useDepthPacking: S.depthPacking >= 0,
            depthPacking: S.depthPacking || 0,
            index0AttributeName: S.index0AttributeName,
            extensionClipCullDistance: We && S.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (We && S.extensions.multiDraw === true || Le) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: S.customProgramCacheKey()
          };
          return ri.vertexUv1s = l.has(1), ri.vertexUv2s = l.has(2), ri.vertexUv3s = l.has(3), l.clear(), ri;
        }
        function A(S) {
          const E = [];
          if (S.shaderID ? E.push(S.shaderID) : (E.push(S.customVertexShaderID), E.push(S.customFragmentShaderID)), S.defines !== void 0) for (const P in S.defines) E.push(P), E.push(S.defines[P]);
          return S.isRawShaderMaterial === false && (x(E, S), b(E, S), E.push(s.outputColorSpace)), E.push(S.customProgramCacheKey), E.join();
        }
        function x(S, E) {
          S.push(E.precision), S.push(E.outputColorSpace), S.push(E.envMapMode), S.push(E.envMapCubeUVHeight), S.push(E.mapUv), S.push(E.alphaMapUv), S.push(E.lightMapUv), S.push(E.aoMapUv), S.push(E.bumpMapUv), S.push(E.normalMapUv), S.push(E.displacementMapUv), S.push(E.emissiveMapUv), S.push(E.metalnessMapUv), S.push(E.roughnessMapUv), S.push(E.anisotropyMapUv), S.push(E.clearcoatMapUv), S.push(E.clearcoatNormalMapUv), S.push(E.clearcoatRoughnessMapUv), S.push(E.iridescenceMapUv), S.push(E.iridescenceThicknessMapUv), S.push(E.sheenColorMapUv), S.push(E.sheenRoughnessMapUv), S.push(E.specularMapUv), S.push(E.specularColorMapUv), S.push(E.specularIntensityMapUv), S.push(E.transmissionMapUv), S.push(E.thicknessMapUv), S.push(E.combine), S.push(E.fogExp2), S.push(E.sizeAttenuation), S.push(E.morphTargetsCount), S.push(E.morphAttributeCount), S.push(E.numDirLights), S.push(E.numPointLights), S.push(E.numSpotLights), S.push(E.numSpotLightMaps), S.push(E.numHemiLights), S.push(E.numRectAreaLights), S.push(E.numDirLightShadows), S.push(E.numPointLightShadows), S.push(E.numSpotLightShadows), S.push(E.numSpotLightShadowsWithMaps), S.push(E.numLightProbes), S.push(E.shadowMapType), S.push(E.toneMapping), S.push(E.numClippingPlanes), S.push(E.numClipIntersection), S.push(E.depthPacking);
        }
        function b(S, E) {
          o.disableAll(), E.supportsVertexTextures && o.enable(0), E.instancing && o.enable(1), E.instancingColor && o.enable(2), E.instancingMorph && o.enable(3), E.matcap && o.enable(4), E.envMap && o.enable(5), E.normalMapObjectSpace && o.enable(6), E.normalMapTangentSpace && o.enable(7), E.clearcoat && o.enable(8), E.iridescence && o.enable(9), E.alphaTest && o.enable(10), E.vertexColors && o.enable(11), E.vertexAlphas && o.enable(12), E.vertexUv1s && o.enable(13), E.vertexUv2s && o.enable(14), E.vertexUv3s && o.enable(15), E.vertexTangents && o.enable(16), E.anisotropy && o.enable(17), E.alphaHash && o.enable(18), E.batching && o.enable(19), E.dispersion && o.enable(20), E.batchingColor && o.enable(21), S.push(o.mask), o.disableAll(), E.fog && o.enable(0), E.useFog && o.enable(1), E.flatShading && o.enable(2), E.logarithmicDepthBuffer && o.enable(3), E.reverseDepthBuffer && o.enable(4), E.skinning && o.enable(5), E.morphTargets && o.enable(6), E.morphNormals && o.enable(7), E.morphColors && o.enable(8), E.premultipliedAlpha && o.enable(9), E.shadowMapEnabled && o.enable(10), E.doubleSided && o.enable(11), E.flipSided && o.enable(12), E.useDepthPacking && o.enable(13), E.dithering && o.enable(14), E.transmission && o.enable(15), E.sheen && o.enable(16), E.opaque && o.enable(17), E.pointsUvs && o.enable(18), E.decodeVideoTexture && o.enable(19), E.decodeVideoTextureEmissive && o.enable(20), E.alphaToCoverage && o.enable(21), S.push(o.mask);
        }
        function y(S) {
          const E = p[S.type];
          let P;
          if (E) {
            const j = sn[E];
            P = Uo.clone(j.uniforms);
          } else P = S.uniforms;
          return P;
        }
        function I(S, E) {
          let P;
          for (let j = 0, H = h.length; j < H; j++) {
            const Y = h[j];
            if (Y.cacheKey === E) {
              P = Y, ++P.usedTimes;
              break;
            }
          }
          return P === void 0 && (P = new _x(s, E, S, r), h.push(P)), P;
        }
        function M(S) {
          if (--S.usedTimes === 0) {
            const E = h.indexOf(S);
            h[E] = h[h.length - 1], h.pop(), S.destroy();
          }
        }
        function R(S) {
          c.remove(S);
        }
        function D() {
          c.dispose();
        }
        return {
          getParameters: g,
          getProgramCacheKey: A,
          getUniforms: y,
          acquireProgram: I,
          releaseProgram: M,
          releaseShaderCache: R,
          programs: h,
          dispose: D
        };
      }
      function xx() {
        let s = /* @__PURE__ */ new WeakMap();
        function e(a) {
          return s.has(a);
        }
        function t(a) {
          let o = s.get(a);
          return o === void 0 && (o = {}, s.set(a, o)), o;
        }
        function i(a) {
          s.delete(a);
        }
        function n(a, o, c) {
          s.get(a)[o] = c;
        }
        function r() {
          s = /* @__PURE__ */ new WeakMap();
        }
        return {
          has: e,
          get: t,
          remove: i,
          update: n,
          dispose: r
        };
      }
      function Ex(s, e) {
        return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
      }
      function Wu(s, e) {
        return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
      }
      function ju() {
        const s = [];
        let e = 0;
        const t = [], i = [], n = [];
        function r() {
          e = 0, t.length = 0, i.length = 0, n.length = 0;
        }
        function a(d, u, f, p, m, g) {
          let A = s[e];
          return A === void 0 ? (A = {
            id: d.id,
            object: d,
            geometry: u,
            material: f,
            groupOrder: p,
            renderOrder: d.renderOrder,
            z: m,
            group: g
          }, s[e] = A) : (A.id = d.id, A.object = d, A.geometry = u, A.material = f, A.groupOrder = p, A.renderOrder = d.renderOrder, A.z = m, A.group = g), e++, A;
        }
        function o(d, u, f, p, m, g) {
          const A = a(d, u, f, p, m, g);
          f.transmission > 0 ? i.push(A) : f.transparent === true ? n.push(A) : t.push(A);
        }
        function c(d, u, f, p, m, g) {
          const A = a(d, u, f, p, m, g);
          f.transmission > 0 ? i.unshift(A) : f.transparent === true ? n.unshift(A) : t.unshift(A);
        }
        function l(d, u) {
          t.length > 1 && t.sort(d || Ex), i.length > 1 && i.sort(u || Wu), n.length > 1 && n.sort(u || Wu);
        }
        function h() {
          for (let d = e, u = s.length; d < u; d++) {
            const f = s[d];
            if (f.id === null) break;
            f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
          }
        }
        return {
          opaque: t,
          transmissive: i,
          transparent: n,
          init: r,
          push: o,
          unshift: c,
          finish: h,
          sort: l
        };
      }
      function vx() {
        let s = /* @__PURE__ */ new WeakMap();
        function e(i, n) {
          const r = s.get(i);
          let a;
          return r === void 0 ? (a = new ju(), s.set(i, [
            a
          ])) : n >= r.length ? (a = new ju(), r.push(a)) : a = r[n], a;
        }
        function t() {
          s = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: e,
          dispose: t
        };
      }
      function Sx() {
        const s = {};
        return {
          get: function(e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  direction: new T(),
                  color: new ue()
                };
                break;
              case "SpotLight":
                t = {
                  position: new T(),
                  direction: new T(),
                  color: new ue(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                t = {
                  position: new T(),
                  color: new ue(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new T(),
                  skyColor: new ue(),
                  groundColor: new ue()
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new ue(),
                  position: new T(),
                  halfWidth: new T(),
                  halfHeight: new T()
                };
                break;
            }
            return s[e.id] = t, t;
          }
        };
      }
      function Cx() {
        const s = {};
        return {
          get: function(e) {
            if (s[e.id] !== void 0) return s[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new oe()
                };
                break;
              case "SpotLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new oe()
                };
                break;
              case "PointLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new oe(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            return s[e.id] = t, t;
          }
        };
      }
      let Ix = 0;
      function Mx(s, e) {
        return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
      }
      function Tx(s) {
        const e = new Sx(), t = Cx(), i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
          },
          ambient: [
            0,
            0,
            0
          ],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
          numLightProbes: 0
        };
        for (let l = 0; l < 9; l++) i.probe.push(new T());
        const n = new T(), r = new ge(), a = new ge();
        function o(l) {
          let h = 0, d = 0, u = 0;
          for (let S = 0; S < 9; S++) i.probe[S].set(0, 0, 0);
          let f = 0, p = 0, m = 0, g = 0, A = 0, x = 0, b = 0, y = 0, I = 0, M = 0, R = 0;
          l.sort(Mx);
          for (let S = 0, E = l.length; S < E; S++) {
            const P = l[S], j = P.color, H = P.intensity, Y = P.distance, te = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
            if (P.isAmbientLight) h += j.r * H, d += j.g * H, u += j.b * H;
            else if (P.isLightProbe) {
              for (let q = 0; q < 9; q++) i.probe[q].addScaledVector(P.sh.coefficients[q], H);
              R++;
            } else if (P.isDirectionalLight) {
              const q = e.get(P);
              if (q.color.copy(P.color).multiplyScalar(P.intensity), P.castShadow) {
                const Z = P.shadow, V = t.get(P);
                V.shadowIntensity = Z.intensity, V.shadowBias = Z.bias, V.shadowNormalBias = Z.normalBias, V.shadowRadius = Z.radius, V.shadowMapSize = Z.mapSize, i.directionalShadow[f] = V, i.directionalShadowMap[f] = te, i.directionalShadowMatrix[f] = P.shadow.matrix, x++;
              }
              i.directional[f] = q, f++;
            } else if (P.isSpotLight) {
              const q = e.get(P);
              q.position.setFromMatrixPosition(P.matrixWorld), q.color.copy(j).multiplyScalar(H), q.distance = Y, q.coneCos = Math.cos(P.angle), q.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)), q.decay = P.decay, i.spot[m] = q;
              const Z = P.shadow;
              if (P.map && (i.spotLightMap[I] = P.map, I++, Z.updateMatrices(P), P.castShadow && M++), i.spotLightMatrix[m] = Z.matrix, P.castShadow) {
                const V = t.get(P);
                V.shadowIntensity = Z.intensity, V.shadowBias = Z.bias, V.shadowNormalBias = Z.normalBias, V.shadowRadius = Z.radius, V.shadowMapSize = Z.mapSize, i.spotShadow[m] = V, i.spotShadowMap[m] = te, y++;
              }
              m++;
            } else if (P.isRectAreaLight) {
              const q = e.get(P);
              q.color.copy(j).multiplyScalar(H), q.halfWidth.set(P.width * 0.5, 0, 0), q.halfHeight.set(0, P.height * 0.5, 0), i.rectArea[g] = q, g++;
            } else if (P.isPointLight) {
              const q = e.get(P);
              if (q.color.copy(P.color).multiplyScalar(P.intensity), q.distance = P.distance, q.decay = P.decay, P.castShadow) {
                const Z = P.shadow, V = t.get(P);
                V.shadowIntensity = Z.intensity, V.shadowBias = Z.bias, V.shadowNormalBias = Z.normalBias, V.shadowRadius = Z.radius, V.shadowMapSize = Z.mapSize, V.shadowCameraNear = Z.camera.near, V.shadowCameraFar = Z.camera.far, i.pointShadow[p] = V, i.pointShadowMap[p] = te, i.pointShadowMatrix[p] = P.shadow.matrix, b++;
              }
              i.point[p] = q, p++;
            } else if (P.isHemisphereLight) {
              const q = e.get(P);
              q.skyColor.copy(P.color).multiplyScalar(H), q.groundColor.copy(P.groundColor).multiplyScalar(H), i.hemi[A] = q, A++;
            }
          }
          g > 0 && (s.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = ce.LTC_FLOAT_1, i.rectAreaLTC2 = ce.LTC_FLOAT_2) : (i.rectAreaLTC1 = ce.LTC_HALF_1, i.rectAreaLTC2 = ce.LTC_HALF_2)), i.ambient[0] = h, i.ambient[1] = d, i.ambient[2] = u;
          const D = i.hash;
          (D.directionalLength !== f || D.pointLength !== p || D.spotLength !== m || D.rectAreaLength !== g || D.hemiLength !== A || D.numDirectionalShadows !== x || D.numPointShadows !== b || D.numSpotShadows !== y || D.numSpotMaps !== I || D.numLightProbes !== R) && (i.directional.length = f, i.spot.length = m, i.rectArea.length = g, i.point.length = p, i.hemi.length = A, i.directionalShadow.length = x, i.directionalShadowMap.length = x, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = y, i.spotShadowMap.length = y, i.directionalShadowMatrix.length = x, i.pointShadowMatrix.length = b, i.spotLightMatrix.length = y + I - M, i.spotLightMap.length = I, i.numSpotLightShadowsWithMaps = M, i.numLightProbes = R, D.directionalLength = f, D.pointLength = p, D.spotLength = m, D.rectAreaLength = g, D.hemiLength = A, D.numDirectionalShadows = x, D.numPointShadows = b, D.numSpotShadows = y, D.numSpotMaps = I, D.numLightProbes = R, i.version = Ix++);
        }
        function c(l, h) {
          let d = 0, u = 0, f = 0, p = 0, m = 0;
          const g = h.matrixWorldInverse;
          for (let A = 0, x = l.length; A < x; A++) {
            const b = l[A];
            if (b.isDirectionalLight) {
              const y = i.directional[d];
              y.direction.setFromMatrixPosition(b.matrixWorld), n.setFromMatrixPosition(b.target.matrixWorld), y.direction.sub(n), y.direction.transformDirection(g), d++;
            } else if (b.isSpotLight) {
              const y = i.spot[f];
              y.position.setFromMatrixPosition(b.matrixWorld), y.position.applyMatrix4(g), y.direction.setFromMatrixPosition(b.matrixWorld), n.setFromMatrixPosition(b.target.matrixWorld), y.direction.sub(n), y.direction.transformDirection(g), f++;
            } else if (b.isRectAreaLight) {
              const y = i.rectArea[p];
              y.position.setFromMatrixPosition(b.matrixWorld), y.position.applyMatrix4(g), a.identity(), r.copy(b.matrixWorld), r.premultiply(g), a.extractRotation(r), y.halfWidth.set(b.width * 0.5, 0, 0), y.halfHeight.set(0, b.height * 0.5, 0), y.halfWidth.applyMatrix4(a), y.halfHeight.applyMatrix4(a), p++;
            } else if (b.isPointLight) {
              const y = i.point[u];
              y.position.setFromMatrixPosition(b.matrixWorld), y.position.applyMatrix4(g), u++;
            } else if (b.isHemisphereLight) {
              const y = i.hemi[m];
              y.direction.setFromMatrixPosition(b.matrixWorld), y.direction.transformDirection(g), m++;
            }
          }
        }
        return {
          setup: o,
          setupView: c,
          state: i
        };
      }
      function qu(s) {
        const e = new Tx(s), t = [], i = [];
        function n(h) {
          l.camera = h, t.length = 0, i.length = 0;
        }
        function r(h) {
          t.push(h);
        }
        function a(h) {
          i.push(h);
        }
        function o() {
          e.setup(t);
        }
        function c(h) {
          e.setupView(t, h);
        }
        const l = {
          lightsArray: t,
          shadowsArray: i,
          camera: null,
          lights: e,
          transmissionRenderTarget: {}
        };
        return {
          init: n,
          state: l,
          setupLights: o,
          setupLightsView: c,
          pushLight: r,
          pushShadow: a
        };
      }
      function Rx(s) {
        let e = /* @__PURE__ */ new WeakMap();
        function t(n, r = 0) {
          const a = e.get(n);
          let o;
          return a === void 0 ? (o = new qu(s), e.set(n, [
            o
          ])) : r >= a.length ? (o = new qu(s), a.push(o)) : o = a[r], o;
        }
        function i() {
          e = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: t,
          dispose: i
        };
      }
      const Bx = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Dx = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function Px(s, e, t) {
        let i = new Th();
        const n = new oe(), r = new oe(), a = new je(), o = new vm({
          depthPacking: Ng
        }), c = new Sm(), l = {}, h = t.maxTextureSize, d = {
          [Sn]: _i,
          [_i]: Sn,
          [Yi]: Yi
        }, u = new ki({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new oe()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: Bx,
          fragmentShader: Dx
        }), f = u.clone();
        f.defines.HORIZONTAL_PASS = 1;
        const p = new Qt();
        p.setAttribute("position", new ni(new Float32Array([
          -1,
          -1,
          0.5,
          3,
          -1,
          0.5,
          -1,
          3,
          0.5
        ]), 3));
        const m = new yt(p, u), g = this;
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = Nf;
        let A = this.type;
        this.render = function(M, R, D) {
          if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || M.length === 0) return;
          const S = s.getRenderTarget(), E = s.getActiveCubeFace(), P = s.getActiveMipmapLevel(), j = s.state;
          j.setBlending(zn), j.buffers.color.setClear(1, 1, 1, 1), j.buffers.depth.setTest(true), j.setScissorTest(false);
          const H = A !== _n && this.type === _n, Y = A === _n && this.type !== _n;
          for (let te = 0, q = M.length; te < q; te++) {
            const Z = M[te], V = Z.shadow;
            if (V === void 0) {
              console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
              continue;
            }
            if (V.autoUpdate === false && V.needsUpdate === false) continue;
            n.copy(V.mapSize);
            const re = V.getFrameExtents();
            if (n.multiply(re), r.copy(V.mapSize), (n.x > h || n.y > h) && (n.x > h && (r.x = Math.floor(h / re.x), n.x = r.x * re.x, V.mapSize.x = r.x), n.y > h && (r.y = Math.floor(h / re.y), n.y = r.y * re.y, V.mapSize.y = r.y)), V.map === null || H === true || Y === true) {
              const ve = this.type !== _n ? {
                minFilter: pi,
                magFilter: pi
              } : {};
              V.map !== null && V.map.dispose(), V.map = new Cn(n.x, n.y, ve), V.map.texture.name = Z.name + ".shadowMap", V.camera.updateProjectionMatrix();
            }
            s.setRenderTarget(V.map), s.clear();
            const he = V.getViewportCount();
            for (let ve = 0; ve < he; ve++) {
              const Pe = V.getViewport(ve);
              a.set(r.x * Pe.x, r.y * Pe.y, r.x * Pe.z, r.y * Pe.w), j.viewport(a), V.updateMatrices(Z, ve), i = V.getFrustum(), y(R, D, V.camera, Z, this.type);
            }
            V.isPointLightShadow !== true && this.type === _n && x(V, D), V.needsUpdate = false;
          }
          A = this.type, g.needsUpdate = false, s.setRenderTarget(S, E, P);
        };
        function x(M, R) {
          const D = e.update(m);
          u.defines.VSM_SAMPLES !== M.blurSamples && (u.defines.VSM_SAMPLES = M.blurSamples, f.defines.VSM_SAMPLES = M.blurSamples, u.needsUpdate = true, f.needsUpdate = true), M.mapPass === null && (M.mapPass = new Cn(n.x, n.y)), u.uniforms.shadow_pass.value = M.map.texture, u.uniforms.resolution.value = M.mapSize, u.uniforms.radius.value = M.radius, s.setRenderTarget(M.mapPass), s.clear(), s.renderBufferDirect(R, null, D, u, m, null), f.uniforms.shadow_pass.value = M.mapPass.texture, f.uniforms.resolution.value = M.mapSize, f.uniforms.radius.value = M.radius, s.setRenderTarget(M.map), s.clear(), s.renderBufferDirect(R, null, D, f, m, null);
        }
        function b(M, R, D, S) {
          let E = null;
          const P = D.isPointLight === true ? M.customDistanceMaterial : M.customDepthMaterial;
          if (P !== void 0) E = P;
          else if (E = D.isPointLight === true ? c : o, s.localClippingEnabled && R.clipShadows === true && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
            const j = E.uuid, H = R.uuid;
            let Y = l[j];
            Y === void 0 && (Y = {}, l[j] = Y);
            let te = Y[H];
            te === void 0 && (te = E.clone(), Y[H] = te, R.addEventListener("dispose", I)), E = te;
          }
          if (E.visible = R.visible, E.wireframe = R.wireframe, S === _n ? E.side = R.shadowSide !== null ? R.shadowSide : R.side : E.side = R.shadowSide !== null ? R.shadowSide : d[R.side], E.alphaMap = R.alphaMap, E.alphaTest = R.alphaTest, E.map = R.map, E.clipShadows = R.clipShadows, E.clippingPlanes = R.clippingPlanes, E.clipIntersection = R.clipIntersection, E.displacementMap = R.displacementMap, E.displacementScale = R.displacementScale, E.displacementBias = R.displacementBias, E.wireframeLinewidth = R.wireframeLinewidth, E.linewidth = R.linewidth, D.isPointLight === true && E.isMeshDistanceMaterial === true) {
            const j = s.properties.get(E);
            j.light = D;
          }
          return E;
        }
        function y(M, R, D, S, E) {
          if (M.visible === false) return;
          if (M.layers.test(R.layers) && (M.isMesh || M.isLine || M.isPoints) && (M.castShadow || M.receiveShadow && E === _n) && (!M.frustumCulled || i.intersectsObject(M))) {
            M.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, M.matrixWorld);
            const H = e.update(M), Y = M.material;
            if (Array.isArray(Y)) {
              const te = H.groups;
              for (let q = 0, Z = te.length; q < Z; q++) {
                const V = te[q], re = Y[V.materialIndex];
                if (re && re.visible) {
                  const he = b(M, re, S, E);
                  M.onBeforeShadow(s, M, R, D, H, he, V), s.renderBufferDirect(D, null, H, he, M, V), M.onAfterShadow(s, M, R, D, H, he, V);
                }
              }
            } else if (Y.visible) {
              const te = b(M, Y, S, E);
              M.onBeforeShadow(s, M, R, D, H, te, null), s.renderBufferDirect(D, null, H, te, M, null), M.onAfterShadow(s, M, R, D, H, te, null);
            }
          }
          const j = M.children;
          for (let H = 0, Y = j.length; H < Y; H++) y(j[H], R, D, S, E);
        }
        function I(M) {
          M.target.removeEventListener("dispose", I);
          for (const D in l) {
            const S = l[D], E = M.target.uuid;
            E in S && (S[E].dispose(), delete S[E]);
          }
        }
      }
      const Lx = {
        [fl]: pl,
        [Al]: ml,
        [gl]: wl,
        [Zr]: _l,
        [pl]: fl,
        [ml]: Al,
        [wl]: gl,
        [_l]: Zr
      };
      function Fx(s, e) {
        function t() {
          let N = false;
          const pe = new je();
          let X = null;
          const ee = new je(0, 0, 0, 0);
          return {
            setMask: function(_e) {
              X !== _e && !N && (s.colorMask(_e, _e, _e, _e), X = _e);
            },
            setLocked: function(_e) {
              N = _e;
            },
            setClear: function(_e, Ae, We, Bt, ri) {
              ri === true && (_e *= Bt, Ae *= Bt, We *= Bt), pe.set(_e, Ae, We, Bt), ee.equals(pe) === false && (s.clearColor(_e, Ae, We, Bt), ee.copy(pe));
            },
            reset: function() {
              N = false, X = null, ee.set(-1, 0, 0, 0);
            }
          };
        }
        function i() {
          let N = false, pe = false, X = null, ee = null, _e = null;
          return {
            setReversed: function(Ae) {
              if (pe !== Ae) {
                const We = e.get("EXT_clip_control");
                Ae ? We.clipControlEXT(We.LOWER_LEFT_EXT, We.ZERO_TO_ONE_EXT) : We.clipControlEXT(We.LOWER_LEFT_EXT, We.NEGATIVE_ONE_TO_ONE_EXT), pe = Ae;
                const Bt = _e;
                _e = null, this.setClear(Bt);
              }
            },
            getReversed: function() {
              return pe;
            },
            setTest: function(Ae) {
              Ae ? le(s.DEPTH_TEST) : Te(s.DEPTH_TEST);
            },
            setMask: function(Ae) {
              X !== Ae && !N && (s.depthMask(Ae), X = Ae);
            },
            setFunc: function(Ae) {
              if (pe && (Ae = Lx[Ae]), ee !== Ae) {
                switch (Ae) {
                  case fl:
                    s.depthFunc(s.NEVER);
                    break;
                  case pl:
                    s.depthFunc(s.ALWAYS);
                    break;
                  case Al:
                    s.depthFunc(s.LESS);
                    break;
                  case Zr:
                    s.depthFunc(s.LEQUAL);
                    break;
                  case gl:
                    s.depthFunc(s.EQUAL);
                    break;
                  case _l:
                    s.depthFunc(s.GEQUAL);
                    break;
                  case ml:
                    s.depthFunc(s.GREATER);
                    break;
                  case wl:
                    s.depthFunc(s.NOTEQUAL);
                    break;
                  default:
                    s.depthFunc(s.LEQUAL);
                }
                ee = Ae;
              }
            },
            setLocked: function(Ae) {
              N = Ae;
            },
            setClear: function(Ae) {
              _e !== Ae && (pe && (Ae = 1 - Ae), s.clearDepth(Ae), _e = Ae);
            },
            reset: function() {
              N = false, X = null, ee = null, _e = null, pe = false;
            }
          };
        }
        function n() {
          let N = false, pe = null, X = null, ee = null, _e = null, Ae = null, We = null, Bt = null, ri = null;
          return {
            setTest: function(ut) {
              N || (ut ? le(s.STENCIL_TEST) : Te(s.STENCIL_TEST));
            },
            setMask: function(ut) {
              pe !== ut && !N && (s.stencilMask(ut), pe = ut);
            },
            setFunc: function(ut, Qi, hn) {
              (X !== ut || ee !== Qi || _e !== hn) && (s.stencilFunc(ut, Qi, hn), X = ut, ee = Qi, _e = hn);
            },
            setOp: function(ut, Qi, hn) {
              (Ae !== ut || We !== Qi || Bt !== hn) && (s.stencilOp(ut, Qi, hn), Ae = ut, We = Qi, Bt = hn);
            },
            setLocked: function(ut) {
              N = ut;
            },
            setClear: function(ut) {
              ri !== ut && (s.clearStencil(ut), ri = ut);
            },
            reset: function() {
              N = false, pe = null, X = null, ee = null, _e = null, Ae = null, We = null, Bt = null, ri = null;
            }
          };
        }
        const r = new t(), a = new i(), o = new n(), c = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new WeakMap();
        let h = {}, d = {}, u = /* @__PURE__ */ new WeakMap(), f = [], p = null, m = false, g = null, A = null, x = null, b = null, y = null, I = null, M = null, R = new ue(0, 0, 0), D = 0, S = false, E = null, P = null, j = null, H = null, Y = null;
        const te = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let q = false, Z = 0;
        const V = s.getParameter(s.VERSION);
        V.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(V)[1]), q = Z >= 1) : V.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]), q = Z >= 2);
        let re = null, he = {};
        const ve = s.getParameter(s.SCISSOR_BOX), Pe = s.getParameter(s.VIEWPORT), Ve = new je().fromArray(ve), K = new je().fromArray(Pe);
        function ae(N, pe, X, ee) {
          const _e = new Uint8Array(4), Ae = s.createTexture();
          s.bindTexture(N, Ae), s.texParameteri(N, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(N, s.TEXTURE_MAG_FILTER, s.NEAREST);
          for (let We = 0; We < X; We++) N === s.TEXTURE_3D || N === s.TEXTURE_2D_ARRAY ? s.texImage3D(pe, 0, s.RGBA, 1, 1, ee, 0, s.RGBA, s.UNSIGNED_BYTE, _e) : s.texImage2D(pe + We, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, _e);
          return Ae;
        }
        const be = {};
        be[s.TEXTURE_2D] = ae(s.TEXTURE_2D, s.TEXTURE_2D, 1), be[s.TEXTURE_CUBE_MAP] = ae(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), be[s.TEXTURE_2D_ARRAY] = ae(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), be[s.TEXTURE_3D] = ae(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), le(s.DEPTH_TEST), a.setFunc(Zr), rt(false), $e(yd), le(s.CULL_FACE), F(zn);
        function le(N) {
          h[N] !== true && (s.enable(N), h[N] = true);
        }
        function Te(N) {
          h[N] !== false && (s.disable(N), h[N] = false);
        }
        function Ze(N, pe) {
          return d[N] !== pe ? (s.bindFramebuffer(N, pe), d[N] = pe, N === s.DRAW_FRAMEBUFFER && (d[s.FRAMEBUFFER] = pe), N === s.FRAMEBUFFER && (d[s.DRAW_FRAMEBUFFER] = pe), true) : false;
        }
        function Le(N, pe) {
          let X = f, ee = false;
          if (N) {
            X = u.get(pe), X === void 0 && (X = [], u.set(pe, X));
            const _e = N.textures;
            if (X.length !== _e.length || X[0] !== s.COLOR_ATTACHMENT0) {
              for (let Ae = 0, We = _e.length; Ae < We; Ae++) X[Ae] = s.COLOR_ATTACHMENT0 + Ae;
              X.length = _e.length, ee = true;
            }
          } else X[0] !== s.BACK && (X[0] = s.BACK, ee = true);
          ee && s.drawBuffers(X);
        }
        function St(N) {
          return p !== N ? (s.useProgram(N), p = N, true) : false;
        }
        const wt = {
          [cr]: s.FUNC_ADD,
          [ag]: s.FUNC_SUBTRACT,
          [og]: s.FUNC_REVERSE_SUBTRACT
        };
        wt[cg] = s.MIN, wt[lg] = s.MAX;
        const Ke = {
          [hg]: s.ZERO,
          [dg]: s.ONE,
          [ug]: s.SRC_COLOR,
          [dl]: s.SRC_ALPHA,
          [mg]: s.SRC_ALPHA_SATURATE,
          [gg]: s.DST_COLOR,
          [pg]: s.DST_ALPHA,
          [fg]: s.ONE_MINUS_SRC_COLOR,
          [ul]: s.ONE_MINUS_SRC_ALPHA,
          [_g]: s.ONE_MINUS_DST_COLOR,
          [Ag]: s.ONE_MINUS_DST_ALPHA,
          [wg]: s.CONSTANT_COLOR,
          [bg]: s.ONE_MINUS_CONSTANT_COLOR,
          [yg]: s.CONSTANT_ALPHA,
          [xg]: s.ONE_MINUS_CONSTANT_ALPHA
        };
        function F(N, pe, X, ee, _e, Ae, We, Bt, ri, ut) {
          if (N === zn) {
            m === true && (Te(s.BLEND), m = false);
            return;
          }
          if (m === false && (le(s.BLEND), m = true), N !== sg) {
            if (N !== g || ut !== S) {
              if ((A !== cr || y !== cr) && (s.blendEquation(s.FUNC_ADD), A = cr, y = cr), ut) switch (N) {
                case Xr:
                  s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                  break;
                case xd:
                  s.blendFunc(s.ONE, s.ONE);
                  break;
                case Ed:
                  s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                  break;
                case vd:
                  s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", N);
                  break;
              }
              else switch (N) {
                case Xr:
                  s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                  break;
                case xd:
                  s.blendFunc(s.SRC_ALPHA, s.ONE);
                  break;
                case Ed:
                  s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                  break;
                case vd:
                  s.blendFunc(s.ZERO, s.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", N);
                  break;
              }
              x = null, b = null, I = null, M = null, R.set(0, 0, 0), D = 0, g = N, S = ut;
            }
            return;
          }
          _e = _e || pe, Ae = Ae || X, We = We || ee, (pe !== A || _e !== y) && (s.blendEquationSeparate(wt[pe], wt[_e]), A = pe, y = _e), (X !== x || ee !== b || Ae !== I || We !== M) && (s.blendFuncSeparate(Ke[X], Ke[ee], Ke[Ae], Ke[We]), x = X, b = ee, I = Ae, M = We), (Bt.equals(R) === false || ri !== D) && (s.blendColor(Bt.r, Bt.g, Bt.b, ri), R.copy(Bt), D = ri), g = N, S = false;
        }
        function Ci(N, pe) {
          N.side === Yi ? Te(s.CULL_FACE) : le(s.CULL_FACE);
          let X = N.side === _i;
          pe && (X = !X), rt(X), N.blending === Xr && N.transparent === false ? F(zn) : F(N.blending, N.blendEquation, N.blendSrc, N.blendDst, N.blendEquationAlpha, N.blendSrcAlpha, N.blendDstAlpha, N.blendColor, N.blendAlpha, N.premultipliedAlpha), a.setFunc(N.depthFunc), a.setTest(N.depthTest), a.setMask(N.depthWrite), r.setMask(N.colorWrite);
          const ee = N.stencilWrite;
          o.setTest(ee), ee && (o.setMask(N.stencilWriteMask), o.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask), o.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)), xt(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits), N.alphaToCoverage === true ? le(s.SAMPLE_ALPHA_TO_COVERAGE) : Te(s.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function rt(N) {
          E !== N && (N ? s.frontFace(s.CW) : s.frontFace(s.CCW), E = N);
        }
        function $e(N) {
          N !== ng ? (le(s.CULL_FACE), N !== P && (N === yd ? s.cullFace(s.BACK) : N === rg ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Te(s.CULL_FACE), P = N;
        }
        function Ie(N) {
          N !== j && (q && s.lineWidth(N), j = N);
        }
        function xt(N, pe, X) {
          N ? (le(s.POLYGON_OFFSET_FILL), (H !== pe || Y !== X) && (s.polygonOffset(pe, X), H = pe, Y = X)) : Te(s.POLYGON_OFFSET_FILL);
        }
        function Ce(N) {
          N ? le(s.SCISSOR_TEST) : Te(s.SCISSOR_TEST);
        }
        function B(N) {
          N === void 0 && (N = s.TEXTURE0 + te - 1), re !== N && (s.activeTexture(N), re = N);
        }
        function v(N, pe, X) {
          X === void 0 && (re === null ? X = s.TEXTURE0 + te - 1 : X = re);
          let ee = he[X];
          ee === void 0 && (ee = {
            type: void 0,
            texture: void 0
          }, he[X] = ee), (ee.type !== N || ee.texture !== pe) && (re !== X && (s.activeTexture(X), re = X), s.bindTexture(N, pe || be[N]), ee.type = N, ee.texture = pe);
        }
        function z() {
          const N = he[re];
          N !== void 0 && N.type !== void 0 && (s.bindTexture(N.type, null), N.type = void 0, N.texture = void 0);
        }
        function $() {
          try {
            s.compressedTexImage2D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function ie() {
          try {
            s.compressedTexImage3D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function J() {
          try {
            s.texSubImage2D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function Se() {
          try {
            s.texSubImage3D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function fe() {
          try {
            s.compressedTexSubImage2D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function we() {
          try {
            s.compressedTexSubImage3D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function st() {
          try {
            s.texStorage2D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function se() {
          try {
            s.texStorage3D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function ye() {
          try {
            s.texImage2D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function Fe() {
          try {
            s.texImage3D(...arguments);
          } catch (N) {
            console.error("THREE.WebGLState:", N);
          }
        }
        function Ue(N) {
          Ve.equals(N) === false && (s.scissor(N.x, N.y, N.z, N.w), Ve.copy(N));
        }
        function xe(N) {
          K.equals(N) === false && (s.viewport(N.x, N.y, N.z, N.w), K.copy(N));
        }
        function et(N, pe) {
          let X = l.get(pe);
          X === void 0 && (X = /* @__PURE__ */ new WeakMap(), l.set(pe, X));
          let ee = X.get(N);
          ee === void 0 && (ee = s.getUniformBlockIndex(pe, N.name), X.set(N, ee));
        }
        function qe(N, pe) {
          const ee = l.get(pe).get(N);
          c.get(pe) !== ee && (s.uniformBlockBinding(pe, ee, N.__bindingPointIndex), c.set(pe, ee));
        }
        function bt() {
          s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(true, true, true, true), s.clearColor(0, 0, 0, 0), s.depthMask(true), s.depthFunc(s.LESS), a.setReversed(false), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), h = {}, re = null, he = {}, d = {}, u = /* @__PURE__ */ new WeakMap(), f = [], p = null, m = false, g = null, A = null, x = null, b = null, y = null, I = null, M = null, R = new ue(0, 0, 0), D = 0, S = false, E = null, P = null, j = null, H = null, Y = null, Ve.set(0, 0, s.canvas.width, s.canvas.height), K.set(0, 0, s.canvas.width, s.canvas.height), r.reset(), a.reset(), o.reset();
        }
        return {
          buffers: {
            color: r,
            depth: a,
            stencil: o
          },
          enable: le,
          disable: Te,
          bindFramebuffer: Ze,
          drawBuffers: Le,
          useProgram: St,
          setBlending: F,
          setMaterial: Ci,
          setFlipSided: rt,
          setCullFace: $e,
          setLineWidth: Ie,
          setPolygonOffset: xt,
          setScissorTest: Ce,
          activeTexture: B,
          bindTexture: v,
          unbindTexture: z,
          compressedTexImage2D: $,
          compressedTexImage3D: ie,
          texImage2D: ye,
          texImage3D: Fe,
          updateUBOMapping: et,
          uniformBlockBinding: qe,
          texStorage2D: st,
          texStorage3D: se,
          texSubImage2D: J,
          texSubImage3D: Se,
          compressedTexSubImage2D: fe,
          compressedTexSubImage3D: we,
          scissor: Ue,
          viewport: xe,
          reset: bt
        };
      }
      function kx(s, e, t, i, n, r, a) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), l = new oe(), h = /* @__PURE__ */ new WeakMap();
        let d;
        const u = /* @__PURE__ */ new WeakMap();
        let f = false;
        try {
          f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {
        }
        function p(B, v) {
          return f ? new OffscreenCanvas(B, v) : js("canvas");
        }
        function m(B, v, z) {
          let $ = 1;
          const ie = Ce(B);
          if ((ie.width > z || ie.height > z) && ($ = z / Math.max(ie.width, ie.height)), $ < 1) if (typeof HTMLImageElement < "u" && B instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && B instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && B instanceof ImageBitmap || typeof VideoFrame < "u" && B instanceof VideoFrame) {
            const J = Math.floor($ * ie.width), Se = Math.floor($ * ie.height);
            d === void 0 && (d = p(J, Se));
            const fe = v ? p(J, Se) : d;
            return fe.width = J, fe.height = Se, fe.getContext("2d").drawImage(B, 0, 0, J, Se), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ie.width + "x" + ie.height + ") to (" + J + "x" + Se + ")."), fe;
          } else return "data" in B && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ie.width + "x" + ie.height + ")."), B;
          return B;
        }
        function g(B) {
          return B.generateMipmaps;
        }
        function A(B) {
          s.generateMipmap(B);
        }
        function x(B) {
          return B.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : B.isWebGL3DRenderTarget ? s.TEXTURE_3D : B.isWebGLArrayRenderTarget || B.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
        }
        function b(B, v, z, $, ie = false) {
          if (B !== null) {
            if (s[B] !== void 0) return s[B];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + B + "'");
          }
          let J = v;
          if (v === s.RED && (z === s.FLOAT && (J = s.R32F), z === s.HALF_FLOAT && (J = s.R16F), z === s.UNSIGNED_BYTE && (J = s.R8)), v === s.RED_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.R8UI), z === s.UNSIGNED_SHORT && (J = s.R16UI), z === s.UNSIGNED_INT && (J = s.R32UI), z === s.BYTE && (J = s.R8I), z === s.SHORT && (J = s.R16I), z === s.INT && (J = s.R32I)), v === s.RG && (z === s.FLOAT && (J = s.RG32F), z === s.HALF_FLOAT && (J = s.RG16F), z === s.UNSIGNED_BYTE && (J = s.RG8)), v === s.RG_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.RG8UI), z === s.UNSIGNED_SHORT && (J = s.RG16UI), z === s.UNSIGNED_INT && (J = s.RG32UI), z === s.BYTE && (J = s.RG8I), z === s.SHORT && (J = s.RG16I), z === s.INT && (J = s.RG32I)), v === s.RGB_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.RGB8UI), z === s.UNSIGNED_SHORT && (J = s.RGB16UI), z === s.UNSIGNED_INT && (J = s.RGB32UI), z === s.BYTE && (J = s.RGB8I), z === s.SHORT && (J = s.RGB16I), z === s.INT && (J = s.RGB32I)), v === s.RGBA_INTEGER && (z === s.UNSIGNED_BYTE && (J = s.RGBA8UI), z === s.UNSIGNED_SHORT && (J = s.RGBA16UI), z === s.UNSIGNED_INT && (J = s.RGBA32UI), z === s.BYTE && (J = s.RGBA8I), z === s.SHORT && (J = s.RGBA16I), z === s.INT && (J = s.RGBA32I)), v === s.RGB && z === s.UNSIGNED_INT_5_9_9_9_REV && (J = s.RGB9_E5), v === s.RGBA) {
            const Se = ie ? wo : ze.getTransfer($);
            z === s.FLOAT && (J = s.RGBA32F), z === s.HALF_FLOAT && (J = s.RGBA16F), z === s.UNSIGNED_BYTE && (J = Se === pt ? s.SRGB8_ALPHA8 : s.RGBA8), z === s.UNSIGNED_SHORT_4_4_4_4 && (J = s.RGBA4), z === s.UNSIGNED_SHORT_5_5_5_1 && (J = s.RGB5_A1);
          }
          return (J === s.R16F || J === s.R32F || J === s.RG16F || J === s.RG32F || J === s.RGBA16F || J === s.RGBA32F) && e.get("EXT_color_buffer_float"), J;
        }
        function y(B, v) {
          let z;
          return B ? v === null || v === Ar || v === Qs ? z = s.DEPTH24_STENCIL8 : v === ii ? z = s.DEPTH32F_STENCIL8 : v === Ns && (z = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : v === null || v === Ar || v === Qs ? z = s.DEPTH_COMPONENT24 : v === ii ? z = s.DEPTH_COMPONENT32F : v === Ns && (z = s.DEPTH_COMPONENT16), z;
        }
        function I(B, v) {
          return g(B) === true || B.isFramebufferTexture && B.minFilter !== pi && B.minFilter !== Rt ? Math.log2(Math.max(v.width, v.height)) + 1 : B.mipmaps !== void 0 && B.mipmaps.length > 0 ? B.mipmaps.length : B.isCompressedTexture && Array.isArray(B.image) ? v.mipmaps.length : 1;
        }
        function M(B) {
          const v = B.target;
          v.removeEventListener("dispose", M), D(v), v.isVideoTexture && h.delete(v);
        }
        function R(B) {
          const v = B.target;
          v.removeEventListener("dispose", R), E(v);
        }
        function D(B) {
          const v = i.get(B);
          if (v.__webglInit === void 0) return;
          const z = B.source, $ = u.get(z);
          if ($) {
            const ie = $[v.__cacheKey];
            ie.usedTimes--, ie.usedTimes === 0 && S(B), Object.keys($).length === 0 && u.delete(z);
          }
          i.remove(B);
        }
        function S(B) {
          const v = i.get(B);
          s.deleteTexture(v.__webglTexture);
          const z = B.source, $ = u.get(z);
          delete $[v.__cacheKey], a.memory.textures--;
        }
        function E(B) {
          const v = i.get(B);
          if (B.depthTexture && (B.depthTexture.dispose(), i.remove(B.depthTexture)), B.isWebGLCubeRenderTarget) for (let $ = 0; $ < 6; $++) {
            if (Array.isArray(v.__webglFramebuffer[$])) for (let ie = 0; ie < v.__webglFramebuffer[$].length; ie++) s.deleteFramebuffer(v.__webglFramebuffer[$][ie]);
            else s.deleteFramebuffer(v.__webglFramebuffer[$]);
            v.__webglDepthbuffer && s.deleteRenderbuffer(v.__webglDepthbuffer[$]);
          }
          else {
            if (Array.isArray(v.__webglFramebuffer)) for (let $ = 0; $ < v.__webglFramebuffer.length; $++) s.deleteFramebuffer(v.__webglFramebuffer[$]);
            else s.deleteFramebuffer(v.__webglFramebuffer);
            if (v.__webglDepthbuffer && s.deleteRenderbuffer(v.__webglDepthbuffer), v.__webglMultisampledFramebuffer && s.deleteFramebuffer(v.__webglMultisampledFramebuffer), v.__webglColorRenderbuffer) for (let $ = 0; $ < v.__webglColorRenderbuffer.length; $++) v.__webglColorRenderbuffer[$] && s.deleteRenderbuffer(v.__webglColorRenderbuffer[$]);
            v.__webglDepthRenderbuffer && s.deleteRenderbuffer(v.__webglDepthRenderbuffer);
          }
          const z = B.textures;
          for (let $ = 0, ie = z.length; $ < ie; $++) {
            const J = i.get(z[$]);
            J.__webglTexture && (s.deleteTexture(J.__webglTexture), a.memory.textures--), i.remove(z[$]);
          }
          i.remove(B);
        }
        let P = 0;
        function j() {
          P = 0;
        }
        function H() {
          const B = P;
          return B >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + B + " texture units while this GPU supports only " + n.maxTextures), P += 1, B;
        }
        function Y(B) {
          const v = [];
          return v.push(B.wrapS), v.push(B.wrapT), v.push(B.wrapR || 0), v.push(B.magFilter), v.push(B.minFilter), v.push(B.anisotropy), v.push(B.internalFormat), v.push(B.format), v.push(B.type), v.push(B.generateMipmaps), v.push(B.premultiplyAlpha), v.push(B.flipY), v.push(B.unpackAlignment), v.push(B.colorSpace), v.join();
        }
        function te(B, v) {
          const z = i.get(B);
          if (B.isVideoTexture && Ie(B), B.isRenderTargetTexture === false && B.version > 0 && z.__version !== B.version) {
            const $ = B.image;
            if ($ === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if ($.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
              K(z, B, v);
              return;
            }
          }
          t.bindTexture(s.TEXTURE_2D, z.__webglTexture, s.TEXTURE0 + v);
        }
        function q(B, v) {
          const z = i.get(B);
          if (B.version > 0 && z.__version !== B.version) {
            K(z, B, v);
            return;
          }
          t.bindTexture(s.TEXTURE_2D_ARRAY, z.__webglTexture, s.TEXTURE0 + v);
        }
        function Z(B, v) {
          const z = i.get(B);
          if (B.version > 0 && z.__version !== B.version) {
            K(z, B, v);
            return;
          }
          t.bindTexture(s.TEXTURE_3D, z.__webglTexture, s.TEXTURE0 + v);
        }
        function V(B, v) {
          const z = i.get(B);
          if (B.version > 0 && z.__version !== B.version) {
            ae(z, B, v);
            return;
          }
          t.bindTexture(s.TEXTURE_CUBE_MAP, z.__webglTexture, s.TEXTURE0 + v);
        }
        const re = {
          [mi]: s.REPEAT,
          [fi]: s.CLAMP_TO_EDGE,
          [ho]: s.MIRRORED_REPEAT
        }, he = {
          [pi]: s.NEAREST,
          [zf]: s.NEAREST_MIPMAP_NEAREST,
          [Ss]: s.NEAREST_MIPMAP_LINEAR,
          [Rt]: s.LINEAR,
          [io]: s.LINEAR_MIPMAP_NEAREST,
          [Ji]: s.LINEAR_MIPMAP_LINEAR
        }, ve = {
          [Og]: s.NEVER,
          [jg]: s.ALWAYS,
          [zg]: s.LESS,
          [Jf]: s.LEQUAL,
          [Gg]: s.EQUAL,
          [Wg]: s.GEQUAL,
          [Hg]: s.GREATER,
          [Vg]: s.NOTEQUAL
        };
        function Pe(B, v) {
          if (v.type === ii && e.has("OES_texture_float_linear") === false && (v.magFilter === Rt || v.magFilter === io || v.magFilter === Ss || v.magFilter === Ji || v.minFilter === Rt || v.minFilter === io || v.minFilter === Ss || v.minFilter === Ji) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(B, s.TEXTURE_WRAP_S, re[v.wrapS]), s.texParameteri(B, s.TEXTURE_WRAP_T, re[v.wrapT]), (B === s.TEXTURE_3D || B === s.TEXTURE_2D_ARRAY) && s.texParameteri(B, s.TEXTURE_WRAP_R, re[v.wrapR]), s.texParameteri(B, s.TEXTURE_MAG_FILTER, he[v.magFilter]), s.texParameteri(B, s.TEXTURE_MIN_FILTER, he[v.minFilter]), v.compareFunction && (s.texParameteri(B, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(B, s.TEXTURE_COMPARE_FUNC, ve[v.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
            if (v.magFilter === pi || v.minFilter !== Ss && v.minFilter !== Ji || v.type === ii && e.has("OES_texture_float_linear") === false) return;
            if (v.anisotropy > 1 || i.get(v).__currentAnisotropy) {
              const z = e.get("EXT_texture_filter_anisotropic");
              s.texParameterf(B, z.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(v.anisotropy, n.getMaxAnisotropy())), i.get(v).__currentAnisotropy = v.anisotropy;
            }
          }
        }
        function Ve(B, v) {
          let z = false;
          B.__webglInit === void 0 && (B.__webglInit = true, v.addEventListener("dispose", M));
          const $ = v.source;
          let ie = u.get($);
          ie === void 0 && (ie = {}, u.set($, ie));
          const J = Y(v);
          if (J !== B.__cacheKey) {
            ie[J] === void 0 && (ie[J] = {
              texture: s.createTexture(),
              usedTimes: 0
            }, a.memory.textures++, z = true), ie[J].usedTimes++;
            const Se = ie[B.__cacheKey];
            Se !== void 0 && (ie[B.__cacheKey].usedTimes--, Se.usedTimes === 0 && S(v)), B.__cacheKey = J, B.__webglTexture = ie[J].texture;
          }
          return z;
        }
        function K(B, v, z) {
          let $ = s.TEXTURE_2D;
          (v.isDataArrayTexture || v.isCompressedArrayTexture) && ($ = s.TEXTURE_2D_ARRAY), v.isData3DTexture && ($ = s.TEXTURE_3D);
          const ie = Ve(B, v), J = v.source;
          t.bindTexture($, B.__webglTexture, s.TEXTURE0 + z);
          const Se = i.get(J);
          if (J.version !== Se.__version || ie === true) {
            t.activeTexture(s.TEXTURE0 + z);
            const fe = ze.getPrimaries(ze.workingColorSpace), we = v.colorSpace === an ? null : ze.getPrimaries(v.colorSpace), st = v.colorSpace === an || fe === we ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, v.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, v.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, st);
            let se = m(v.image, false, n.maxTextureSize);
            se = xt(v, se);
            const ye = r.convert(v.format, v.colorSpace), Fe = r.convert(v.type);
            let Ue = b(v.internalFormat, ye, Fe, v.colorSpace, v.isVideoTexture);
            Pe($, v);
            let xe;
            const et = v.mipmaps, qe = v.isVideoTexture !== true, bt = Se.__version === void 0 || ie === true, N = J.dataReady, pe = I(v, se);
            if (v.isDepthTexture) Ue = y(v.format === zs, v.type), bt && (qe ? t.texStorage2D(s.TEXTURE_2D, 1, Ue, se.width, se.height) : t.texImage2D(s.TEXTURE_2D, 0, Ue, se.width, se.height, 0, ye, Fe, null));
            else if (v.isDataTexture) if (et.length > 0) {
              qe && bt && t.texStorage2D(s.TEXTURE_2D, pe, Ue, et[0].width, et[0].height);
              for (let X = 0, ee = et.length; X < ee; X++) xe = et[X], qe ? N && t.texSubImage2D(s.TEXTURE_2D, X, 0, 0, xe.width, xe.height, ye, Fe, xe.data) : t.texImage2D(s.TEXTURE_2D, X, Ue, xe.width, xe.height, 0, ye, Fe, xe.data);
              v.generateMipmaps = false;
            } else qe ? (bt && t.texStorage2D(s.TEXTURE_2D, pe, Ue, se.width, se.height), N && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, se.width, se.height, ye, Fe, se.data)) : t.texImage2D(s.TEXTURE_2D, 0, Ue, se.width, se.height, 0, ye, Fe, se.data);
            else if (v.isCompressedTexture) if (v.isCompressedArrayTexture) {
              qe && bt && t.texStorage3D(s.TEXTURE_2D_ARRAY, pe, Ue, et[0].width, et[0].height, se.depth);
              for (let X = 0, ee = et.length; X < ee; X++) if (xe = et[X], v.format !== Wt) if (ye !== null) if (qe) {
                if (N) if (v.layerUpdates.size > 0) {
                  const _e = Eu(xe.width, xe.height, v.format, v.type);
                  for (const Ae of v.layerUpdates) {
                    const We = xe.data.subarray(Ae * _e / xe.data.BYTES_PER_ELEMENT, (Ae + 1) * _e / xe.data.BYTES_PER_ELEMENT);
                    t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, X, 0, 0, Ae, xe.width, xe.height, 1, ye, We);
                  }
                  v.clearLayerUpdates();
                } else t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, X, 0, 0, 0, xe.width, xe.height, se.depth, ye, xe.data);
              } else t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, X, Ue, xe.width, xe.height, se.depth, 0, xe.data, 0, 0);
              else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              else qe ? N && t.texSubImage3D(s.TEXTURE_2D_ARRAY, X, 0, 0, 0, xe.width, xe.height, se.depth, ye, Fe, xe.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, X, Ue, xe.width, xe.height, se.depth, 0, ye, Fe, xe.data);
            } else {
              qe && bt && t.texStorage2D(s.TEXTURE_2D, pe, Ue, et[0].width, et[0].height);
              for (let X = 0, ee = et.length; X < ee; X++) xe = et[X], v.format !== Wt ? ye !== null ? qe ? N && t.compressedTexSubImage2D(s.TEXTURE_2D, X, 0, 0, xe.width, xe.height, ye, xe.data) : t.compressedTexImage2D(s.TEXTURE_2D, X, Ue, xe.width, xe.height, 0, xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qe ? N && t.texSubImage2D(s.TEXTURE_2D, X, 0, 0, xe.width, xe.height, ye, Fe, xe.data) : t.texImage2D(s.TEXTURE_2D, X, Ue, xe.width, xe.height, 0, ye, Fe, xe.data);
            }
            else if (v.isDataArrayTexture) if (qe) {
              if (bt && t.texStorage3D(s.TEXTURE_2D_ARRAY, pe, Ue, se.width, se.height, se.depth), N) if (v.layerUpdates.size > 0) {
                const X = Eu(se.width, se.height, v.format, v.type);
                for (const ee of v.layerUpdates) {
                  const _e = se.data.subarray(ee * X / se.data.BYTES_PER_ELEMENT, (ee + 1) * X / se.data.BYTES_PER_ELEMENT);
                  t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, ee, se.width, se.height, 1, ye, Fe, _e);
                }
                v.clearLayerUpdates();
              } else t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, se.width, se.height, se.depth, ye, Fe, se.data);
            } else t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Ue, se.width, se.height, se.depth, 0, ye, Fe, se.data);
            else if (v.isData3DTexture) qe ? (bt && t.texStorage3D(s.TEXTURE_3D, pe, Ue, se.width, se.height, se.depth), N && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, se.width, se.height, se.depth, ye, Fe, se.data)) : t.texImage3D(s.TEXTURE_3D, 0, Ue, se.width, se.height, se.depth, 0, ye, Fe, se.data);
            else if (v.isFramebufferTexture) {
              if (bt) if (qe) t.texStorage2D(s.TEXTURE_2D, pe, Ue, se.width, se.height);
              else {
                let X = se.width, ee = se.height;
                for (let _e = 0; _e < pe; _e++) t.texImage2D(s.TEXTURE_2D, _e, Ue, X, ee, 0, ye, Fe, null), X >>= 1, ee >>= 1;
              }
            } else if (et.length > 0) {
              if (qe && bt) {
                const X = Ce(et[0]);
                t.texStorage2D(s.TEXTURE_2D, pe, Ue, X.width, X.height);
              }
              for (let X = 0, ee = et.length; X < ee; X++) xe = et[X], qe ? N && t.texSubImage2D(s.TEXTURE_2D, X, 0, 0, ye, Fe, xe) : t.texImage2D(s.TEXTURE_2D, X, Ue, ye, Fe, xe);
              v.generateMipmaps = false;
            } else if (qe) {
              if (bt) {
                const X = Ce(se);
                t.texStorage2D(s.TEXTURE_2D, pe, Ue, X.width, X.height);
              }
              N && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ye, Fe, se);
            } else t.texImage2D(s.TEXTURE_2D, 0, Ue, ye, Fe, se);
            g(v) && A($), Se.__version = J.version, v.onUpdate && v.onUpdate(v);
          }
          B.__version = v.version;
        }
        function ae(B, v, z) {
          if (v.image.length !== 6) return;
          const $ = Ve(B, v), ie = v.source;
          t.bindTexture(s.TEXTURE_CUBE_MAP, B.__webglTexture, s.TEXTURE0 + z);
          const J = i.get(ie);
          if (ie.version !== J.__version || $ === true) {
            t.activeTexture(s.TEXTURE0 + z);
            const Se = ze.getPrimaries(ze.workingColorSpace), fe = v.colorSpace === an ? null : ze.getPrimaries(v.colorSpace), we = v.colorSpace === an || Se === fe ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, v.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, v.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, v.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, we);
            const st = v.isCompressedTexture || v.image[0].isCompressedTexture, se = v.image[0] && v.image[0].isDataTexture, ye = [];
            for (let ee = 0; ee < 6; ee++) !st && !se ? ye[ee] = m(v.image[ee], true, n.maxCubemapSize) : ye[ee] = se ? v.image[ee].image : v.image[ee], ye[ee] = xt(v, ye[ee]);
            const Fe = ye[0], Ue = r.convert(v.format, v.colorSpace), xe = r.convert(v.type), et = b(v.internalFormat, Ue, xe, v.colorSpace), qe = v.isVideoTexture !== true, bt = J.__version === void 0 || $ === true, N = ie.dataReady;
            let pe = I(v, Fe);
            Pe(s.TEXTURE_CUBE_MAP, v);
            let X;
            if (st) {
              qe && bt && t.texStorage2D(s.TEXTURE_CUBE_MAP, pe, et, Fe.width, Fe.height);
              for (let ee = 0; ee < 6; ee++) {
                X = ye[ee].mipmaps;
                for (let _e = 0; _e < X.length; _e++) {
                  const Ae = X[_e];
                  v.format !== Wt ? Ue !== null ? qe ? N && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, 0, 0, Ae.width, Ae.height, Ue, Ae.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, et, Ae.width, Ae.height, 0, Ae.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : qe ? N && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, 0, 0, Ae.width, Ae.height, Ue, xe, Ae.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e, et, Ae.width, Ae.height, 0, Ue, xe, Ae.data);
                }
              }
            } else {
              if (X = v.mipmaps, qe && bt) {
                X.length > 0 && pe++;
                const ee = Ce(ye[0]);
                t.texStorage2D(s.TEXTURE_CUBE_MAP, pe, et, ee.width, ee.height);
              }
              for (let ee = 0; ee < 6; ee++) if (se) {
                qe ? N && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, 0, 0, ye[ee].width, ye[ee].height, Ue, xe, ye[ee].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, et, ye[ee].width, ye[ee].height, 0, Ue, xe, ye[ee].data);
                for (let _e = 0; _e < X.length; _e++) {
                  const We = X[_e].image[ee].image;
                  qe ? N && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, 0, 0, We.width, We.height, Ue, xe, We.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, et, We.width, We.height, 0, Ue, xe, We.data);
                }
              } else {
                qe ? N && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, 0, 0, Ue, xe, ye[ee]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, 0, et, Ue, xe, ye[ee]);
                for (let _e = 0; _e < X.length; _e++) {
                  const Ae = X[_e];
                  qe ? N && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, 0, 0, Ue, xe, Ae.image[ee]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + ee, _e + 1, et, Ue, xe, Ae.image[ee]);
                }
              }
            }
            g(v) && A(s.TEXTURE_CUBE_MAP), J.__version = ie.version, v.onUpdate && v.onUpdate(v);
          }
          B.__version = v.version;
        }
        function be(B, v, z, $, ie, J) {
          const Se = r.convert(z.format, z.colorSpace), fe = r.convert(z.type), we = b(z.internalFormat, Se, fe, z.colorSpace), st = i.get(v), se = i.get(z);
          if (se.__renderTarget = v, !st.__hasExternalTextures) {
            const ye = Math.max(1, v.width >> J), Fe = Math.max(1, v.height >> J);
            ie === s.TEXTURE_3D || ie === s.TEXTURE_2D_ARRAY ? t.texImage3D(ie, J, we, ye, Fe, v.depth, 0, Se, fe, null) : t.texImage2D(ie, J, we, ye, Fe, 0, Se, fe, null);
          }
          t.bindFramebuffer(s.FRAMEBUFFER, B), $e(v) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, $, ie, se.__webglTexture, 0, rt(v)) : (ie === s.TEXTURE_2D || ie >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ie <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, $, ie, se.__webglTexture, J), t.bindFramebuffer(s.FRAMEBUFFER, null);
        }
        function le(B, v, z) {
          if (s.bindRenderbuffer(s.RENDERBUFFER, B), v.depthBuffer) {
            const $ = v.depthTexture, ie = $ && $.isDepthTexture ? $.type : null, J = y(v.stencilBuffer, ie), Se = v.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, fe = rt(v);
            $e(v) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, fe, J, v.width, v.height) : z ? s.renderbufferStorageMultisample(s.RENDERBUFFER, fe, J, v.width, v.height) : s.renderbufferStorage(s.RENDERBUFFER, J, v.width, v.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, Se, s.RENDERBUFFER, B);
          } else {
            const $ = v.textures;
            for (let ie = 0; ie < $.length; ie++) {
              const J = $[ie], Se = r.convert(J.format, J.colorSpace), fe = r.convert(J.type), we = b(J.internalFormat, Se, fe, J.colorSpace), st = rt(v);
              z && $e(v) === false ? s.renderbufferStorageMultisample(s.RENDERBUFFER, st, we, v.width, v.height) : $e(v) ? o.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, st, we, v.width, v.height) : s.renderbufferStorage(s.RENDERBUFFER, we, v.width, v.height);
            }
          }
          s.bindRenderbuffer(s.RENDERBUFFER, null);
        }
        function Te(B, v) {
          if (v && v.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (t.bindFramebuffer(s.FRAMEBUFFER, B), !(v.depthTexture && v.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          const $ = i.get(v.depthTexture);
          $.__renderTarget = v, (!$.__webglTexture || v.depthTexture.image.width !== v.width || v.depthTexture.image.height !== v.height) && (v.depthTexture.image.width = v.width, v.depthTexture.image.height = v.height, v.depthTexture.needsUpdate = true), te(v.depthTexture, 0);
          const ie = $.__webglTexture, J = rt(v);
          if (v.depthTexture.format === Os) $e(v) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ie, 0, J) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ie, 0);
          else if (v.depthTexture.format === zs) $e(v) ? o.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ie, 0, J) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ie, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Ze(B) {
          const v = i.get(B), z = B.isWebGLCubeRenderTarget === true;
          if (v.__boundDepthTexture !== B.depthTexture) {
            const $ = B.depthTexture;
            if (v.__depthDisposeCallback && v.__depthDisposeCallback(), $) {
              const ie = () => {
                delete v.__boundDepthTexture, delete v.__depthDisposeCallback, $.removeEventListener("dispose", ie);
              };
              $.addEventListener("dispose", ie), v.__depthDisposeCallback = ie;
            }
            v.__boundDepthTexture = $;
          }
          if (B.depthTexture && !v.__autoAllocateDepthBuffer) {
            if (z) throw new Error("target.depthTexture not supported in Cube render targets");
            Te(v.__webglFramebuffer, B);
          } else if (z) {
            v.__webglDepthbuffer = [];
            for (let $ = 0; $ < 6; $++) if (t.bindFramebuffer(s.FRAMEBUFFER, v.__webglFramebuffer[$]), v.__webglDepthbuffer[$] === void 0) v.__webglDepthbuffer[$] = s.createRenderbuffer(), le(v.__webglDepthbuffer[$], B, false);
            else {
              const ie = B.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, J = v.__webglDepthbuffer[$];
              s.bindRenderbuffer(s.RENDERBUFFER, J), s.framebufferRenderbuffer(s.FRAMEBUFFER, ie, s.RENDERBUFFER, J);
            }
          } else if (t.bindFramebuffer(s.FRAMEBUFFER, v.__webglFramebuffer), v.__webglDepthbuffer === void 0) v.__webglDepthbuffer = s.createRenderbuffer(), le(v.__webglDepthbuffer, B, false);
          else {
            const $ = B.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ie = v.__webglDepthbuffer;
            s.bindRenderbuffer(s.RENDERBUFFER, ie), s.framebufferRenderbuffer(s.FRAMEBUFFER, $, s.RENDERBUFFER, ie);
          }
          t.bindFramebuffer(s.FRAMEBUFFER, null);
        }
        function Le(B, v, z) {
          const $ = i.get(B);
          v !== void 0 && be($.__webglFramebuffer, B, B.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), z !== void 0 && Ze(B);
        }
        function St(B) {
          const v = B.texture, z = i.get(B), $ = i.get(v);
          B.addEventListener("dispose", R);
          const ie = B.textures, J = B.isWebGLCubeRenderTarget === true, Se = ie.length > 1;
          if (Se || ($.__webglTexture === void 0 && ($.__webglTexture = s.createTexture()), $.__version = v.version, a.memory.textures++), J) {
            z.__webglFramebuffer = [];
            for (let fe = 0; fe < 6; fe++) if (v.mipmaps && v.mipmaps.length > 0) {
              z.__webglFramebuffer[fe] = [];
              for (let we = 0; we < v.mipmaps.length; we++) z.__webglFramebuffer[fe][we] = s.createFramebuffer();
            } else z.__webglFramebuffer[fe] = s.createFramebuffer();
          } else {
            if (v.mipmaps && v.mipmaps.length > 0) {
              z.__webglFramebuffer = [];
              for (let fe = 0; fe < v.mipmaps.length; fe++) z.__webglFramebuffer[fe] = s.createFramebuffer();
            } else z.__webglFramebuffer = s.createFramebuffer();
            if (Se) for (let fe = 0, we = ie.length; fe < we; fe++) {
              const st = i.get(ie[fe]);
              st.__webglTexture === void 0 && (st.__webglTexture = s.createTexture(), a.memory.textures++);
            }
            if (B.samples > 0 && $e(B) === false) {
              z.__webglMultisampledFramebuffer = s.createFramebuffer(), z.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, z.__webglMultisampledFramebuffer);
              for (let fe = 0; fe < ie.length; fe++) {
                const we = ie[fe];
                z.__webglColorRenderbuffer[fe] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, z.__webglColorRenderbuffer[fe]);
                const st = r.convert(we.format, we.colorSpace), se = r.convert(we.type), ye = b(we.internalFormat, st, se, we.colorSpace, B.isXRRenderTarget === true), Fe = rt(B);
                s.renderbufferStorageMultisample(s.RENDERBUFFER, Fe, ye, B.width, B.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + fe, s.RENDERBUFFER, z.__webglColorRenderbuffer[fe]);
              }
              s.bindRenderbuffer(s.RENDERBUFFER, null), B.depthBuffer && (z.__webglDepthRenderbuffer = s.createRenderbuffer(), le(z.__webglDepthRenderbuffer, B, true)), t.bindFramebuffer(s.FRAMEBUFFER, null);
            }
          }
          if (J) {
            t.bindTexture(s.TEXTURE_CUBE_MAP, $.__webglTexture), Pe(s.TEXTURE_CUBE_MAP, v);
            for (let fe = 0; fe < 6; fe++) if (v.mipmaps && v.mipmaps.length > 0) for (let we = 0; we < v.mipmaps.length; we++) be(z.__webglFramebuffer[fe][we], B, v, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + fe, we);
            else be(z.__webglFramebuffer[fe], B, v, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + fe, 0);
            g(v) && A(s.TEXTURE_CUBE_MAP), t.unbindTexture();
          } else if (Se) {
            for (let fe = 0, we = ie.length; fe < we; fe++) {
              const st = ie[fe], se = i.get(st);
              t.bindTexture(s.TEXTURE_2D, se.__webglTexture), Pe(s.TEXTURE_2D, st), be(z.__webglFramebuffer, B, st, s.COLOR_ATTACHMENT0 + fe, s.TEXTURE_2D, 0), g(st) && A(s.TEXTURE_2D);
            }
            t.unbindTexture();
          } else {
            let fe = s.TEXTURE_2D;
            if ((B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) && (fe = B.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), t.bindTexture(fe, $.__webglTexture), Pe(fe, v), v.mipmaps && v.mipmaps.length > 0) for (let we = 0; we < v.mipmaps.length; we++) be(z.__webglFramebuffer[we], B, v, s.COLOR_ATTACHMENT0, fe, we);
            else be(z.__webglFramebuffer, B, v, s.COLOR_ATTACHMENT0, fe, 0);
            g(v) && A(fe), t.unbindTexture();
          }
          B.depthBuffer && Ze(B);
        }
        function wt(B) {
          const v = B.textures;
          for (let z = 0, $ = v.length; z < $; z++) {
            const ie = v[z];
            if (g(ie)) {
              const J = x(B), Se = i.get(ie).__webglTexture;
              t.bindTexture(J, Se), A(J), t.unbindTexture();
            }
          }
        }
        const Ke = [], F = [];
        function Ci(B) {
          if (B.samples > 0) {
            if ($e(B) === false) {
              const v = B.textures, z = B.width, $ = B.height;
              let ie = s.COLOR_BUFFER_BIT;
              const J = B.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Se = i.get(B), fe = v.length > 1;
              if (fe) for (let we = 0; we < v.length; we++) t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.TEXTURE_2D, null, 0);
              t.bindFramebuffer(s.READ_FRAMEBUFFER, Se.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Se.__webglFramebuffer);
              for (let we = 0; we < v.length; we++) {
                if (B.resolveDepthBuffer && (B.depthBuffer && (ie |= s.DEPTH_BUFFER_BIT), B.stencilBuffer && B.resolveStencilBuffer && (ie |= s.STENCIL_BUFFER_BIT)), fe) {
                  s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Se.__webglColorRenderbuffer[we]);
                  const st = i.get(v[we]).__webglTexture;
                  s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, st, 0);
                }
                s.blitFramebuffer(0, 0, z, $, 0, 0, z, $, ie, s.NEAREST), c === true && (Ke.length = 0, F.length = 0, Ke.push(s.COLOR_ATTACHMENT0 + we), B.depthBuffer && B.resolveDepthBuffer === false && (Ke.push(J), F.push(J), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, F)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Ke));
              }
              if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), fe) for (let we = 0; we < v.length; we++) {
                t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.RENDERBUFFER, Se.__webglColorRenderbuffer[we]);
                const st = i.get(v[we]).__webglTexture;
                t.bindFramebuffer(s.FRAMEBUFFER, Se.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.TEXTURE_2D, st, 0);
              }
              t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Se.__webglMultisampledFramebuffer);
            } else if (B.depthBuffer && B.resolveDepthBuffer === false && c) {
              const v = B.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
              s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [
                v
              ]);
            }
          }
        }
        function rt(B) {
          return Math.min(n.maxSamples, B.samples);
        }
        function $e(B) {
          const v = i.get(B);
          return B.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && v.__useRenderToTexture !== false;
        }
        function Ie(B) {
          const v = a.render.frame;
          h.get(B) !== v && (h.set(B, v), B.update());
        }
        function xt(B, v) {
          const z = B.colorSpace, $ = B.format, ie = B.type;
          return B.isCompressedTexture === true || B.isVideoTexture === true || z !== oi && z !== an && (ze.getTransfer(z) === pt ? ($ !== Wt || ie !== Jt) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", z)), v;
        }
        function Ce(B) {
          return typeof HTMLImageElement < "u" && B instanceof HTMLImageElement ? (l.width = B.naturalWidth || B.width, l.height = B.naturalHeight || B.height) : typeof VideoFrame < "u" && B instanceof VideoFrame ? (l.width = B.displayWidth, l.height = B.displayHeight) : (l.width = B.width, l.height = B.height), l;
        }
        this.allocateTextureUnit = H, this.resetTextureUnits = j, this.setTexture2D = te, this.setTexture2DArray = q, this.setTexture3D = Z, this.setTextureCube = V, this.rebindTextures = Le, this.setupRenderTarget = St, this.updateRenderTargetMipmap = wt, this.updateMultisampleRenderTarget = Ci, this.setupDepthRenderbuffer = Ze, this.setupFrameBufferTexture = be, this.useMultisampledRTT = $e;
      }
      function Ux(s, e) {
        function t(i, n = an) {
          let r;
          const a = ze.getTransfer(n);
          if (i === Jt) return s.UNSIGNED_BYTE;
          if (i === gh) return s.UNSIGNED_SHORT_4_4_4_4;
          if (i === _h) return s.UNSIGNED_SHORT_5_5_5_1;
          if (i === Vf) return s.UNSIGNED_INT_5_9_9_9_REV;
          if (i === Gf) return s.BYTE;
          if (i === Hf) return s.SHORT;
          if (i === Ns) return s.UNSIGNED_SHORT;
          if (i === Ah) return s.INT;
          if (i === Ar) return s.UNSIGNED_INT;
          if (i === ii) return s.FLOAT;
          if (i === vi) return s.HALF_FLOAT;
          if (i === Wf) return s.ALPHA;
          if (i === jf) return s.RGB;
          if (i === Wt) return s.RGBA;
          if (i === qf) return s.LUMINANCE;
          if (i === Xf) return s.LUMINANCE_ALPHA;
          if (i === Os) return s.DEPTH_COMPONENT;
          if (i === zs) return s.DEPTH_STENCIL;
          if (i === yn) return s.RED;
          if (i === mh) return s.RED_INTEGER;
          if (i === hr) return s.RG;
          if (i === wh) return s.RG_INTEGER;
          if (i === bh) return s.RGBA_INTEGER;
          if (i === no || i === Ts || i === ro || i === Rs) if (a === pt) if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
            if (i === no) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (i === Ts) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (i === ro) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (i === Rs) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
          else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
            if (i === no) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === Ts) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === ro) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === Rs) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
          if (i === uo || i === yl || i === fo || i === xl) if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
            if (i === uo) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === yl) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === fo) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === xl) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
          if (i === po || i === Ao || i === go) if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
            if (i === po || i === Ao) return a === pt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
            if (i === go) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
          } else return null;
          if (i === Gs || i === El || i === vl || i === Sl || i === Hs || i === Cl || i === Il || i === Ml || i === Tl || i === Rl || i === Bl || i === Dl || i === Pl || i === Ll) if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
            if (i === Gs) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (i === El) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (i === vl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (i === Sl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (i === Hs) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (i === Cl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (i === Il) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (i === Ml) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (i === Tl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (i === Rl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (i === Bl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (i === Dl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (i === Pl) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (i === Ll) return a === pt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else return null;
          if (i === Bs || i === Fl || i === _o) if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
            if (i === Bs) return a === pt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            if (i === Fl) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            if (i === _o) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
          } else return null;
          if (i === Yf || i === kl || i === Ul || i === Nl) if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
            if (i === Bs) return r.COMPRESSED_RED_RGTC1_EXT;
            if (i === kl) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === Ul) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === Nl) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
          return i === Qs ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
        }
        return {
          convert: t
        };
      }
      const Nx = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, Qx = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class Ox {
        constructor() {
          this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(e, t, i) {
          if (this.texture === null) {
            const n = new Nt(), r = e.properties.get(n);
            r.__webglTexture = t.texture, (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = n;
          }
        }
        getMesh(e) {
          if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport, i = new ki({
              vertexShader: Nx,
              fragmentShader: Qx,
              uniforms: {
                depthColor: {
                  value: this.texture
                },
                depthWidth: {
                  value: t.z
                },
                depthHeight: {
                  value: t.w
                }
              }
            });
            this.mesh = new yt(new yr(20, 20), i);
          }
          return this.mesh;
        }
        reset() {
          this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class zx extends jn {
        constructor(e, t) {
          super();
          const i = this;
          let n = null, r = 1, a = null, o = "local-floor", c = 1, l = null, h = null, d = null, u = null, f = null, p = null;
          const m = new Ox(), g = t.getContextAttributes();
          let A = null, x = null;
          const b = [], y = [], I = new oe();
          let M = null;
          const R = new Vt();
          R.viewport = new je();
          const D = new Vt();
          D.viewport = new je();
          const S = [
            R,
            D
          ], E = new Gm();
          let P = null, j = null;
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(K) {
            let ae = b[K];
            return ae === void 0 && (ae = new yc(), b[K] = ae), ae.getTargetRaySpace();
          }, this.getControllerGrip = function(K) {
            let ae = b[K];
            return ae === void 0 && (ae = new yc(), b[K] = ae), ae.getGripSpace();
          }, this.getHand = function(K) {
            let ae = b[K];
            return ae === void 0 && (ae = new yc(), b[K] = ae), ae.getHandSpace();
          };
          function H(K) {
            const ae = y.indexOf(K.inputSource);
            if (ae === -1) return;
            const be = b[ae];
            be !== void 0 && (be.update(K.inputSource, K.frame, l || a), be.dispatchEvent({
              type: K.type,
              data: K.inputSource
            }));
          }
          function Y() {
            n.removeEventListener("select", H), n.removeEventListener("selectstart", H), n.removeEventListener("selectend", H), n.removeEventListener("squeeze", H), n.removeEventListener("squeezestart", H), n.removeEventListener("squeezeend", H), n.removeEventListener("end", Y), n.removeEventListener("inputsourceschange", te);
            for (let K = 0; K < b.length; K++) {
              const ae = y[K];
              ae !== null && (y[K] = null, b[K].disconnect(ae));
            }
            P = null, j = null, m.reset(), e.setRenderTarget(A), f = null, u = null, d = null, n = null, x = null, Ve.stop(), i.isPresenting = false, e.setPixelRatio(M), e.setSize(I.width, I.height, false), i.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(K) {
            r = K, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(K) {
            o = K, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return l || a;
          }, this.setReferenceSpace = function(K) {
            l = K;
          }, this.getBaseLayer = function() {
            return u !== null ? u : f;
          }, this.getBinding = function() {
            return d;
          }, this.getFrame = function() {
            return p;
          }, this.getSession = function() {
            return n;
          }, this.setSession = async function(K) {
            if (n = K, n !== null) {
              if (A = e.getRenderTarget(), n.addEventListener("select", H), n.addEventListener("selectstart", H), n.addEventListener("selectend", H), n.addEventListener("squeeze", H), n.addEventListener("squeezestart", H), n.addEventListener("squeezeend", H), n.addEventListener("end", Y), n.addEventListener("inputsourceschange", te), g.xrCompatible !== true && await t.makeXRCompatible(), M = e.getPixelRatio(), e.getSize(I), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                let be = null, le = null, Te = null;
                g.depth && (Te = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, be = g.stencil ? zs : Os, le = g.stencil ? Qs : Ar);
                const Ze = {
                  colorFormat: t.RGBA8,
                  depthFormat: Te,
                  scaleFactor: r
                };
                d = new XRWebGLBinding(n, t), u = d.createProjectionLayer(Ze), n.updateRenderState({
                  layers: [
                    u
                  ]
                }), e.setPixelRatio(1), e.setSize(u.textureWidth, u.textureHeight, false), x = new Cn(u.textureWidth, u.textureHeight, {
                  format: Wt,
                  type: Jt,
                  depthTexture: new op(u.textureWidth, u.textureHeight, le, void 0, void 0, void 0, void 0, void 0, void 0, be),
                  stencilBuffer: g.stencil,
                  colorSpace: e.outputColorSpace,
                  samples: g.antialias ? 4 : 0,
                  resolveDepthBuffer: u.ignoreDepthValues === false,
                  resolveStencilBuffer: u.ignoreDepthValues === false
                });
              } else {
                const be = {
                  antialias: g.antialias,
                  alpha: true,
                  depth: g.depth,
                  stencil: g.stencil,
                  framebufferScaleFactor: r
                };
                f = new XRWebGLLayer(n, t, be), n.updateRenderState({
                  baseLayer: f
                }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, false), x = new Cn(f.framebufferWidth, f.framebufferHeight, {
                  format: Wt,
                  type: Jt,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: g.stencil,
                  resolveDepthBuffer: f.ignoreDepthValues === false,
                  resolveStencilBuffer: f.ignoreDepthValues === false
                });
              }
              x.isXRRenderTarget = true, this.setFoveation(c), l = null, a = await n.requestReferenceSpace(o), Ve.setContext(n), Ve.start(), i.isPresenting = true, i.dispatchEvent({
                type: "sessionstart"
              });
            }
          }, this.getEnvironmentBlendMode = function() {
            if (n !== null) return n.environmentBlendMode;
          }, this.getDepthTexture = function() {
            return m.getDepthTexture();
          };
          function te(K) {
            for (let ae = 0; ae < K.removed.length; ae++) {
              const be = K.removed[ae], le = y.indexOf(be);
              le >= 0 && (y[le] = null, b[le].disconnect(be));
            }
            for (let ae = 0; ae < K.added.length; ae++) {
              const be = K.added[ae];
              let le = y.indexOf(be);
              if (le === -1) {
                for (let Ze = 0; Ze < b.length; Ze++) if (Ze >= y.length) {
                  y.push(be), le = Ze;
                  break;
                } else if (y[Ze] === null) {
                  y[Ze] = be, le = Ze;
                  break;
                }
                if (le === -1) break;
              }
              const Te = b[le];
              Te && Te.connect(be);
            }
          }
          const q = new T(), Z = new T();
          function V(K, ae, be) {
            q.setFromMatrixPosition(ae.matrixWorld), Z.setFromMatrixPosition(be.matrixWorld);
            const le = q.distanceTo(Z), Te = ae.projectionMatrix.elements, Ze = be.projectionMatrix.elements, Le = Te[14] / (Te[10] - 1), St = Te[14] / (Te[10] + 1), wt = (Te[9] + 1) / Te[5], Ke = (Te[9] - 1) / Te[5], F = (Te[8] - 1) / Te[0], Ci = (Ze[8] + 1) / Ze[0], rt = Le * F, $e = Le * Ci, Ie = le / (-F + Ci), xt = Ie * -F;
            if (ae.matrixWorld.decompose(K.position, K.quaternion, K.scale), K.translateX(xt), K.translateZ(Ie), K.matrixWorld.compose(K.position, K.quaternion, K.scale), K.matrixWorldInverse.copy(K.matrixWorld).invert(), Te[10] === -1) K.projectionMatrix.copy(ae.projectionMatrix), K.projectionMatrixInverse.copy(ae.projectionMatrixInverse);
            else {
              const Ce = Le + Ie, B = St + Ie, v = rt - xt, z = $e + (le - xt), $ = wt * St / B * Ce, ie = Ke * St / B * Ce;
              K.projectionMatrix.makePerspective(v, z, $, ie, Ce, B), K.projectionMatrixInverse.copy(K.projectionMatrix).invert();
            }
          }
          function re(K, ae) {
            ae === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(ae.matrixWorld, K.matrix), K.matrixWorldInverse.copy(K.matrixWorld).invert();
          }
          this.updateCamera = function(K) {
            if (n === null) return;
            let ae = K.near, be = K.far;
            m.texture !== null && (m.depthNear > 0 && (ae = m.depthNear), m.depthFar > 0 && (be = m.depthFar)), E.near = D.near = R.near = ae, E.far = D.far = R.far = be, (P !== E.near || j !== E.far) && (n.updateRenderState({
              depthNear: E.near,
              depthFar: E.far
            }), P = E.near, j = E.far), R.layers.mask = K.layers.mask | 2, D.layers.mask = K.layers.mask | 4, E.layers.mask = R.layers.mask | D.layers.mask;
            const le = K.parent, Te = E.cameras;
            re(E, le);
            for (let Ze = 0; Ze < Te.length; Ze++) re(Te[Ze], le);
            Te.length === 2 ? V(E, R, D) : E.projectionMatrix.copy(R.projectionMatrix), he(K, E, le);
          };
          function he(K, ae, be) {
            be === null ? K.matrix.copy(ae.matrixWorld) : (K.matrix.copy(be.matrixWorld), K.matrix.invert(), K.matrix.multiply(ae.matrixWorld)), K.matrix.decompose(K.position, K.quaternion, K.scale), K.updateMatrixWorld(true), K.projectionMatrix.copy(ae.projectionMatrix), K.projectionMatrixInverse.copy(ae.projectionMatrixInverse), K.isPerspectiveCamera && (K.fov = es * 2 * Math.atan(1 / K.projectionMatrix.elements[5]), K.zoom = 1);
          }
          this.getCamera = function() {
            return E;
          }, this.getFoveation = function() {
            if (!(u === null && f === null)) return c;
          }, this.setFoveation = function(K) {
            c = K, u !== null && (u.fixedFoveation = K), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = K);
          }, this.hasDepthSensing = function() {
            return m.texture !== null;
          }, this.getDepthSensingMesh = function() {
            return m.getMesh(E);
          };
          let ve = null;
          function Pe(K, ae) {
            if (h = ae.getViewerPose(l || a), p = ae, h !== null) {
              const be = h.views;
              f !== null && (e.setRenderTargetFramebuffer(x, f.framebuffer), e.setRenderTarget(x));
              let le = false;
              be.length !== E.cameras.length && (E.cameras.length = 0, le = true);
              for (let Le = 0; Le < be.length; Le++) {
                const St = be[Le];
                let wt = null;
                if (f !== null) wt = f.getViewport(St);
                else {
                  const F = d.getViewSubImage(u, St);
                  wt = F.viewport, Le === 0 && (e.setRenderTargetTextures(x, F.colorTexture, F.depthStencilTexture), e.setRenderTarget(x));
                }
                let Ke = S[Le];
                Ke === void 0 && (Ke = new Vt(), Ke.layers.enable(Le), Ke.viewport = new je(), S[Le] = Ke), Ke.matrix.fromArray(St.transform.matrix), Ke.matrix.decompose(Ke.position, Ke.quaternion, Ke.scale), Ke.projectionMatrix.fromArray(St.projectionMatrix), Ke.projectionMatrixInverse.copy(Ke.projectionMatrix).invert(), Ke.viewport.set(wt.x, wt.y, wt.width, wt.height), Le === 0 && (E.matrix.copy(Ke.matrix), E.matrix.decompose(E.position, E.quaternion, E.scale)), le === true && E.cameras.push(Ke);
              }
              const Te = n.enabledFeatures;
              if (Te && Te.includes("depth-sensing") && n.depthUsage == "gpu-optimized" && d) {
                const Le = d.getDepthInformation(be[0]);
                Le && Le.isValid && Le.texture && m.init(e, Le, n.renderState);
              }
            }
            for (let be = 0; be < b.length; be++) {
              const le = y[be], Te = b[be];
              le !== null && Te !== void 0 && Te.update(le, ae, l || a);
            }
            ve && ve(K, ae), ae.detectedPlanes && i.dispatchEvent({
              type: "planesdetected",
              data: ae
            }), p = null;
          }
          const Ve = new Ip();
          Ve.setAnimationLoop(Pe), this.setAnimationLoop = function(K) {
            ve = K;
          }, this.dispose = function() {
          };
        }
      }
      const rr = new Ht(), Gx = new ge();
      function Hx(s, e) {
        function t(g, A) {
          g.matrixAutoUpdate === true && g.updateMatrix(), A.value.copy(g.matrix);
        }
        function i(g, A) {
          A.color.getRGB(g.fogColor.value, rp(s)), A.isFog ? (g.fogNear.value = A.near, g.fogFar.value = A.far) : A.isFogExp2 && (g.fogDensity.value = A.density);
        }
        function n(g, A, x, b, y) {
          A.isMeshBasicMaterial || A.isMeshLambertMaterial ? r(g, A) : A.isMeshToonMaterial ? (r(g, A), d(g, A)) : A.isMeshPhongMaterial ? (r(g, A), h(g, A)) : A.isMeshStandardMaterial ? (r(g, A), u(g, A), A.isMeshPhysicalMaterial && f(g, A, y)) : A.isMeshMatcapMaterial ? (r(g, A), p(g, A)) : A.isMeshDepthMaterial ? r(g, A) : A.isMeshDistanceMaterial ? (r(g, A), m(g, A)) : A.isMeshNormalMaterial ? r(g, A) : A.isLineBasicMaterial ? (a(g, A), A.isLineDashedMaterial && o(g, A)) : A.isPointsMaterial ? c(g, A, x, b) : A.isSpriteMaterial ? l(g, A) : A.isShadowMaterial ? (g.color.value.copy(A.color), g.opacity.value = A.opacity) : A.isShaderMaterial && (A.uniformsNeedUpdate = false);
        }
        function r(g, A) {
          g.opacity.value = A.opacity, A.color && g.diffuse.value.copy(A.color), A.emissive && g.emissive.value.copy(A.emissive).multiplyScalar(A.emissiveIntensity), A.map && (g.map.value = A.map, t(A.map, g.mapTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, t(A.alphaMap, g.alphaMapTransform)), A.bumpMap && (g.bumpMap.value = A.bumpMap, t(A.bumpMap, g.bumpMapTransform), g.bumpScale.value = A.bumpScale, A.side === _i && (g.bumpScale.value *= -1)), A.normalMap && (g.normalMap.value = A.normalMap, t(A.normalMap, g.normalMapTransform), g.normalScale.value.copy(A.normalScale), A.side === _i && g.normalScale.value.negate()), A.displacementMap && (g.displacementMap.value = A.displacementMap, t(A.displacementMap, g.displacementMapTransform), g.displacementScale.value = A.displacementScale, g.displacementBias.value = A.displacementBias), A.emissiveMap && (g.emissiveMap.value = A.emissiveMap, t(A.emissiveMap, g.emissiveMapTransform)), A.specularMap && (g.specularMap.value = A.specularMap, t(A.specularMap, g.specularMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
          const x = e.get(A), b = x.envMap, y = x.envMapRotation;
          b && (g.envMap.value = b, rr.copy(y), rr.x *= -1, rr.y *= -1, rr.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === false && (rr.y *= -1, rr.z *= -1), g.envMapRotation.value.setFromMatrix4(Gx.makeRotationFromEuler(rr)), g.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = A.reflectivity, g.ior.value = A.ior, g.refractionRatio.value = A.refractionRatio), A.lightMap && (g.lightMap.value = A.lightMap, g.lightMapIntensity.value = A.lightMapIntensity, t(A.lightMap, g.lightMapTransform)), A.aoMap && (g.aoMap.value = A.aoMap, g.aoMapIntensity.value = A.aoMapIntensity, t(A.aoMap, g.aoMapTransform));
        }
        function a(g, A) {
          g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, A.map && (g.map.value = A.map, t(A.map, g.mapTransform));
        }
        function o(g, A) {
          g.dashSize.value = A.dashSize, g.totalSize.value = A.dashSize + A.gapSize, g.scale.value = A.scale;
        }
        function c(g, A, x, b) {
          g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, g.size.value = A.size * x, g.scale.value = b * 0.5, A.map && (g.map.value = A.map, t(A.map, g.uvTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, t(A.alphaMap, g.alphaMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
        }
        function l(g, A) {
          g.diffuse.value.copy(A.color), g.opacity.value = A.opacity, g.rotation.value = A.rotation, A.map && (g.map.value = A.map, t(A.map, g.mapTransform)), A.alphaMap && (g.alphaMap.value = A.alphaMap, t(A.alphaMap, g.alphaMapTransform)), A.alphaTest > 0 && (g.alphaTest.value = A.alphaTest);
        }
        function h(g, A) {
          g.specular.value.copy(A.specular), g.shininess.value = Math.max(A.shininess, 1e-4);
        }
        function d(g, A) {
          A.gradientMap && (g.gradientMap.value = A.gradientMap);
        }
        function u(g, A) {
          g.metalness.value = A.metalness, A.metalnessMap && (g.metalnessMap.value = A.metalnessMap, t(A.metalnessMap, g.metalnessMapTransform)), g.roughness.value = A.roughness, A.roughnessMap && (g.roughnessMap.value = A.roughnessMap, t(A.roughnessMap, g.roughnessMapTransform)), A.envMap && (g.envMapIntensity.value = A.envMapIntensity);
        }
        function f(g, A, x) {
          g.ior.value = A.ior, A.sheen > 0 && (g.sheenColor.value.copy(A.sheenColor).multiplyScalar(A.sheen), g.sheenRoughness.value = A.sheenRoughness, A.sheenColorMap && (g.sheenColorMap.value = A.sheenColorMap, t(A.sheenColorMap, g.sheenColorMapTransform)), A.sheenRoughnessMap && (g.sheenRoughnessMap.value = A.sheenRoughnessMap, t(A.sheenRoughnessMap, g.sheenRoughnessMapTransform))), A.clearcoat > 0 && (g.clearcoat.value = A.clearcoat, g.clearcoatRoughness.value = A.clearcoatRoughness, A.clearcoatMap && (g.clearcoatMap.value = A.clearcoatMap, t(A.clearcoatMap, g.clearcoatMapTransform)), A.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = A.clearcoatRoughnessMap, t(A.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), A.clearcoatNormalMap && (g.clearcoatNormalMap.value = A.clearcoatNormalMap, t(A.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(A.clearcoatNormalScale), A.side === _i && g.clearcoatNormalScale.value.negate())), A.dispersion > 0 && (g.dispersion.value = A.dispersion), A.iridescence > 0 && (g.iridescence.value = A.iridescence, g.iridescenceIOR.value = A.iridescenceIOR, g.iridescenceThicknessMinimum.value = A.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = A.iridescenceThicknessRange[1], A.iridescenceMap && (g.iridescenceMap.value = A.iridescenceMap, t(A.iridescenceMap, g.iridescenceMapTransform)), A.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = A.iridescenceThicknessMap, t(A.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), A.transmission > 0 && (g.transmission.value = A.transmission, g.transmissionSamplerMap.value = x.texture, g.transmissionSamplerSize.value.set(x.width, x.height), A.transmissionMap && (g.transmissionMap.value = A.transmissionMap, t(A.transmissionMap, g.transmissionMapTransform)), g.thickness.value = A.thickness, A.thicknessMap && (g.thicknessMap.value = A.thicknessMap, t(A.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = A.attenuationDistance, g.attenuationColor.value.copy(A.attenuationColor)), A.anisotropy > 0 && (g.anisotropyVector.value.set(A.anisotropy * Math.cos(A.anisotropyRotation), A.anisotropy * Math.sin(A.anisotropyRotation)), A.anisotropyMap && (g.anisotropyMap.value = A.anisotropyMap, t(A.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = A.specularIntensity, g.specularColor.value.copy(A.specularColor), A.specularColorMap && (g.specularColorMap.value = A.specularColorMap, t(A.specularColorMap, g.specularColorMapTransform)), A.specularIntensityMap && (g.specularIntensityMap.value = A.specularIntensityMap, t(A.specularIntensityMap, g.specularIntensityMapTransform));
        }
        function p(g, A) {
          A.matcap && (g.matcap.value = A.matcap);
        }
        function m(g, A) {
          const x = e.get(A).light;
          g.referencePosition.value.setFromMatrixPosition(x.matrixWorld), g.nearDistance.value = x.shadow.camera.near, g.farDistance.value = x.shadow.camera.far;
        }
        return {
          refreshFogUniforms: i,
          refreshMaterialUniforms: n
        };
      }
      function Vx(s, e, t, i) {
        let n = {}, r = {}, a = [];
        const o = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
        function c(x, b) {
          const y = b.program;
          i.uniformBlockBinding(x, y);
        }
        function l(x, b) {
          let y = n[x.id];
          y === void 0 && (p(x), y = h(x), n[x.id] = y, x.addEventListener("dispose", g));
          const I = b.program;
          i.updateUBOMapping(x, I);
          const M = e.render.frame;
          r[x.id] !== M && (u(x), r[x.id] = M);
        }
        function h(x) {
          const b = d();
          x.__bindingPointIndex = b;
          const y = s.createBuffer(), I = x.__size, M = x.usage;
          return s.bindBuffer(s.UNIFORM_BUFFER, y), s.bufferData(s.UNIFORM_BUFFER, I, M), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, b, y), y;
        }
        function d() {
          for (let x = 0; x < o; x++) if (a.indexOf(x) === -1) return a.push(x), x;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function u(x) {
          const b = n[x.id], y = x.uniforms, I = x.__cache;
          s.bindBuffer(s.UNIFORM_BUFFER, b);
          for (let M = 0, R = y.length; M < R; M++) {
            const D = Array.isArray(y[M]) ? y[M] : [
              y[M]
            ];
            for (let S = 0, E = D.length; S < E; S++) {
              const P = D[S];
              if (f(P, M, S, I) === true) {
                const j = P.__offset, H = Array.isArray(P.value) ? P.value : [
                  P.value
                ];
                let Y = 0;
                for (let te = 0; te < H.length; te++) {
                  const q = H[te], Z = m(q);
                  typeof q == "number" || typeof q == "boolean" ? (P.__data[0] = q, s.bufferSubData(s.UNIFORM_BUFFER, j + Y, P.__data)) : q.isMatrix3 ? (P.__data[0] = q.elements[0], P.__data[1] = q.elements[1], P.__data[2] = q.elements[2], P.__data[3] = 0, P.__data[4] = q.elements[3], P.__data[5] = q.elements[4], P.__data[6] = q.elements[5], P.__data[7] = 0, P.__data[8] = q.elements[6], P.__data[9] = q.elements[7], P.__data[10] = q.elements[8], P.__data[11] = 0) : (q.toArray(P.__data, Y), Y += Z.storage / Float32Array.BYTES_PER_ELEMENT);
                }
                s.bufferSubData(s.UNIFORM_BUFFER, j, P.__data);
              }
            }
          }
          s.bindBuffer(s.UNIFORM_BUFFER, null);
        }
        function f(x, b, y, I) {
          const M = x.value, R = b + "_" + y;
          if (I[R] === void 0) return typeof M == "number" || typeof M == "boolean" ? I[R] = M : I[R] = M.clone(), true;
          {
            const D = I[R];
            if (typeof M == "number" || typeof M == "boolean") {
              if (D !== M) return I[R] = M, true;
            } else if (D.equals(M) === false) return D.copy(M), true;
          }
          return false;
        }
        function p(x) {
          const b = x.uniforms;
          let y = 0;
          const I = 16;
          for (let R = 0, D = b.length; R < D; R++) {
            const S = Array.isArray(b[R]) ? b[R] : [
              b[R]
            ];
            for (let E = 0, P = S.length; E < P; E++) {
              const j = S[E], H = Array.isArray(j.value) ? j.value : [
                j.value
              ];
              for (let Y = 0, te = H.length; Y < te; Y++) {
                const q = H[Y], Z = m(q), V = y % I, re = V % Z.boundary, he = V + re;
                y += re, he !== 0 && I - he < Z.storage && (y += I - he), j.__data = new Float32Array(Z.storage / Float32Array.BYTES_PER_ELEMENT), j.__offset = y, y += Z.storage;
              }
            }
          }
          const M = y % I;
          return M > 0 && (y += I - M), x.__size = y, x.__cache = {}, this;
        }
        function m(x) {
          const b = {
            boundary: 0,
            storage: 0
          };
          return typeof x == "number" || typeof x == "boolean" ? (b.boundary = 4, b.storage = 4) : x.isVector2 ? (b.boundary = 8, b.storage = 8) : x.isVector3 || x.isColor ? (b.boundary = 16, b.storage = 12) : x.isVector4 ? (b.boundary = 16, b.storage = 16) : x.isMatrix3 ? (b.boundary = 48, b.storage = 48) : x.isMatrix4 ? (b.boundary = 64, b.storage = 64) : x.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", x), b;
        }
        function g(x) {
          const b = x.target;
          b.removeEventListener("dispose", g);
          const y = a.indexOf(b.__bindingPointIndex);
          a.splice(y, 1), s.deleteBuffer(n[b.id]), delete n[b.id], delete r[b.id];
        }
        function A() {
          for (const x in n) s.deleteBuffer(n[x]);
          a = [], n = {}, r = {};
        }
        return {
          bind: c,
          update: l,
          dispose: A
        };
      }
      class Dp {
        constructor(e = {}) {
          const { canvas: t = l_(), context: i = null, depth: n = true, stencil: r = false, alpha: a = false, antialias: o = false, premultipliedAlpha: c = true, preserveDrawingBuffer: l = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = false, reverseDepthBuffer: u = false } = e;
          this.isWebGLRenderer = true;
          let f;
          if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            f = i.getContextAttributes().alpha;
          } else f = a;
          const p = new Uint32Array(4), m = new Int32Array(4);
          let g = null, A = null;
          const x = [], b = [];
          this.domElement = t, this.debug = {
            checkShaderErrors: true,
            onShaderError: null
          }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.toneMapping = Gn, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
          const y = this;
          let I = false;
          this._outputColorSpace = nt;
          let M = 0, R = 0, D = null, S = -1, E = null;
          const P = new je(), j = new je();
          let H = null;
          const Y = new ue(0);
          let te = 0, q = t.width, Z = t.height, V = 1, re = null, he = null;
          const ve = new je(0, 0, q, Z), Pe = new je(0, 0, q, Z);
          let Ve = false;
          const K = new Th();
          let ae = false, be = false;
          const le = new ge(), Te = new ge(), Ze = new T(), Le = new je(), St = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
          };
          let wt = false;
          function Ke() {
            return D === null ? V : 1;
          }
          let F = i;
          function Ci(C, Q) {
            return t.getContext(C, Q);
          }
          try {
            const C = {
              alpha: true,
              depth: n,
              stencil: r,
              antialias: o,
              premultipliedAlpha: c,
              preserveDrawingBuffer: l,
              powerPreference: h,
              failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${ph}`), t.addEventListener("webglcontextlost", ee, false), t.addEventListener("webglcontextrestored", _e, false), t.addEventListener("webglcontextcreationerror", Ae, false), F === null) {
              const Q = "webgl2";
              if (F = Ci(Q, C), F === null) throw Ci(Q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          } catch (C) {
            throw console.error("THREE.WebGLRenderer: " + C.message), C;
          }
          let rt, $e, Ie, xt, Ce, B, v, z, $, ie, J, Se, fe, we, st, se, ye, Fe, Ue, xe, et, qe, bt, N;
          function pe() {
            rt = new t0(F), rt.init(), qe = new Ux(F, rt), $e = new Xy(F, rt, e, qe), Ie = new Fx(F, rt), $e.reverseDepthBuffer && u && Ie.buffers.depth.setReversed(true), xt = new r0(F), Ce = new xx(), B = new kx(F, rt, Ie, Ce, $e, qe, xt), v = new Ky(y), z = new e0(y), $ = new hw(F), bt = new jy(F, $), ie = new i0(F, $, xt, bt), J = new a0(F, ie, $, xt), Ue = new s0(F, $e, B), se = new Yy(Ce), Se = new yx(y, v, z, rt, $e, bt, se), fe = new Hx(y, Ce), we = new vx(), st = new Rx(rt), Fe = new Wy(y, v, z, Ie, J, f, c), ye = new Px(y, J, $e), N = new Vx(F, xt, $e, Ie), xe = new qy(F, rt, xt), et = new n0(F, rt, xt), xt.programs = Se.programs, y.capabilities = $e, y.extensions = rt, y.properties = Ce, y.renderLists = we, y.shadowMap = ye, y.state = Ie, y.info = xt;
          }
          pe();
          const X = new zx(y, F);
          this.xr = X, this.getContext = function() {
            return F;
          }, this.getContextAttributes = function() {
            return F.getContextAttributes();
          }, this.forceContextLoss = function() {
            const C = rt.get("WEBGL_lose_context");
            C && C.loseContext();
          }, this.forceContextRestore = function() {
            const C = rt.get("WEBGL_lose_context");
            C && C.restoreContext();
          }, this.getPixelRatio = function() {
            return V;
          }, this.setPixelRatio = function(C) {
            C !== void 0 && (V = C, this.setSize(q, Z, false));
          }, this.getSize = function(C) {
            return C.set(q, Z);
          }, this.setSize = function(C, Q, G = true) {
            if (X.isPresenting) {
              console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
              return;
            }
            q = C, Z = Q, t.width = Math.floor(C * V), t.height = Math.floor(Q * V), G === true && (t.style.width = C + "px", t.style.height = Q + "px"), this.setViewport(0, 0, C, Q);
          }, this.getDrawingBufferSize = function(C) {
            return C.set(q * V, Z * V).floor();
          }, this.setDrawingBufferSize = function(C, Q, G) {
            q = C, Z = Q, V = G, t.width = Math.floor(C * G), t.height = Math.floor(Q * G), this.setViewport(0, 0, C, Q);
          }, this.getCurrentViewport = function(C) {
            return C.copy(P);
          }, this.getViewport = function(C) {
            return C.copy(ve);
          }, this.setViewport = function(C, Q, G, W) {
            C.isVector4 ? ve.set(C.x, C.y, C.z, C.w) : ve.set(C, Q, G, W), Ie.viewport(P.copy(ve).multiplyScalar(V).round());
          }, this.getScissor = function(C) {
            return C.copy(Pe);
          }, this.setScissor = function(C, Q, G, W) {
            C.isVector4 ? Pe.set(C.x, C.y, C.z, C.w) : Pe.set(C, Q, G, W), Ie.scissor(j.copy(Pe).multiplyScalar(V).round());
          }, this.getScissorTest = function() {
            return Ve;
          }, this.setScissorTest = function(C) {
            Ie.setScissorTest(Ve = C);
          }, this.setOpaqueSort = function(C) {
            re = C;
          }, this.setTransparentSort = function(C) {
            he = C;
          }, this.getClearColor = function(C) {
            return C.copy(Fe.getClearColor());
          }, this.setClearColor = function() {
            Fe.setClearColor(...arguments);
          }, this.getClearAlpha = function() {
            return Fe.getClearAlpha();
          }, this.setClearAlpha = function() {
            Fe.setClearAlpha(...arguments);
          }, this.clear = function(C = true, Q = true, G = true) {
            let W = 0;
            if (C) {
              let O = false;
              if (D !== null) {
                const ne = D.texture.format;
                O = ne === bh || ne === wh || ne === mh;
              }
              if (O) {
                const ne = D.texture.type, de = ne === Jt || ne === Ar || ne === Ns || ne === Qs || ne === gh || ne === _h, me = Fe.getClearColor(), Ee = Fe.getClearAlpha(), Ne = me.r, ke = me.g, Me = me.b;
                de ? (p[0] = Ne, p[1] = ke, p[2] = Me, p[3] = Ee, F.clearBufferuiv(F.COLOR, 0, p)) : (m[0] = Ne, m[1] = ke, m[2] = Me, m[3] = Ee, F.clearBufferiv(F.COLOR, 0, m));
              } else W |= F.COLOR_BUFFER_BIT;
            }
            Q && (W |= F.DEPTH_BUFFER_BIT), G && (W |= F.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), F.clear(W);
          }, this.clearColor = function() {
            this.clear(true, false, false);
          }, this.clearDepth = function() {
            this.clear(false, true, false);
          }, this.clearStencil = function() {
            this.clear(false, false, true);
          }, this.dispose = function() {
            t.removeEventListener("webglcontextlost", ee, false), t.removeEventListener("webglcontextrestored", _e, false), t.removeEventListener("webglcontextcreationerror", Ae, false), Fe.dispose(), we.dispose(), st.dispose(), Ce.dispose(), v.dispose(), z.dispose(), J.dispose(), bt.dispose(), N.dispose(), Se.dispose(), X.dispose(), X.removeEventListener("sessionstart", pd), X.removeEventListener("sessionend", Ad), qn.stop();
          };
          function ee(C) {
            C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), I = true;
          }
          function _e() {
            console.log("THREE.WebGLRenderer: Context Restored."), I = false;
            const C = xt.autoReset, Q = ye.enabled, G = ye.autoUpdate, W = ye.needsUpdate, O = ye.type;
            pe(), xt.autoReset = C, ye.enabled = Q, ye.autoUpdate = G, ye.needsUpdate = W, ye.type = O;
          }
          function Ae(C) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", C.statusMessage);
          }
          function We(C) {
            const Q = C.target;
            Q.removeEventListener("dispose", We), Bt(Q);
          }
          function Bt(C) {
            ri(C), Ce.remove(C);
          }
          function ri(C) {
            const Q = Ce.get(C).programs;
            Q !== void 0 && (Q.forEach(function(G) {
              Se.releaseProgram(G);
            }), C.isShaderMaterial && Se.releaseShaderCache(C));
          }
          this.renderBufferDirect = function(C, Q, G, W, O, ne) {
            Q === null && (Q = St);
            const de = O.isMesh && O.matrixWorld.determinant() < 0, me = JA(C, Q, G, W, O);
            Ie.setMaterial(W, de);
            let Ee = G.index, Ne = 1;
            if (W.wireframe === true) {
              if (Ee = ie.getWireframeAttribute(G), Ee === void 0) return;
              Ne = 2;
            }
            const ke = G.drawRange, Me = G.attributes.position;
            let at = ke.start * Ne, lt = (ke.start + ke.count) * Ne;
            ne !== null && (at = Math.max(at, ne.start * Ne), lt = Math.min(lt, (ne.start + ne.count) * Ne)), Ee !== null ? (at = Math.max(at, 0), lt = Math.min(lt, Ee.count)) : Me != null && (at = Math.max(at, 0), lt = Math.min(lt, Me.count));
            const Lt = lt - at;
            if (Lt < 0 || Lt === 1 / 0) return;
            bt.setup(O, W, me, G, Ee);
            let Dt, ot = xe;
            if (Ee !== null && (Dt = $.get(Ee), ot = et, ot.setIndex(Dt)), O.isMesh) W.wireframe === true ? (Ie.setLineWidth(W.wireframeLinewidth * Ke()), ot.setMode(F.LINES)) : ot.setMode(F.TRIANGLES);
            else if (O.isLine) {
              let Re = W.linewidth;
              Re === void 0 && (Re = 1), Ie.setLineWidth(Re * Ke()), O.isLineSegments ? ot.setMode(F.LINES) : O.isLineLoop ? ot.setMode(F.LINE_LOOP) : ot.setMode(F.LINE_STRIP);
            } else O.isPoints ? ot.setMode(F.POINTS) : O.isSprite && ot.setMode(F.TRIANGLES);
            if (O.isBatchedMesh) if (O._multiDrawInstances !== null) so("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), ot.renderMultiDrawInstances(O._multiDrawStarts, O._multiDrawCounts, O._multiDrawCount, O._multiDrawInstances);
            else if (rt.get("WEBGL_multi_draw")) ot.renderMultiDraw(O._multiDrawStarts, O._multiDrawCounts, O._multiDrawCount);
            else {
              const Re = O._multiDrawStarts, $t = O._multiDrawCounts, ht = O._multiDrawCount, Oi = Ee ? $.get(Ee).bytesPerElement : 1, xr = Ce.get(W).currentProgram.getUniforms();
              for (let wi = 0; wi < ht; wi++) xr.setValue(F, "_gl_DrawID", wi), ot.render(Re[wi] / Oi, $t[wi]);
            }
            else if (O.isInstancedMesh) ot.renderInstances(at, Lt, O.count);
            else if (G.isInstancedBufferGeometry) {
              const Re = G._maxInstanceCount !== void 0 ? G._maxInstanceCount : 1 / 0, $t = Math.min(G.instanceCount, Re);
              ot.renderInstances(at, Lt, $t);
            } else ot.render(at, Lt);
          };
          function ut(C, Q, G) {
            C.transparent === true && C.side === Yi && C.forceSinglePass === false ? (C.side = _i, C.needsUpdate = true, pa(C, Q, G), C.side = Sn, C.needsUpdate = true, pa(C, Q, G), C.side = Yi) : pa(C, Q, G);
          }
          this.compile = function(C, Q, G = null) {
            G === null && (G = C), A = st.get(G), A.init(Q), b.push(A), G.traverseVisible(function(O) {
              O.isLight && O.layers.test(Q.layers) && (A.pushLight(O), O.castShadow && A.pushShadow(O));
            }), C !== G && C.traverseVisible(function(O) {
              O.isLight && O.layers.test(Q.layers) && (A.pushLight(O), O.castShadow && A.pushShadow(O));
            }), A.setupLights();
            const W = /* @__PURE__ */ new Set();
            return C.traverse(function(O) {
              if (!(O.isMesh || O.isPoints || O.isLine || O.isSprite)) return;
              const ne = O.material;
              if (ne) if (Array.isArray(ne)) for (let de = 0; de < ne.length; de++) {
                const me = ne[de];
                ut(me, G, O), W.add(me);
              }
              else ut(ne, G, O), W.add(ne);
            }), A = b.pop(), W;
          }, this.compileAsync = function(C, Q, G = null) {
            const W = this.compile(C, Q, G);
            return new Promise((O) => {
              function ne() {
                if (W.forEach(function(de) {
                  Ce.get(de).currentProgram.isReady() && W.delete(de);
                }), W.size === 0) {
                  O(C);
                  return;
                }
                setTimeout(ne, 10);
              }
              rt.get("KHR_parallel_shader_compile") !== null ? ne() : setTimeout(ne, 10);
            });
          };
          let Qi = null;
          function hn(C) {
            Qi && Qi(C);
          }
          function pd() {
            qn.stop();
          }
          function Ad() {
            qn.start();
          }
          const qn = new Ip();
          qn.setAnimationLoop(hn), typeof self < "u" && qn.setContext(self), this.setAnimationLoop = function(C) {
            Qi = C, X.setAnimationLoop(C), C === null ? qn.stop() : qn.start();
          }, X.addEventListener("sessionstart", pd), X.addEventListener("sessionend", Ad), this.render = function(C, Q) {
            if (Q !== void 0 && Q.isCamera !== true) {
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              return;
            }
            if (I === true) return;
            if (C.matrixWorldAutoUpdate === true && C.updateMatrixWorld(), Q.parent === null && Q.matrixWorldAutoUpdate === true && Q.updateMatrixWorld(), X.enabled === true && X.isPresenting === true && (X.cameraAutoUpdate === true && X.updateCamera(Q), Q = X.getCamera()), C.isScene === true && C.onBeforeRender(y, C, Q, D), A = st.get(C, b.length), A.init(Q), b.push(A), Te.multiplyMatrices(Q.projectionMatrix, Q.matrixWorldInverse), K.setFromProjectionMatrix(Te), be = this.localClippingEnabled, ae = se.init(this.clippingPlanes, be), g = we.get(C, x.length), g.init(), x.push(g), X.enabled === true && X.isPresenting === true) {
              const ne = y.xr.getDepthSensingMesh();
              ne !== null && $o(ne, Q, -1 / 0, y.sortObjects);
            }
            $o(C, Q, 0, y.sortObjects), g.finish(), y.sortObjects === true && g.sort(re, he), wt = X.enabled === false || X.isPresenting === false || X.hasDepthSensing() === false, wt && Fe.addToRenderList(g, C), this.info.render.frame++, ae === true && se.beginShadows();
            const G = A.state.shadowsArray;
            ye.render(G, C, Q), ae === true && se.endShadows(), this.info.autoReset === true && this.info.reset();
            const W = g.opaque, O = g.transmissive;
            if (A.setupLights(), Q.isArrayCamera) {
              const ne = Q.cameras;
              if (O.length > 0) for (let de = 0, me = ne.length; de < me; de++) {
                const Ee = ne[de];
                _d(W, O, C, Ee);
              }
              wt && Fe.render(C);
              for (let de = 0, me = ne.length; de < me; de++) {
                const Ee = ne[de];
                gd(g, C, Ee, Ee.viewport);
              }
            } else O.length > 0 && _d(W, O, C, Q), wt && Fe.render(C), gd(g, C, Q);
            D !== null && R === 0 && (B.updateMultisampleRenderTarget(D), B.updateRenderTargetMipmap(D)), C.isScene === true && C.onAfterRender(y, C, Q), bt.resetDefaultState(), S = -1, E = null, b.pop(), b.length > 0 ? (A = b[b.length - 1], ae === true && se.setGlobalState(y.clippingPlanes, A.state.camera)) : A = null, x.pop(), x.length > 0 ? g = x[x.length - 1] : g = null;
          };
          function $o(C, Q, G, W) {
            if (C.visible === false) return;
            if (C.layers.test(Q.layers)) {
              if (C.isGroup) G = C.renderOrder;
              else if (C.isLOD) C.autoUpdate === true && C.update(Q);
              else if (C.isLight) A.pushLight(C), C.castShadow && A.pushShadow(C);
              else if (C.isSprite) {
                if (!C.frustumCulled || K.intersectsSprite(C)) {
                  W && Le.setFromMatrixPosition(C.matrixWorld).applyMatrix4(Te);
                  const de = J.update(C), me = C.material;
                  me.visible && g.push(C, de, me, G, Le.z, null);
                }
              } else if ((C.isMesh || C.isLine || C.isPoints) && (!C.frustumCulled || K.intersectsObject(C))) {
                const de = J.update(C), me = C.material;
                if (W && (C.boundingSphere !== void 0 ? (C.boundingSphere === null && C.computeBoundingSphere(), Le.copy(C.boundingSphere.center)) : (de.boundingSphere === null && de.computeBoundingSphere(), Le.copy(de.boundingSphere.center)), Le.applyMatrix4(C.matrixWorld).applyMatrix4(Te)), Array.isArray(me)) {
                  const Ee = de.groups;
                  for (let Ne = 0, ke = Ee.length; Ne < ke; Ne++) {
                    const Me = Ee[Ne], at = me[Me.materialIndex];
                    at && at.visible && g.push(C, de, at, G, Le.z, Me);
                  }
                } else me.visible && g.push(C, de, me, G, Le.z, null);
              }
            }
            const ne = C.children;
            for (let de = 0, me = ne.length; de < me; de++) $o(ne[de], Q, G, W);
          }
          function gd(C, Q, G, W) {
            const O = C.opaque, ne = C.transmissive, de = C.transparent;
            A.setupLightsView(G), ae === true && se.setGlobalState(y.clippingPlanes, G), W && Ie.viewport(P.copy(W)), O.length > 0 && fa(O, Q, G), ne.length > 0 && fa(ne, Q, G), de.length > 0 && fa(de, Q, G), Ie.buffers.depth.setTest(true), Ie.buffers.depth.setMask(true), Ie.buffers.color.setMask(true), Ie.setPolygonOffset(false);
          }
          function _d(C, Q, G, W) {
            if ((G.isScene === true ? G.overrideMaterial : null) !== null) return;
            A.state.transmissionRenderTarget[W.id] === void 0 && (A.state.transmissionRenderTarget[W.id] = new Cn(1, 1, {
              generateMipmaps: true,
              type: rt.has("EXT_color_buffer_half_float") || rt.has("EXT_color_buffer_float") ? vi : Jt,
              minFilter: Ji,
              samples: 4,
              stencilBuffer: r,
              resolveDepthBuffer: false,
              resolveStencilBuffer: false,
              colorSpace: ze.workingColorSpace
            }));
            const ne = A.state.transmissionRenderTarget[W.id], de = W.viewport || P;
            ne.setSize(de.z * y.transmissionResolutionScale, de.w * y.transmissionResolutionScale);
            const me = y.getRenderTarget();
            y.setRenderTarget(ne), y.getClearColor(Y), te = y.getClearAlpha(), te < 1 && y.setClearColor(16777215, 0.5), y.clear(), wt && Fe.render(G);
            const Ee = y.toneMapping;
            y.toneMapping = Gn;
            const Ne = W.viewport;
            if (W.viewport !== void 0 && (W.viewport = void 0), A.setupLightsView(W), ae === true && se.setGlobalState(y.clippingPlanes, W), fa(C, G, W), B.updateMultisampleRenderTarget(ne), B.updateRenderTargetMipmap(ne), rt.has("WEBGL_multisampled_render_to_texture") === false) {
              let ke = false;
              for (let Me = 0, at = Q.length; Me < at; Me++) {
                const lt = Q[Me], Lt = lt.object, Dt = lt.geometry, ot = lt.material, Re = lt.group;
                if (ot.side === Yi && Lt.layers.test(W.layers)) {
                  const $t = ot.side;
                  ot.side = _i, ot.needsUpdate = true, md(Lt, G, W, Dt, ot, Re), ot.side = $t, ot.needsUpdate = true, ke = true;
                }
              }
              ke === true && (B.updateMultisampleRenderTarget(ne), B.updateRenderTargetMipmap(ne));
            }
            y.setRenderTarget(me), y.setClearColor(Y, te), Ne !== void 0 && (W.viewport = Ne), y.toneMapping = Ee;
          }
          function fa(C, Q, G) {
            const W = Q.isScene === true ? Q.overrideMaterial : null;
            for (let O = 0, ne = C.length; O < ne; O++) {
              const de = C[O], me = de.object, Ee = de.geometry, Ne = de.group;
              let ke = de.material;
              ke.allowOverride === true && W !== null && (ke = W), me.layers.test(G.layers) && md(me, Q, G, Ee, ke, Ne);
            }
          }
          function md(C, Q, G, W, O, ne) {
            C.onBeforeRender(y, Q, G, W, O, ne), C.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), O.onBeforeRender(y, Q, G, W, C, ne), O.transparent === true && O.side === Yi && O.forceSinglePass === false ? (O.side = _i, O.needsUpdate = true, y.renderBufferDirect(G, Q, W, O, C, ne), O.side = Sn, O.needsUpdate = true, y.renderBufferDirect(G, Q, W, O, C, ne), O.side = Yi) : y.renderBufferDirect(G, Q, W, O, C, ne), C.onAfterRender(y, Q, G, W, O, ne);
          }
          function pa(C, Q, G) {
            Q.isScene !== true && (Q = St);
            const W = Ce.get(C), O = A.state.lights, ne = A.state.shadowsArray, de = O.state.version, me = Se.getParameters(C, O.state, ne, Q, G), Ee = Se.getProgramCacheKey(me);
            let Ne = W.programs;
            W.environment = C.isMeshStandardMaterial ? Q.environment : null, W.fog = Q.fog, W.envMap = (C.isMeshStandardMaterial ? z : v).get(C.envMap || W.environment), W.envMapRotation = W.environment !== null && C.envMap === null ? Q.environmentRotation : C.envMapRotation, Ne === void 0 && (C.addEventListener("dispose", We), Ne = /* @__PURE__ */ new Map(), W.programs = Ne);
            let ke = Ne.get(Ee);
            if (ke !== void 0) {
              if (W.currentProgram === ke && W.lightsStateVersion === de) return bd(C, me), ke;
            } else me.uniforms = Se.getUniforms(C), C.onBeforeCompile(me, y), ke = Se.acquireProgram(me, Ee), Ne.set(Ee, ke), W.uniforms = me.uniforms;
            const Me = W.uniforms;
            return (!C.isShaderMaterial && !C.isRawShaderMaterial || C.clipping === true) && (Me.clippingPlanes = se.uniform), bd(C, me), W.needsLights = $A(C), W.lightsStateVersion = de, W.needsLights && (Me.ambientLightColor.value = O.state.ambient, Me.lightProbe.value = O.state.probe, Me.directionalLights.value = O.state.directional, Me.directionalLightShadows.value = O.state.directionalShadow, Me.spotLights.value = O.state.spot, Me.spotLightShadows.value = O.state.spotShadow, Me.rectAreaLights.value = O.state.rectArea, Me.ltc_1.value = O.state.rectAreaLTC1, Me.ltc_2.value = O.state.rectAreaLTC2, Me.pointLights.value = O.state.point, Me.pointLightShadows.value = O.state.pointShadow, Me.hemisphereLights.value = O.state.hemi, Me.directionalShadowMap.value = O.state.directionalShadowMap, Me.directionalShadowMatrix.value = O.state.directionalShadowMatrix, Me.spotShadowMap.value = O.state.spotShadowMap, Me.spotLightMatrix.value = O.state.spotLightMatrix, Me.spotLightMap.value = O.state.spotLightMap, Me.pointShadowMap.value = O.state.pointShadowMap, Me.pointShadowMatrix.value = O.state.pointShadowMatrix), W.currentProgram = ke, W.uniformsList = null, ke;
          }
          function wd(C) {
            if (C.uniformsList === null) {
              const Q = C.currentProgram.getUniforms();
              C.uniformsList = oo.seqWithValue(Q.seq, C.uniforms);
            }
            return C.uniformsList;
          }
          function bd(C, Q) {
            const G = Ce.get(C);
            G.outputColorSpace = Q.outputColorSpace, G.batching = Q.batching, G.batchingColor = Q.batchingColor, G.instancing = Q.instancing, G.instancingColor = Q.instancingColor, G.instancingMorph = Q.instancingMorph, G.skinning = Q.skinning, G.morphTargets = Q.morphTargets, G.morphNormals = Q.morphNormals, G.morphColors = Q.morphColors, G.morphTargetsCount = Q.morphTargetsCount, G.numClippingPlanes = Q.numClippingPlanes, G.numIntersection = Q.numClipIntersection, G.vertexAlphas = Q.vertexAlphas, G.vertexTangents = Q.vertexTangents, G.toneMapping = Q.toneMapping;
          }
          function JA(C, Q, G, W, O) {
            Q.isScene !== true && (Q = St), B.resetTextureUnits();
            const ne = Q.fog, de = W.isMeshStandardMaterial ? Q.environment : null, me = D === null ? y.outputColorSpace : D.isXRRenderTarget === true ? D.texture.colorSpace : oi, Ee = (W.isMeshStandardMaterial ? z : v).get(W.envMap || de), Ne = W.vertexColors === true && !!G.attributes.color && G.attributes.color.itemSize === 4, ke = !!G.attributes.tangent && (!!W.normalMap || W.anisotropy > 0), Me = !!G.morphAttributes.position, at = !!G.morphAttributes.normal, lt = !!G.morphAttributes.color;
            let Lt = Gn;
            W.toneMapped && (D === null || D.isXRRenderTarget === true) && (Lt = y.toneMapping);
            const Dt = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color, ot = Dt !== void 0 ? Dt.length : 0, Re = Ce.get(W), $t = A.state.lights;
            if (ae === true && (be === true || C !== E)) {
              const ci = C === E && W.id === S;
              se.setState(W, C, ci);
            }
            let ht = false;
            W.version === Re.__version ? (Re.needsLights && Re.lightsStateVersion !== $t.state.version || Re.outputColorSpace !== me || O.isBatchedMesh && Re.batching === false || !O.isBatchedMesh && Re.batching === true || O.isBatchedMesh && Re.batchingColor === true && O.colorTexture === null || O.isBatchedMesh && Re.batchingColor === false && O.colorTexture !== null || O.isInstancedMesh && Re.instancing === false || !O.isInstancedMesh && Re.instancing === true || O.isSkinnedMesh && Re.skinning === false || !O.isSkinnedMesh && Re.skinning === true || O.isInstancedMesh && Re.instancingColor === true && O.instanceColor === null || O.isInstancedMesh && Re.instancingColor === false && O.instanceColor !== null || O.isInstancedMesh && Re.instancingMorph === true && O.morphTexture === null || O.isInstancedMesh && Re.instancingMorph === false && O.morphTexture !== null || Re.envMap !== Ee || W.fog === true && Re.fog !== ne || Re.numClippingPlanes !== void 0 && (Re.numClippingPlanes !== se.numPlanes || Re.numIntersection !== se.numIntersection) || Re.vertexAlphas !== Ne || Re.vertexTangents !== ke || Re.morphTargets !== Me || Re.morphNormals !== at || Re.morphColors !== lt || Re.toneMapping !== Lt || Re.morphTargetsCount !== ot) && (ht = true) : (ht = true, Re.__version = W.version);
            let Oi = Re.currentProgram;
            ht === true && (Oi = pa(W, Q, O));
            let xr = false, wi = false, fs = false;
            const Ct = Oi.getUniforms(), Ii = Re.uniforms;
            if (Ie.useProgram(Oi.program) && (xr = true, wi = true, fs = true), W.id !== S && (S = W.id, wi = true), xr || E !== C) {
              Ie.buffers.depth.getReversed() ? (le.copy(C.projectionMatrix), d_(le), u_(le), Ct.setValue(F, "projectionMatrix", le)) : Ct.setValue(F, "projectionMatrix", C.projectionMatrix), Ct.setValue(F, "viewMatrix", C.matrixWorldInverse);
              const Ai = Ct.map.cameraPosition;
              Ai !== void 0 && Ai.setValue(F, Ze.setFromMatrixPosition(C.matrixWorld)), $e.logarithmicDepthBuffer && Ct.setValue(F, "logDepthBufFC", 2 / (Math.log(C.far + 1) / Math.LN2)), (W.isMeshPhongMaterial || W.isMeshToonMaterial || W.isMeshLambertMaterial || W.isMeshBasicMaterial || W.isMeshStandardMaterial || W.isShaderMaterial) && Ct.setValue(F, "isOrthographic", C.isOrthographicCamera === true), E !== C && (E = C, wi = true, fs = true);
            }
            if (O.isSkinnedMesh) {
              Ct.setOptional(F, O, "bindMatrix"), Ct.setOptional(F, O, "bindMatrixInverse");
              const ci = O.skeleton;
              ci && (ci.boneTexture === null && ci.computeBoneTexture(), Ct.setValue(F, "boneTexture", ci.boneTexture, B));
            }
            O.isBatchedMesh && (Ct.setOptional(F, O, "batchingTexture"), Ct.setValue(F, "batchingTexture", O._matricesTexture, B), Ct.setOptional(F, O, "batchingIdTexture"), Ct.setValue(F, "batchingIdTexture", O._indirectTexture, B), Ct.setOptional(F, O, "batchingColorTexture"), O._colorsTexture !== null && Ct.setValue(F, "batchingColorTexture", O._colorsTexture, B));
            const Mi = G.morphAttributes;
            if ((Mi.position !== void 0 || Mi.normal !== void 0 || Mi.color !== void 0) && Ue.update(O, G, Oi), (wi || Re.receiveShadow !== O.receiveShadow) && (Re.receiveShadow = O.receiveShadow, Ct.setValue(F, "receiveShadow", O.receiveShadow)), W.isMeshGouraudMaterial && W.envMap !== null && (Ii.envMap.value = Ee, Ii.flipEnvMap.value = Ee.isCubeTexture && Ee.isRenderTargetTexture === false ? -1 : 1), W.isMeshStandardMaterial && W.envMap === null && Q.environment !== null && (Ii.envMapIntensity.value = Q.environmentIntensity), wi && (Ct.setValue(F, "toneMappingExposure", y.toneMappingExposure), Re.needsLights && ZA(Ii, fs), ne && W.fog === true && fe.refreshFogUniforms(Ii, ne), fe.refreshMaterialUniforms(Ii, W, V, Z, A.state.transmissionRenderTarget[C.id]), oo.upload(F, wd(Re), Ii, B)), W.isShaderMaterial && W.uniformsNeedUpdate === true && (oo.upload(F, wd(Re), Ii, B), W.uniformsNeedUpdate = false), W.isSpriteMaterial && Ct.setValue(F, "center", O.center), Ct.setValue(F, "modelViewMatrix", O.modelViewMatrix), Ct.setValue(F, "normalMatrix", O.normalMatrix), Ct.setValue(F, "modelMatrix", O.matrixWorld), W.isShaderMaterial || W.isRawShaderMaterial) {
              const ci = W.uniformsGroups;
              for (let Ai = 0, ec = ci.length; Ai < ec; Ai++) {
                const Xn = ci[Ai];
                N.update(Xn, Oi), N.bind(Xn, Oi);
              }
            }
            return Oi;
          }
          function ZA(C, Q) {
            C.ambientLightColor.needsUpdate = Q, C.lightProbe.needsUpdate = Q, C.directionalLights.needsUpdate = Q, C.directionalLightShadows.needsUpdate = Q, C.pointLights.needsUpdate = Q, C.pointLightShadows.needsUpdate = Q, C.spotLights.needsUpdate = Q, C.spotLightShadows.needsUpdate = Q, C.rectAreaLights.needsUpdate = Q, C.hemisphereLights.needsUpdate = Q;
          }
          function $A(C) {
            return C.isMeshLambertMaterial || C.isMeshToonMaterial || C.isMeshPhongMaterial || C.isMeshStandardMaterial || C.isShadowMaterial || C.isShaderMaterial && C.lights === true;
          }
          this.getActiveCubeFace = function() {
            return M;
          }, this.getActiveMipmapLevel = function() {
            return R;
          }, this.getRenderTarget = function() {
            return D;
          }, this.setRenderTargetTextures = function(C, Q, G) {
            const W = Ce.get(C);
            W.__autoAllocateDepthBuffer = C.resolveDepthBuffer === false, W.__autoAllocateDepthBuffer === false && (W.__useRenderToTexture = false), Ce.get(C.texture).__webglTexture = Q, Ce.get(C.depthTexture).__webglTexture = W.__autoAllocateDepthBuffer ? void 0 : G, W.__hasExternalTextures = true;
          }, this.setRenderTargetFramebuffer = function(C, Q) {
            const G = Ce.get(C);
            G.__webglFramebuffer = Q, G.__useDefaultFramebuffer = Q === void 0;
          };
          const eg = F.createFramebuffer();
          this.setRenderTarget = function(C, Q = 0, G = 0) {
            D = C, M = Q, R = G;
            let W = true, O = null, ne = false, de = false;
            if (C) {
              const Ee = Ce.get(C);
              if (Ee.__useDefaultFramebuffer !== void 0) Ie.bindFramebuffer(F.FRAMEBUFFER, null), W = false;
              else if (Ee.__webglFramebuffer === void 0) B.setupRenderTarget(C);
              else if (Ee.__hasExternalTextures) B.rebindTextures(C, Ce.get(C.texture).__webglTexture, Ce.get(C.depthTexture).__webglTexture);
              else if (C.depthBuffer) {
                const Me = C.depthTexture;
                if (Ee.__boundDepthTexture !== Me) {
                  if (Me !== null && Ce.has(Me) && (C.width !== Me.image.width || C.height !== Me.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  B.setupDepthRenderbuffer(C);
                }
              }
              const Ne = C.texture;
              (Ne.isData3DTexture || Ne.isDataArrayTexture || Ne.isCompressedArrayTexture) && (de = true);
              const ke = Ce.get(C).__webglFramebuffer;
              C.isWebGLCubeRenderTarget ? (Array.isArray(ke[Q]) ? O = ke[Q][G] : O = ke[Q], ne = true) : C.samples > 0 && B.useMultisampledRTT(C) === false ? O = Ce.get(C).__webglMultisampledFramebuffer : Array.isArray(ke) ? O = ke[G] : O = ke, P.copy(C.viewport), j.copy(C.scissor), H = C.scissorTest;
            } else P.copy(ve).multiplyScalar(V).floor(), j.copy(Pe).multiplyScalar(V).floor(), H = Ve;
            if (G !== 0 && (O = eg), Ie.bindFramebuffer(F.FRAMEBUFFER, O) && W && Ie.drawBuffers(C, O), Ie.viewport(P), Ie.scissor(j), Ie.setScissorTest(H), ne) {
              const Ee = Ce.get(C.texture);
              F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Ee.__webglTexture, G);
            } else if (de) {
              const Ee = Ce.get(C.texture), Ne = Q;
              F.framebufferTextureLayer(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ee.__webglTexture, G, Ne);
            } else if (C !== null && G !== 0) {
              const Ee = Ce.get(C.texture);
              F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, Ee.__webglTexture, G);
            }
            S = -1;
          }, this.readRenderTargetPixels = function(C, Q, G, W, O, ne, de) {
            if (!(C && C.isWebGLRenderTarget)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              return;
            }
            let me = Ce.get(C).__webglFramebuffer;
            if (C.isWebGLCubeRenderTarget && de !== void 0 && (me = me[de]), me) {
              Ie.bindFramebuffer(F.FRAMEBUFFER, me);
              try {
                const Ee = C.texture, Ne = Ee.format, ke = Ee.type;
                if (!$e.textureFormatReadable(Ne)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return;
                }
                if (!$e.textureTypeReadable(ke)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return;
                }
                Q >= 0 && Q <= C.width - W && G >= 0 && G <= C.height - O && F.readPixels(Q, G, W, O, qe.convert(Ne), qe.convert(ke), ne);
              } finally {
                const Ee = D !== null ? Ce.get(D).__webglFramebuffer : null;
                Ie.bindFramebuffer(F.FRAMEBUFFER, Ee);
              }
            }
          }, this.readRenderTargetPixelsAsync = async function(C, Q, G, W, O, ne, de) {
            if (!(C && C.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let me = Ce.get(C).__webglFramebuffer;
            if (C.isWebGLCubeRenderTarget && de !== void 0 && (me = me[de]), me) if (Q >= 0 && Q <= C.width - W && G >= 0 && G <= C.height - O) {
              Ie.bindFramebuffer(F.FRAMEBUFFER, me);
              const Ee = C.texture, Ne = Ee.format, ke = Ee.type;
              if (!$e.textureFormatReadable(Ne)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              if (!$e.textureTypeReadable(ke)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              const Me = F.createBuffer();
              F.bindBuffer(F.PIXEL_PACK_BUFFER, Me), F.bufferData(F.PIXEL_PACK_BUFFER, ne.byteLength, F.STREAM_READ), F.readPixels(Q, G, W, O, qe.convert(Ne), qe.convert(ke), 0);
              const at = D !== null ? Ce.get(D).__webglFramebuffer : null;
              Ie.bindFramebuffer(F.FRAMEBUFFER, at);
              const lt = F.fenceSync(F.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return F.flush(), await h_(F, lt, 4), F.bindBuffer(F.PIXEL_PACK_BUFFER, Me), F.getBufferSubData(F.PIXEL_PACK_BUFFER, 0, ne), F.deleteBuffer(Me), F.deleteSync(lt), ne;
            } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
          }, this.copyFramebufferToTexture = function(C, Q = null, G = 0) {
            const W = Math.pow(2, -G), O = Math.floor(C.image.width * W), ne = Math.floor(C.image.height * W), de = Q !== null ? Q.x : 0, me = Q !== null ? Q.y : 0;
            B.setTexture2D(C, 0), F.copyTexSubImage2D(F.TEXTURE_2D, G, 0, 0, de, me, O, ne), Ie.unbindTexture();
          };
          const tg = F.createFramebuffer(), ig = F.createFramebuffer();
          this.copyTextureToTexture = function(C, Q, G = null, W = null, O = 0, ne = null) {
            ne === null && (O !== 0 ? (so("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), ne = O, O = 0) : ne = 0);
            let de, me, Ee, Ne, ke, Me, at, lt, Lt;
            const Dt = C.isCompressedTexture ? C.mipmaps[ne] : C.image;
            if (G !== null) de = G.max.x - G.min.x, me = G.max.y - G.min.y, Ee = G.isBox3 ? G.max.z - G.min.z : 1, Ne = G.min.x, ke = G.min.y, Me = G.isBox3 ? G.min.z : 0;
            else {
              const Mi = Math.pow(2, -O);
              de = Math.floor(Dt.width * Mi), me = Math.floor(Dt.height * Mi), C.isDataArrayTexture ? Ee = Dt.depth : C.isData3DTexture ? Ee = Math.floor(Dt.depth * Mi) : Ee = 1, Ne = 0, ke = 0, Me = 0;
            }
            W !== null ? (at = W.x, lt = W.y, Lt = W.z) : (at = 0, lt = 0, Lt = 0);
            const ot = qe.convert(Q.format), Re = qe.convert(Q.type);
            let $t;
            Q.isData3DTexture ? (B.setTexture3D(Q, 0), $t = F.TEXTURE_3D) : Q.isDataArrayTexture || Q.isCompressedArrayTexture ? (B.setTexture2DArray(Q, 0), $t = F.TEXTURE_2D_ARRAY) : (B.setTexture2D(Q, 0), $t = F.TEXTURE_2D), F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, Q.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, Q.unpackAlignment);
            const ht = F.getParameter(F.UNPACK_ROW_LENGTH), Oi = F.getParameter(F.UNPACK_IMAGE_HEIGHT), xr = F.getParameter(F.UNPACK_SKIP_PIXELS), wi = F.getParameter(F.UNPACK_SKIP_ROWS), fs = F.getParameter(F.UNPACK_SKIP_IMAGES);
            F.pixelStorei(F.UNPACK_ROW_LENGTH, Dt.width), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, Dt.height), F.pixelStorei(F.UNPACK_SKIP_PIXELS, Ne), F.pixelStorei(F.UNPACK_SKIP_ROWS, ke), F.pixelStorei(F.UNPACK_SKIP_IMAGES, Me);
            const Ct = C.isDataArrayTexture || C.isData3DTexture, Ii = Q.isDataArrayTexture || Q.isData3DTexture;
            if (C.isDepthTexture) {
              const Mi = Ce.get(C), ci = Ce.get(Q), Ai = Ce.get(Mi.__renderTarget), ec = Ce.get(ci.__renderTarget);
              Ie.bindFramebuffer(F.READ_FRAMEBUFFER, Ai.__webglFramebuffer), Ie.bindFramebuffer(F.DRAW_FRAMEBUFFER, ec.__webglFramebuffer);
              for (let Xn = 0; Xn < Ee; Xn++) Ct && (F.framebufferTextureLayer(F.READ_FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ce.get(C).__webglTexture, O, Me + Xn), F.framebufferTextureLayer(F.DRAW_FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ce.get(Q).__webglTexture, ne, Lt + Xn)), F.blitFramebuffer(Ne, ke, de, me, at, lt, de, me, F.DEPTH_BUFFER_BIT, F.NEAREST);
              Ie.bindFramebuffer(F.READ_FRAMEBUFFER, null), Ie.bindFramebuffer(F.DRAW_FRAMEBUFFER, null);
            } else if (O !== 0 || C.isRenderTargetTexture || Ce.has(C)) {
              const Mi = Ce.get(C), ci = Ce.get(Q);
              Ie.bindFramebuffer(F.READ_FRAMEBUFFER, tg), Ie.bindFramebuffer(F.DRAW_FRAMEBUFFER, ig);
              for (let Ai = 0; Ai < Ee; Ai++) Ct ? F.framebufferTextureLayer(F.READ_FRAMEBUFFER, F.COLOR_ATTACHMENT0, Mi.__webglTexture, O, Me + Ai) : F.framebufferTexture2D(F.READ_FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, Mi.__webglTexture, O), Ii ? F.framebufferTextureLayer(F.DRAW_FRAMEBUFFER, F.COLOR_ATTACHMENT0, ci.__webglTexture, ne, Lt + Ai) : F.framebufferTexture2D(F.DRAW_FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_2D, ci.__webglTexture, ne), O !== 0 ? F.blitFramebuffer(Ne, ke, de, me, at, lt, de, me, F.COLOR_BUFFER_BIT, F.NEAREST) : Ii ? F.copyTexSubImage3D($t, ne, at, lt, Lt + Ai, Ne, ke, de, me) : F.copyTexSubImage2D($t, ne, at, lt, Ne, ke, de, me);
              Ie.bindFramebuffer(F.READ_FRAMEBUFFER, null), Ie.bindFramebuffer(F.DRAW_FRAMEBUFFER, null);
            } else Ii ? C.isDataTexture || C.isData3DTexture ? F.texSubImage3D($t, ne, at, lt, Lt, de, me, Ee, ot, Re, Dt.data) : Q.isCompressedArrayTexture ? F.compressedTexSubImage3D($t, ne, at, lt, Lt, de, me, Ee, ot, Dt.data) : F.texSubImage3D($t, ne, at, lt, Lt, de, me, Ee, ot, Re, Dt) : C.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D, ne, at, lt, de, me, ot, Re, Dt.data) : C.isCompressedTexture ? F.compressedTexSubImage2D(F.TEXTURE_2D, ne, at, lt, Dt.width, Dt.height, ot, Dt.data) : F.texSubImage2D(F.TEXTURE_2D, ne, at, lt, de, me, ot, Re, Dt);
            F.pixelStorei(F.UNPACK_ROW_LENGTH, ht), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, Oi), F.pixelStorei(F.UNPACK_SKIP_PIXELS, xr), F.pixelStorei(F.UNPACK_SKIP_ROWS, wi), F.pixelStorei(F.UNPACK_SKIP_IMAGES, fs), ne === 0 && Q.generateMipmaps && F.generateMipmap($t), Ie.unbindTexture();
          }, this.copyTextureToTexture3D = function(C, Q, G = null, W = null, O = 0) {
            return so('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(C, Q, G, W, O);
          }, this.initRenderTarget = function(C) {
            Ce.get(C).__webglFramebuffer === void 0 && B.setupRenderTarget(C);
          }, this.initTexture = function(C) {
            C.isCubeTexture ? B.setTextureCube(C, 0) : C.isData3DTexture ? B.setTexture3D(C, 0) : C.isDataArrayTexture || C.isCompressedArrayTexture ? B.setTexture2DArray(C, 0) : B.setTexture2D(C, 0), Ie.unbindTexture();
          }, this.resetState = function() {
            M = 0, R = 0, D = null, Ie.reset(), bt.reset();
          }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        get coordinateSystem() {
          return xn;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(e) {
          this._outputColorSpace = e;
          const t = this.getContext();
          t.drawingBufferColorSpace = ze._getDrawingBufferColorSpace(e), t.unpackColorSpace = ze._getUnpackColorSpace();
        }
      }
      const Xu = "./shaders/", Wx = [
        Xu + "grass.vert",
        Xu + "grass.frag"
      ], jx = [
        "grass"
      ], Xl = /* @__PURE__ */ new Map();
      async function qx() {
        const s = await Promise.all(Wx.map(Xx));
        for (let e = 0; e < s.length; e += 2) {
          const t = Math.floor(e / 2), i = jx[t];
          Xl.set(i + "_VS", s[e]), Xl.set(i + "_FS", s[e + 1]);
        }
      }
      async function Xx(s) {
        return fetch(s).then((e) => e.text());
      }
      class Yx {
        constructor() {
          this.maxGrassRadius = 400, this.grassMaskTexture = new Si().load("./textures/grass.jpg"), this.grassDiffTexture = new Si().load("./textures/grass_diffuse.jpg"), this.perlinNoiseTexture = new Si().load("./noise/perlin_noise.png"), this.emptyTexture = new sa(new Uint8Array([
            255,
            255,
            255,
            255
          ]), 1, 1, Wt), this.emptyTexture.needsUpdate = true;
        }
        shaderMaterial(e) {
          return new xm({
            uniforms: {
              time: {
                value: 0
              },
              grassMaskTexture: {
                value: this.grassMaskTexture
              },
              grassDiffTexture: {
                value: this.grassDiffTexture
              },
              perlinNoiseTexture: {
                value: this.perlinNoiseTexture
              },
              heightMap: {
                value: null
              },
              terrainHeightScale: {
                value: 1
              },
              terrainSize: {
                value: new oe(1, 1)
              },
              useHeightMap: {
                value: false
              },
              bladeHeightUniform: {
                value: 1
              },
              bladeWidthUniform: {
                value: 1
              },
              vegetationMaskTexture: {
                value: this.emptyTexture
              },
              vegetationMaskSize: {
                value: new oe(1, 1)
              },
              fog: true,
              fogColor: {
                value: new ue(16777215)
              },
              fogDensity: {
                value: 0
              },
              fogTime: {
                value: 0
              },
              grassRadius: {
                value: this.maxGrassRadius
              }
            },
            vertexShader: e.get("grass_VS"),
            fragmentShader: e.get("grass_FS"),
            side: Yi,
            transparent: true
          });
        }
      }
      function Gh(s, e = false) {
        const t = s[0].index !== null, i = new Set(Object.keys(s[0].attributes)), n = new Set(Object.keys(s[0].morphAttributes)), r = {}, a = {}, o = s[0].morphTargetsRelative, c = new Qt();
        let l = 0;
        for (let h = 0; h < s.length; ++h) {
          const d = s[h];
          let u = 0;
          if (t !== (d.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
          for (const f in d.attributes) {
            if (!i.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null;
            r[f] === void 0 && (r[f] = []), r[f].push(d.attributes[f]), u++;
          }
          if (u !== i.size) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". Make sure all geometries have the same number of attributes."), null;
          if (o !== d.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
          for (const f in d.morphAttributes) {
            if (!n.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ".  .morphAttributes must be consistent throughout all geometries."), null;
            a[f] === void 0 && (a[f] = []), a[f].push(d.morphAttributes[f]);
          }
          if (e) {
            let f;
            if (t) f = d.index.count;
            else if (d.attributes.position !== void 0) f = d.attributes.position.count;
            else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + h + ". The geometry must have either an index or a position attribute"), null;
            c.addGroup(l, f, h), l += f;
          }
        }
        if (t) {
          let h = 0;
          const d = [];
          for (let u = 0; u < s.length; ++u) {
            const f = s[u].index;
            for (let p = 0; p < f.count; ++p) d.push(f.getX(p) + h);
            h += s[u].attributes.position.count;
          }
          c.setIndex(d);
        }
        for (const h in r) {
          const d = Yu(r[h]);
          if (!d) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + h + " attribute."), null;
          c.setAttribute(h, d);
        }
        for (const h in a) {
          const d = a[h][0].length;
          if (d === 0) break;
          c.morphAttributes = c.morphAttributes || {}, c.morphAttributes[h] = [];
          for (let u = 0; u < d; ++u) {
            const f = [];
            for (let m = 0; m < a[h].length; ++m) f.push(a[h][m][u]);
            const p = Yu(f);
            if (!p) return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + h + " morphAttribute."), null;
            c.morphAttributes[h].push(p);
          }
        }
        return c;
      }
      function Yu(s) {
        let e, t, i, n = -1, r = 0;
        for (let l = 0; l < s.length; ++l) {
          const h = s[l];
          if (e === void 0 && (e = h.array.constructor), e !== h.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
          if (t === void 0 && (t = h.itemSize), t !== h.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
          if (i === void 0 && (i = h.normalized), i !== h.normalized) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
          if (n === -1 && (n = h.gpuType), n !== h.gpuType) return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
          r += h.count * t;
        }
        const a = new e(r), o = new ni(a, t, i);
        let c = 0;
        for (let l = 0; l < s.length; ++l) {
          const h = s[l];
          if (h.isInterleavedBufferAttribute) {
            const d = c / t;
            for (let u = 0, f = h.count; u < f; u++) for (let p = 0; p < t; p++) {
              const m = h.getComponent(u, p);
              o.setComponent(u + d, p, m);
            }
          } else a.set(h.array, c);
          c += h.count * t;
        }
        return n !== void 0 && (o.gpuType = n), o;
      }
      function Ku(s, e) {
        if (e === kg) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
        if (e === Ql || e === Kf) {
          let t = s.getIndex();
          if (t === null) {
            const a = [], o = s.getAttribute("position");
            if (o !== void 0) {
              for (let c = 0; c < o.count; c++) a.push(c);
              s.setIndex(a), t = s.getIndex();
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), s;
          }
          const i = t.count - 2, n = [];
          if (e === Ql) for (let a = 1; a <= i; a++) n.push(t.getX(0)), n.push(t.getX(a)), n.push(t.getX(a + 1));
          else for (let a = 0; a < i; a++) a % 2 === 0 ? (n.push(t.getX(a)), n.push(t.getX(a + 1)), n.push(t.getX(a + 2))) : (n.push(t.getX(a + 2)), n.push(t.getX(a + 1)), n.push(t.getX(a)));
          n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
          const r = s.clone();
          return r.setIndex(n), r.clearGroups(), r;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
      }
      class Kx extends Li {
        constructor(e, t) {
          var _a2;
          super(), this.minX = 0, this.maxX = 0, this.minZ = 0, this.maxZ = 0, this.instances = 2e5, this.w = 1315, this.d = 1300, this.h = 0, this.terrain = e, this.mapScaleFactor = {
            x: 1,
            y: 1,
            z: 1
          }, this.terrainHeightScale = 1, this.bladeHeight = 0.9, this.bladeWidth = 0.4, this.terrainPositions = [], this.positions = [], this.indices = [], this.uvs = [], this.angles = [], this.bladeHeights = [], this.grassMask = null, this.fog = (_a2 = e == null ? void 0 : e.parent) == null ? void 0 : _a2.fog, this.geo, this.particles, this.dirLight = t;
        }
        createParticles() {
          this.positions.push(4, -4, 0), this.positions.push(-4, -4, 0), this.positions.push(-4, 4, 0), this.positions.push(4, 4, 0), this.indices.push(0, 1, 2, 2, 3, 0), this.uvs.push(1, 0, 0, 0, 0, 1, 1, 1);
          for (let i = 0; i < this.instances; i++) {
            let n = Math.random() * this.w - this.w / 2, r = this.h, a = Math.random() * this.d - this.d / 2, o = Math.random() * 360, c = Ut.randFloat(0.7, 1.3);
            this.terrainPositions.push(n, r, a), this.angles.push(o), this.bladeHeights.push(c);
          }
          this.geo = new Qm(), this.geo.instanceCount = this.instances, this.geo.setAttribute("position", new _t(this.positions, 3)), this.geo.setAttribute("uv", new _t(this.uvs, 2)), this.geo.setIndex(new ni(new Uint16Array(this.indices), 1)), this.geo.setAttribute("terPos", new dr(new Float32Array(this.terrainPositions), 3)), this.geo.setAttribute("angle", new dr(new Float32Array(this.angles), 1)), this.geo.setAttribute("bladeHeight", new dr(new Float32Array(this.bladeHeights), 1)), this.geo.setAttribute("worldPos", new dr(new Float32Array(this.terrainPositions), 3));
          const t = new Yx(this.dirLight).shaderMaterial(Xl);
          this._setVegetationAreas(t), this.heightsFromTerrain(t), this.grassParticles = new yt(this.geo, t), this.grassParticles.castShadow = true, this.grassParticles.receiveShadow = true, this.grassParticles.frustumCulled = false, this.add(this.grassParticles);
        }
        async heightsFromTerrain(e) {
          const t = await this._createHeightTexture();
          if (!t) {
            console.error("\u274C Failed to generate height texture from terrain."), e.uniforms.useHeightMap.value = false;
            return;
          }
          t.minFilter = Rt, t.magFilter = Rt, t.wrapS = fi, t.wrapT = fi, t.needsUpdate = true, e.uniforms.heightMap.value = t, e.uniforms.terrainHeightScale.value = this.terrainHeightScale, e.uniforms.terrainSize.value = new oe(this.w, this.d), e.uniforms.useHeightMap.value = true, e.uniforms.minX = {
            value: this.minX
          }, e.uniforms.minZ = {
            value: this.minZ
          }, e.uniforms.bladeHeightUniform = {
            value: this.bladeHeight
          }, e.uniforms.bladeWidthUniform = {
            value: this.bladeWidth
          }, this.fog && (e.uniforms.fogColor = {
            value: this.fog.color
          }, e.uniforms.fogDensity = {
            value: this.fog.density
          });
        }
        _setVegetationAreas(e) {
          this.grassMask = new Si().load("./map/vegetation_map.jpeg"), this.grassMask.wrapS = this.grassMask.wrapT = fi, this.grassMask.minFilter = Rt, this.grassMask.magFilter = Rt, e.uniforms.vegetationMaskTexture.value = this.grassMask, e.uniforms.vegetationMaskSize.value = new oe(this.w * 1, this.d * 1);
        }
        getTerrainMesh() {
          if (!this.terrain) throw new Error("No mesh found");
          if (this.terrainMesh = this.terrain.getObjectByName("Plane"), !this.terrainMesh) throw new Error("\u274C Terrain 'Plane' not found!");
          let e = [];
          if (this.terrainMesh.type === "Mesh" ? e.push(this.terrainMesh) : e = this.terrainMesh.children.filter((r) => r.isMesh), e.length === 0) throw new Error("\u274C No meshes found inside 'Plane'!");
          const t = e.map((r) => {
            const a = r.geometry.clone().applyMatrix4(r.matrixWorld);
            return a.scale(this.mapScaleFactor.x, this.mapScaleFactor.y, this.mapScaleFactor.z), a;
          }), i = Gh(t, false);
          if (!i) throw new Error("\u274C Terrain mesh not found!");
          return new yt(i, new Ei({
            color: 65280
          }));
        }
        async _extractHeightData() {
          let i;
          try {
            i = this.getTerrainMesh();
          } catch (g) {
            return console.error(g.message), null;
          }
          const r = i.geometry.attributes.position.array, a = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
          for (let g = 0; g < r.length; g += 3) a.add(r[g]), o.add(r[g + 2]);
          const c = 100, l = 100, h = Math.min(...a), d = Math.max(...a), u = Math.min(...o), f = Math.max(...o), p = new Float32Array(c * l), m = new Float32Array(c * l).fill(0);
          for (let g = 0; g < r.length; g += 3) {
            const A = r[g], x = r[g + 2], b = r[g + 1] / 1 + 4, y = (A - h) / (d - h) || 1, I = (x - u) / (f - u) || 1, M = Math.floor(y * (c - 1)), D = Math.floor(I * (l - 1)) * c + M;
            p[D] += b, m[D] += 1;
          }
          for (let g = 0; g < p.length; g++) m[g] > 0 && (p[g] /= m[g]);
          return {
            heightData: p,
            sizeX: c,
            sizeZ: l,
            minX: h,
            minZ: u
          };
        }
        async _createHeightTexture() {
          const e = await this._extractHeightData();
          if (!e) return console.error("Failed to extract height data!"), null;
          const { heightData: t, sizeX: i, sizeZ: n, minX: r, minZ: a } = e;
          this.minX = r, this.minZ = a;
          const o = new sa(t, i, n, yn, ii);
          return o.needsUpdate = true, o;
        }
        update(e) {
          this.grassParticles.material.uniforms.time.value = e;
        }
      }
      const Jx = "/3d_resume/assets/rapier_wasm3d_bg-CcbIg-ps.wasm", Zx = async (s = {}, e) => {
        let t;
        if (e.startsWith("data:")) {
          const i = e.replace(/^data:.*?base64,/, "");
          let n;
          if (typeof Buffer == "function" && typeof Buffer.from == "function") n = Buffer.from(i, "base64");
          else if (typeof atob == "function") {
            const r = atob(i);
            n = new Uint8Array(r.length);
            for (let a = 0; a < r.length; a++) n[a] = r.charCodeAt(a);
          } else throw new Error("Cannot decode base64-encoded data URL");
          t = await WebAssembly.instantiate(n, s);
        } else {
          const i = await fetch(e), n = i.headers.get("Content-Type") || "";
          if ("instantiateStreaming" in WebAssembly && n.startsWith("application/wasm")) t = await WebAssembly.instantiateStreaming(i, s);
          else {
            const r = await i.arrayBuffer();
            t = await WebAssembly.instantiate(r, s);
          }
        }
        return t.instance.exports;
      };
      let _;
      function $x(s) {
        _ = s;
      }
      const it = new Array(128).fill(void 0);
      it.push(void 0, null, true, false);
      function dt(s) {
        return it[s];
      }
      let ks = it.length;
      function Ot(s) {
        ks === it.length && it.push(it.length + 1);
        const e = ks;
        return ks = it[e], it[e] = s, e;
      }
      function Hh(s, e) {
        try {
          return s.apply(this, e);
        } catch (t) {
          _.__wbindgen_export_0(Ot(t));
        }
      }
      function De(s) {
        return s == null;
      }
      let Nr = null;
      function Kt() {
        return (Nr === null || Nr.buffer.detached === true || Nr.buffer.detached === void 0 && Nr.buffer !== _.memory.buffer) && (Nr = new DataView(_.memory.buffer)), Nr;
      }
      function eE(s) {
        s < 132 || (it[s] = ks, ks = s);
      }
      function Js(s) {
        const e = dt(s);
        return eE(s), e;
      }
      const tE = typeof TextDecoder > "u" ? (0, module.require)("util").TextDecoder : TextDecoder;
      let Pp = new tE("utf-8", {
        ignoreBOM: true,
        fatal: true
      });
      Pp.decode();
      let Ya = null;
      function iE() {
        return (Ya === null || Ya.byteLength === 0) && (Ya = new Uint8Array(_.memory.buffer)), Ya;
      }
      function Lp(s, e) {
        return s = s >>> 0, Pp.decode(iE().subarray(s, s + e));
      }
      function nE() {
        let s, e;
        try {
          const n = _.__wbindgen_add_to_stack_pointer(-16);
          _.version(n);
          var t = Kt().getInt32(n + 4 * 0, true), i = Kt().getInt32(n + 4 * 1, true);
          return s = t, e = i, Lp(t, i);
        } finally {
          _.__wbindgen_add_to_stack_pointer(16), _.__wbindgen_export_1(s, e, 1);
        }
      }
      function L(s, e) {
        if (!(s instanceof e)) throw new Error(`expected instance of ${e.name}`);
      }
      let mt = 128;
      function It(s) {
        if (mt == 1) throw new Error("out of js stack");
        return it[--mt] = s, mt;
      }
      let Ka = null;
      function Fp() {
        return (Ka === null || Ka.byteLength === 0) && (Ka = new Float32Array(_.memory.buffer)), Ka;
      }
      function Ju(s, e) {
        return s = s >>> 0, Fp().subarray(s / 4, s / 4 + e);
      }
      let Ja = null;
      function kp() {
        return (Ja === null || Ja.byteLength === 0) && (Ja = new Uint32Array(_.memory.buffer)), Ja;
      }
      function rE(s, e) {
        return s = s >>> 0, kp().subarray(s / 4, s / 4 + e);
      }
      let xi = 0;
      function sr(s, e) {
        const t = e(s.length * 4, 4) >>> 0;
        return Fp().set(s, t / 4), xi = s.length, t;
      }
      function Za(s, e) {
        const t = e(s.length * 4, 4) >>> 0;
        return kp().set(s, t / 4), xi = s.length, t;
      }
      const Go = Object.freeze({
        LinX: 0,
        0: "LinX",
        LinY: 1,
        1: "LinY",
        LinZ: 2,
        2: "LinZ",
        AngX: 3,
        3: "AngX",
        AngY: 4,
        4: "AngY",
        AngZ: 5,
        5: "AngZ"
      }), qi = Object.freeze({
        Revolute: 0,
        0: "Revolute",
        Fixed: 1,
        1: "Fixed",
        Prismatic: 2,
        2: "Prismatic",
        Rope: 3,
        3: "Rope",
        Spring: 4,
        4: "Spring",
        Spherical: 5,
        5: "Spherical",
        Generic: 6,
        6: "Generic"
      }), ei = Object.freeze({
        Ball: 0,
        0: "Ball",
        Cuboid: 1,
        1: "Cuboid",
        Capsule: 2,
        2: "Capsule",
        Segment: 3,
        3: "Segment",
        Polyline: 4,
        4: "Polyline",
        Triangle: 5,
        5: "Triangle",
        TriMesh: 6,
        6: "TriMesh",
        HeightField: 7,
        7: "HeightField",
        Compound: 8,
        8: "Compound",
        ConvexPolyhedron: 9,
        9: "ConvexPolyhedron",
        Cylinder: 10,
        10: "Cylinder",
        Cone: 11,
        11: "Cone",
        RoundCuboid: 12,
        12: "RoundCuboid",
        RoundTriangle: 13,
        13: "RoundTriangle",
        RoundCylinder: 14,
        14: "RoundCylinder",
        RoundCone: 15,
        15: "RoundCone",
        RoundConvexPolyhedron: 16,
        16: "RoundConvexPolyhedron",
        HalfSpace: 17,
        17: "HalfSpace"
      }), Nc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawbroadphase_free(s >>> 0, 1));
      class wr {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(wr.prototype);
          return t.__wbg_ptr = e, Nc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Nc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawbroadphase_free(e, 0);
        }
        constructor() {
          const e = _.rawbroadphase_new();
          return this.__wbg_ptr = e >>> 0, Nc.register(this, this.__wbg_ptr, this), this;
        }
      }
      const Zu = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawccdsolver_free(s >>> 0, 1));
      class Yl {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Zu.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawccdsolver_free(e, 0);
        }
        constructor() {
          const e = _.rawccdsolver_new();
          return this.__wbg_ptr = e >>> 0, Zu.register(this, this.__wbg_ptr, this), this;
        }
      }
      const $u = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcharactercollision_free(s >>> 0, 1));
      class Up {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, $u.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawcharactercollision_free(e, 0);
        }
        constructor() {
          const e = _.rawcharactercollision_new();
          return this.__wbg_ptr = e >>> 0, $u.register(this, this.__wbg_ptr, this), this;
        }
        handle() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        translationDeltaApplied() {
          const e = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return U.__wrap(e);
        }
        translationDeltaRemaining() {
          const e = _.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
          return U.__wrap(e);
        }
        toi() {
          return _.rawcharactercollision_toi(this.__wbg_ptr);
        }
        worldWitness1() {
          const e = _.rawcharactercollision_worldWitness1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        worldWitness2() {
          const e = _.rawcharactercollision_worldWitness2(this.__wbg_ptr);
          return U.__wrap(e);
        }
        worldNormal1() {
          const e = _.rawcharactercollision_worldNormal1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        worldNormal2() {
          const e = _.rawcharactercollision_worldNormal2(this.__wbg_ptr);
          return U.__wrap(e);
        }
      }
      const Qc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcolliderset_free(s >>> 0, 1));
      class Mt {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Mt.prototype);
          return t.__wbg_ptr = e, Qc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Qc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawcolliderset_free(e, 0);
        }
        coTranslation(e) {
          const t = _.rawcolliderset_coTranslation(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        coRotation(e) {
          const t = _.rawcolliderset_coRotation(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        coSetTranslation(e, t, i, n) {
          _.rawcolliderset_coSetTranslation(this.__wbg_ptr, e, t, i, n);
        }
        coSetTranslationWrtParent(e, t, i, n) {
          _.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, e, t, i, n);
        }
        coSetRotation(e, t, i, n, r) {
          _.rawcolliderset_coSetRotation(this.__wbg_ptr, e, t, i, n, r);
        }
        coSetRotationWrtParent(e, t, i, n, r) {
          _.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, e, t, i, n, r);
        }
        coIsSensor(e) {
          return _.rawcolliderset_coIsSensor(this.__wbg_ptr, e) !== 0;
        }
        coShapeType(e) {
          return _.rawcolliderset_coShapeType(this.__wbg_ptr, e);
        }
        coHalfspaceNormal(e) {
          const t = _.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        coHalfExtents(e) {
          const t = _.rawcolliderset_coHalfExtents(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        coSetHalfExtents(e, t) {
          L(t, U), _.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        coRadius(e) {
          const t = _.rawcolliderset_coRadius(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coSetRadius(e, t) {
          _.rawcolliderset_coSetRadius(this.__wbg_ptr, e, t);
        }
        coHalfHeight(e) {
          const t = _.rawcolliderset_coHalfHeight(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coSetHalfHeight(e, t) {
          _.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, e, t);
        }
        coRoundRadius(e) {
          const t = _.rawcolliderset_coRoundRadius(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coSetRoundRadius(e, t) {
          _.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, e, t);
        }
        coVertices(e) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coVertices(n, this.__wbg_ptr, e);
            var t = Kt().getInt32(n + 4 * 0, true), i = Kt().getInt32(n + 4 * 1, true);
            let r;
            return t !== 0 && (r = Ju(t, i).slice(), _.__wbindgen_export_1(t, i * 4, 4)), r;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coIndices(e) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coIndices(n, this.__wbg_ptr, e);
            var t = Kt().getInt32(n + 4 * 0, true), i = Kt().getInt32(n + 4 * 1, true);
            let r;
            return t !== 0 && (r = rE(t, i).slice(), _.__wbindgen_export_1(t, i * 4, 4)), r;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coTriMeshFlags(e) {
          const t = _.rawcolliderset_coTriMeshFlags(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coHeightFieldFlags(e) {
          const t = _.rawcolliderset_coHeightFieldFlags(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coHeightfieldHeights(e) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coHeightfieldHeights(n, this.__wbg_ptr, e);
            var t = Kt().getInt32(n + 4 * 0, true), i = Kt().getInt32(n + 4 * 1, true);
            let r;
            return t !== 0 && (r = Ju(t, i).slice(), _.__wbindgen_export_1(t, i * 4, 4)), r;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coHeightfieldScale(e) {
          const t = _.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        coHeightfieldNRows(e) {
          const t = _.rawcolliderset_coHeightfieldNRows(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coHeightfieldNCols(e) {
          const t = _.rawcolliderset_coHeightfieldNCols(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        coParent(e) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawcolliderset_coParent(n, this.__wbg_ptr, e);
            var t = Kt().getInt32(n + 4 * 0, true), i = Kt().getFloat64(n + 8 * 1, true);
            return t === 0 ? void 0 : i;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        coSetEnabled(e, t) {
          _.rawcolliderset_coSetEnabled(this.__wbg_ptr, e, t);
        }
        coIsEnabled(e) {
          return _.rawcolliderset_coIsEnabled(this.__wbg_ptr, e) !== 0;
        }
        coSetContactSkin(e, t) {
          _.rawcolliderset_coSetContactSkin(this.__wbg_ptr, e, t);
        }
        coContactSkin(e) {
          return _.rawcolliderset_coContactSkin(this.__wbg_ptr, e);
        }
        coFriction(e) {
          return _.rawcolliderset_coFriction(this.__wbg_ptr, e);
        }
        coRestitution(e) {
          return _.rawcolliderset_coRestitution(this.__wbg_ptr, e);
        }
        coDensity(e) {
          return _.rawcolliderset_coDensity(this.__wbg_ptr, e);
        }
        coMass(e) {
          return _.rawcolliderset_coMass(this.__wbg_ptr, e);
        }
        coVolume(e) {
          return _.rawcolliderset_coVolume(this.__wbg_ptr, e);
        }
        coCollisionGroups(e) {
          return _.rawcolliderset_coCollisionGroups(this.__wbg_ptr, e) >>> 0;
        }
        coSolverGroups(e) {
          return _.rawcolliderset_coSolverGroups(this.__wbg_ptr, e) >>> 0;
        }
        coActiveHooks(e) {
          return _.rawcolliderset_coActiveHooks(this.__wbg_ptr, e) >>> 0;
        }
        coActiveCollisionTypes(e) {
          return _.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, e);
        }
        coActiveEvents(e) {
          return _.rawcolliderset_coActiveEvents(this.__wbg_ptr, e) >>> 0;
        }
        coContactForceEventThreshold(e) {
          return _.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, e);
        }
        coContainsPoint(e, t) {
          return L(t, U), _.rawcolliderset_coContainsPoint(this.__wbg_ptr, e, t.__wbg_ptr) !== 0;
        }
        coCastShape(e, t, i, n, r, a, o, c, l) {
          L(t, U), L(i, Be), L(n, U), L(r, Ye), L(a, U);
          const h = _.rawcolliderset_coCastShape(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o, c, l);
          return h === 0 ? void 0 : qo.__wrap(h);
        }
        coCastCollider(e, t, i, n, r, a, o) {
          L(t, U), L(n, U);
          const c = _.rawcolliderset_coCastCollider(this.__wbg_ptr, e, t.__wbg_ptr, i, n.__wbg_ptr, r, a, o);
          return c === 0 ? void 0 : Ho.__wrap(c);
        }
        coIntersectsShape(e, t, i, n) {
          return L(t, Be), L(i, U), L(n, Ye), _.rawcolliderset_coIntersectsShape(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr) !== 0;
        }
        coContactShape(e, t, i, n, r) {
          L(t, Be), L(i, U), L(n, Ye);
          const a = _.rawcolliderset_coContactShape(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r);
          return a === 0 ? void 0 : Zs.__wrap(a);
        }
        coContactCollider(e, t, i) {
          const n = _.rawcolliderset_coContactCollider(this.__wbg_ptr, e, t, i);
          return n === 0 ? void 0 : Zs.__wrap(n);
        }
        coProjectPoint(e, t, i) {
          L(t, U);
          const n = _.rawcolliderset_coProjectPoint(this.__wbg_ptr, e, t.__wbg_ptr, i);
          return Vo.__wrap(n);
        }
        coIntersectsRay(e, t, i, n) {
          return L(t, U), L(i, U), _.rawcolliderset_coIntersectsRay(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n) !== 0;
        }
        coCastRay(e, t, i, n, r) {
          return L(t, U), L(i, U), _.rawcolliderset_coCastRay(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n, r);
        }
        coCastRayAndGetNormal(e, t, i, n, r) {
          L(t, U), L(i, U);
          const a = _.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n, r);
          return a === 0 ? void 0 : jo.__wrap(a);
        }
        coSetSensor(e, t) {
          _.rawcolliderset_coSetSensor(this.__wbg_ptr, e, t);
        }
        coSetRestitution(e, t) {
          _.rawcolliderset_coSetRestitution(this.__wbg_ptr, e, t);
        }
        coSetFriction(e, t) {
          _.rawcolliderset_coSetFriction(this.__wbg_ptr, e, t);
        }
        coFrictionCombineRule(e) {
          return _.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, e) >>> 0;
        }
        coSetFrictionCombineRule(e, t) {
          _.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, e, t);
        }
        coRestitutionCombineRule(e) {
          return _.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, e) >>> 0;
        }
        coSetRestitutionCombineRule(e, t) {
          _.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, e, t);
        }
        coSetCollisionGroups(e, t) {
          _.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, e, t);
        }
        coSetSolverGroups(e, t) {
          _.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, e, t);
        }
        coSetActiveHooks(e, t) {
          _.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, e, t);
        }
        coSetActiveEvents(e, t) {
          _.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, e, t);
        }
        coSetActiveCollisionTypes(e, t) {
          _.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, e, t);
        }
        coSetShape(e, t) {
          L(t, Be), _.rawcolliderset_coSetShape(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        coSetContactForceEventThreshold(e, t) {
          _.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, e, t);
        }
        coSetDensity(e, t) {
          _.rawcolliderset_coSetDensity(this.__wbg_ptr, e, t);
        }
        coSetMass(e, t) {
          _.rawcolliderset_coSetMass(this.__wbg_ptr, e, t);
        }
        coSetMassProperties(e, t, i, n, r) {
          L(i, U), L(n, U), L(r, Ye), _.rawcolliderset_coSetMassProperties(this.__wbg_ptr, e, t, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr);
        }
        constructor() {
          const e = _.rawcolliderset_new();
          return this.__wbg_ptr = e >>> 0, Qc.register(this, this.__wbg_ptr, this), this;
        }
        len() {
          return _.rawcolliderset_len(this.__wbg_ptr) >>> 0;
        }
        contains(e) {
          return _.rawcolliderset_contains(this.__wbg_ptr, e) !== 0;
        }
        createCollider(e, t, i, n, r, a, o, c, l, h, d, u, f, p, m, g, A, x, b, y, I, M, R, D, S) {
          try {
            const j = _.__wbindgen_add_to_stack_pointer(-16);
            L(t, Be), L(i, U), L(n, Ye), L(o, U), L(c, U), L(l, Ye), L(S, Et), _.rawcolliderset_createCollider(j, this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h, d, u, f, p, m, g, A, x, b, y, I, M, R, D, S.__wbg_ptr);
            var E = Kt().getInt32(j + 4 * 0, true), P = Kt().getFloat64(j + 8 * 1, true);
            return E === 0 ? void 0 : P;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
        remove(e, t, i, n) {
          L(t, Mn), L(i, Et), _.rawcolliderset_remove(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n);
        }
        isHandleValid(e) {
          return _.rawcolliderset_contains(this.__wbg_ptr, e) !== 0;
        }
        forEachColliderHandle(e) {
          try {
            _.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
      }
      const ef = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcollidershapecasthit_free(s >>> 0, 1));
      class Ho {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Ho.prototype);
          return t.__wbg_ptr = e, ef.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ef.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawcollidershapecasthit_free(e, 0);
        }
        colliderHandle() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        time_of_impact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        witness1() {
          const e = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        witness2() {
          const e = _.rawcollidershapecasthit_witness2(this.__wbg_ptr);
          return U.__wrap(e);
        }
        normal1() {
          const e = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return U.__wrap(e);
        }
        normal2() {
          const e = _.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);
          return U.__wrap(e);
        }
      }
      const tf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcontactforceevent_free(s >>> 0, 1));
      class Vh {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Vh.prototype);
          return t.__wbg_ptr = e, tf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, tf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawcontactforceevent_free(e, 0);
        }
        collider1() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        collider2() {
          return _.rawcontactforceevent_collider2(this.__wbg_ptr);
        }
        total_force() {
          const e = _.rawcontactforceevent_total_force(this.__wbg_ptr);
          return U.__wrap(e);
        }
        total_force_magnitude() {
          return _.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);
        }
        max_force_direction() {
          const e = _.rawcontactforceevent_max_force_direction(this.__wbg_ptr);
          return U.__wrap(e);
        }
        max_force_magnitude() {
          return _.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
        }
      }
      const nf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcontactmanifold_free(s >>> 0, 1));
      class Wh {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Wh.prototype);
          return t.__wbg_ptr = e, nf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, nf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawcontactmanifold_free(e, 0);
        }
        normal() {
          const e = _.rawcontactmanifold_normal(this.__wbg_ptr);
          return U.__wrap(e);
        }
        local_n1() {
          const e = _.rawcontactmanifold_local_n1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        local_n2() {
          const e = _.rawcontactmanifold_local_n2(this.__wbg_ptr);
          return U.__wrap(e);
        }
        subshape1() {
          return _.rawcontactmanifold_subshape1(this.__wbg_ptr) >>> 0;
        }
        subshape2() {
          return _.rawcontactmanifold_subshape2(this.__wbg_ptr) >>> 0;
        }
        num_contacts() {
          return _.rawcontactmanifold_num_contacts(this.__wbg_ptr) >>> 0;
        }
        contact_local_p1(e) {
          const t = _.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        contact_local_p2(e) {
          const t = _.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        contact_dist(e) {
          return _.rawcontactmanifold_contact_dist(this.__wbg_ptr, e);
        }
        contact_fid1(e) {
          return _.rawcontactmanifold_contact_fid1(this.__wbg_ptr, e) >>> 0;
        }
        contact_fid2(e) {
          return _.rawcontactmanifold_contact_fid2(this.__wbg_ptr, e) >>> 0;
        }
        contact_impulse(e) {
          return _.rawcontactmanifold_contact_impulse(this.__wbg_ptr, e);
        }
        contact_tangent_impulse_x(e) {
          return _.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, e);
        }
        contact_tangent_impulse_y(e) {
          return _.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, e);
        }
        num_solver_contacts() {
          return _.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr) >>> 0;
        }
        solver_contact_point(e) {
          const t = _.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        solver_contact_dist(e) {
          return _.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, e);
        }
        solver_contact_friction(e) {
          return _.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, e);
        }
        solver_contact_restitution(e) {
          return _.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, e);
        }
        solver_contact_tangent_velocity(e) {
          const t = _.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
      }
      const rf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawcontactpair_free(s >>> 0, 1));
      class jh {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(jh.prototype);
          return t.__wbg_ptr = e, rf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, rf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawcontactpair_free(e, 0);
        }
        collider1() {
          return _.rawcontactpair_collider1(this.__wbg_ptr);
        }
        collider2() {
          return _.rawcontactpair_collider2(this.__wbg_ptr);
        }
        numContactManifolds() {
          return _.rawcontactpair_numContactManifolds(this.__wbg_ptr) >>> 0;
        }
        contactManifold(e) {
          const t = _.rawcontactpair_contactManifold(this.__wbg_ptr, e);
          return t === 0 ? void 0 : Wh.__wrap(t);
        }
      }
      const sf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawdebugrenderpipeline_free(s >>> 0, 1));
      class sE {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, sf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawdebugrenderpipeline_free(e, 0);
        }
        constructor() {
          const e = _.rawdebugrenderpipeline_new();
          return this.__wbg_ptr = e >>> 0, sf.register(this, this.__wbg_ptr, this), this;
        }
        vertices() {
          const e = _.rawdebugrenderpipeline_vertices(this.__wbg_ptr);
          return Js(e);
        }
        colors() {
          const e = _.rawdebugrenderpipeline_colors(this.__wbg_ptr);
          return Js(e);
        }
        render(e, t, i, n, r) {
          L(e, Et), L(t, Mt), L(i, In), L(n, Tn), L(r, Vn), _.rawdebugrenderpipeline_render(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr);
        }
      }
      const af = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawdeserializedworld_free(s >>> 0, 1));
      class qh {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(qh.prototype);
          return t.__wbg_ptr = e, af.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, af.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawdeserializedworld_free(e, 0);
        }
        takeGravity() {
          const e = _.rawdeserializedworld_takeGravity(this.__wbg_ptr);
          return e === 0 ? void 0 : U.__wrap(e);
        }
        takeIntegrationParameters() {
          const e = _.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);
          return e === 0 ? void 0 : br.__wrap(e);
        }
        takeIslandManager() {
          const e = _.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);
          return e === 0 ? void 0 : Mn.__wrap(e);
        }
        takeBroadPhase() {
          const e = _.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);
          return e === 0 ? void 0 : wr.__wrap(e);
        }
        takeNarrowPhase() {
          const e = _.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);
          return e === 0 ? void 0 : Vn.__wrap(e);
        }
        takeBodies() {
          const e = _.rawdeserializedworld_takeBodies(this.__wbg_ptr);
          return e === 0 ? void 0 : Et.__wrap(e);
        }
        takeColliders() {
          const e = _.rawdeserializedworld_takeColliders(this.__wbg_ptr);
          return e === 0 ? void 0 : Mt.__wrap(e);
        }
        takeImpulseJoints() {
          const e = _.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);
          return e === 0 ? void 0 : In.__wrap(e);
        }
        takeMultibodyJoints() {
          const e = _.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);
          return e === 0 ? void 0 : Tn.__wrap(e);
        }
      }
      const of = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawdynamicraycastvehiclecontroller_free(s >>> 0, 1));
      class aE {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, of.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawdynamicraycastvehiclecontroller_free(e, 0);
        }
        constructor(e) {
          const t = _.rawdynamicraycastvehiclecontroller_new(e);
          return this.__wbg_ptr = t >>> 0, of.register(this, this.__wbg_ptr, this), this;
        }
        current_vehicle_speed() {
          return _.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);
        }
        chassis() {
          return _.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);
        }
        index_up_axis() {
          return _.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr) >>> 0;
        }
        set_index_up_axis(e) {
          _.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, e);
        }
        index_forward_axis() {
          return _.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr) >>> 0;
        }
        set_index_forward_axis(e) {
          _.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, e);
        }
        add_wheel(e, t, i, n, r) {
          L(e, U), L(t, U), L(i, U), _.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n, r);
        }
        num_wheels() {
          return _.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr) >>> 0;
        }
        update_vehicle(e, t, i, n, r, a, o) {
          try {
            L(t, Et), L(i, Mt), L(n, Xh), _.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, De(a) ? 4294967297 : a >>> 0, It(o));
          } finally {
            it[mt++] = void 0;
          }
        }
        wheel_chassis_connection_point_cs(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        set_wheel_chassis_connection_point_cs(e, t) {
          L(t, U), _.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        wheel_suspension_rest_length(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_suspension_rest_length(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, e, t);
        }
        wheel_max_suspension_travel(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_max_suspension_travel(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, e, t);
        }
        wheel_radius(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_radius(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_radius(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, e, t);
        }
        wheel_suspension_stiffness(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_suspension_stiffness(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, e, t);
        }
        wheel_suspension_compression(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_suspension_compression(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, e, t);
        }
        wheel_suspension_relaxation(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_suspension_relaxation(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, e, t);
        }
        wheel_max_suspension_force(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_max_suspension_force(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, e, t);
        }
        wheel_brake(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_brake(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_brake(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, e, t);
        }
        wheel_steering(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_steering(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_steering(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, e, t);
        }
        wheel_engine_force(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_engine_force(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_engine_force(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, e, t);
        }
        wheel_direction_cs(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        set_wheel_direction_cs(e, t) {
          L(t, U), _.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        wheel_axle_cs(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        set_wheel_axle_cs(e, t) {
          L(t, U), _.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        wheel_friction_slip(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_friction_slip(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_friction_slip(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, e, t);
        }
        wheel_side_friction_stiffness(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        set_wheel_side_friction_stiffness(e, t) {
          _.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness(this.__wbg_ptr, e, t);
        }
        wheel_rotation(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_rotation(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        wheel_forward_impulse(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        wheel_side_impulse(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_side_impulse(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        wheel_suspension_force(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_suspension_force(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        wheel_contact_normal_ws(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        wheel_contact_point_ws(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        wheel_suspension_length(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_suspension_length(this.__wbg_ptr, e);
          return t === 4294967297 ? void 0 : t;
        }
        wheel_hard_point_ws(e) {
          const t = _.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, e);
          return t === 0 ? void 0 : U.__wrap(t);
        }
        wheel_is_in_contact(e) {
          return _.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, e) !== 0;
        }
        wheel_ground_object(e) {
          try {
            const n = _.__wbindgen_add_to_stack_pointer(-16);
            _.rawdynamicraycastvehiclecontroller_wheel_ground_object(n, this.__wbg_ptr, e);
            var t = Kt().getInt32(n + 4 * 0, true), i = Kt().getFloat64(n + 8 * 1, true);
            return t === 0 ? void 0 : i;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16);
          }
        }
      }
      const cf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_raweventqueue_free(s >>> 0, 1));
      class Np {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, cf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_raweventqueue_free(e, 0);
        }
        constructor(e) {
          const t = _.raweventqueue_new(e);
          return this.__wbg_ptr = t >>> 0, cf.register(this, this.__wbg_ptr, this), this;
        }
        drainCollisionEvents(e) {
          try {
            _.raweventqueue_drainCollisionEvents(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
        drainContactForceEvents(e) {
          try {
            _.raweventqueue_drainContactForceEvents(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
        clear() {
          _.raweventqueue_clear(this.__wbg_ptr);
        }
      }
      const lf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawgenericjoint_free(s >>> 0, 1));
      class Zt {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Zt.prototype);
          return t.__wbg_ptr = e, lf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, lf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawgenericjoint_free(e, 0);
        }
        static generic(e, t, i, n) {
          L(e, U), L(t, U), L(i, U);
          const r = _.rawgenericjoint_generic(e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n);
          return r === 0 ? void 0 : Zt.__wrap(r);
        }
        static spring(e, t, i, n, r) {
          L(n, U), L(r, U);
          const a = _.rawgenericjoint_spring(e, t, i, n.__wbg_ptr, r.__wbg_ptr);
          return Zt.__wrap(a);
        }
        static rope(e, t, i) {
          L(t, U), L(i, U);
          const n = _.rawgenericjoint_rope(e, t.__wbg_ptr, i.__wbg_ptr);
          return Zt.__wrap(n);
        }
        static spherical(e, t) {
          L(e, U), L(t, U);
          const i = _.rawgenericjoint_spherical(e.__wbg_ptr, t.__wbg_ptr);
          return Zt.__wrap(i);
        }
        static prismatic(e, t, i, n, r, a) {
          L(e, U), L(t, U), L(i, U);
          const o = _.rawgenericjoint_prismatic(e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n, r, a);
          return o === 0 ? void 0 : Zt.__wrap(o);
        }
        static fixed(e, t, i, n) {
          L(e, U), L(t, Ye), L(i, U), L(n, Ye);
          const r = _.rawgenericjoint_fixed(e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr);
          return Zt.__wrap(r);
        }
        static revolute(e, t, i) {
          L(e, U), L(t, U), L(i, U);
          const n = _.rawgenericjoint_revolute(e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr);
          return n === 0 ? void 0 : Zt.__wrap(n);
        }
      }
      const Oc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawimpulsejointset_free(s >>> 0, 1));
      class In {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(In.prototype);
          return t.__wbg_ptr = e, Oc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Oc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawimpulsejointset_free(e, 0);
        }
        jointType(e) {
          return _.rawimpulsejointset_jointType(this.__wbg_ptr, e);
        }
        jointBodyHandle1(e) {
          return _.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, e);
        }
        jointBodyHandle2(e) {
          return _.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, e);
        }
        jointFrameX1(e) {
          const t = _.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        jointFrameX2(e) {
          const t = _.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        jointAnchor1(e) {
          const t = _.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        jointAnchor2(e) {
          const t = _.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        jointSetAnchor1(e, t) {
          L(t, U), _.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        jointSetAnchor2(e, t) {
          L(t, U), _.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        jointContactsEnabled(e) {
          return _.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, e) !== 0;
        }
        jointSetContactsEnabled(e, t) {
          _.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, e, t);
        }
        jointLimitsEnabled(e, t) {
          return _.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, e, t) !== 0;
        }
        jointLimitsMin(e, t) {
          return _.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, e, t);
        }
        jointLimitsMax(e, t) {
          return _.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, e, t);
        }
        jointSetLimits(e, t, i, n) {
          _.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, e, t, i, n);
        }
        jointConfigureMotorModel(e, t, i) {
          _.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, e, t, i);
        }
        jointConfigureMotorVelocity(e, t, i, n) {
          _.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, e, t, i, n);
        }
        jointConfigureMotorPosition(e, t, i, n, r) {
          _.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, e, t, i, n, r);
        }
        jointConfigureMotor(e, t, i, n, r, a) {
          _.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, e, t, i, n, r, a);
        }
        constructor() {
          const e = _.rawimpulsejointset_new();
          return this.__wbg_ptr = e >>> 0, Oc.register(this, this.__wbg_ptr, this), this;
        }
        createJoint(e, t, i, n) {
          return L(e, Zt), _.rawimpulsejointset_createJoint(this.__wbg_ptr, e.__wbg_ptr, t, i, n);
        }
        remove(e, t) {
          _.rawimpulsejointset_remove(this.__wbg_ptr, e, t);
        }
        len() {
          return _.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
        }
        contains(e) {
          return _.rawimpulsejointset_contains(this.__wbg_ptr, e) !== 0;
        }
        forEachJointHandle(e) {
          try {
            _.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
        forEachJointAttachedToRigidBody(e, t) {
          try {
            _.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, e, It(t));
          } finally {
            it[mt++] = void 0;
          }
        }
      }
      const zc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawintegrationparameters_free(s >>> 0, 1));
      class br {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(br.prototype);
          return t.__wbg_ptr = e, zc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, zc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawintegrationparameters_free(e, 0);
        }
        constructor() {
          const e = _.rawintegrationparameters_new();
          return this.__wbg_ptr = e >>> 0, zc.register(this, this.__wbg_ptr, this), this;
        }
        get dt() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        get contact_erp() {
          return _.rawintegrationparameters_contact_erp(this.__wbg_ptr);
        }
        get normalizedAllowedLinearError() {
          return _.rawintegrationparameters_normalizedAllowedLinearError(this.__wbg_ptr);
        }
        get normalizedPredictionDistance() {
          return _.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);
        }
        get numSolverIterations() {
          return _.rawintegrationparameters_numSolverIterations(this.__wbg_ptr) >>> 0;
        }
        get numAdditionalFrictionIterations() {
          return _.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr) >>> 0;
        }
        get numInternalPgsIterations() {
          return _.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr) >>> 0;
        }
        get minIslandSize() {
          return _.rawimpulsejointset_len(this.__wbg_ptr) >>> 0;
        }
        get maxCcdSubsteps() {
          return _.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr) >>> 0;
        }
        get lengthUnit() {
          return _.rawintegrationparameters_lengthUnit(this.__wbg_ptr);
        }
        set dt(e) {
          _.rawintegrationparameters_set_dt(this.__wbg_ptr, e);
        }
        set contact_natural_frequency(e) {
          _.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, e);
        }
        set normalizedAllowedLinearError(e) {
          _.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, e);
        }
        set normalizedPredictionDistance(e) {
          _.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, e);
        }
        set numSolverIterations(e) {
          _.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, e);
        }
        set numAdditionalFrictionIterations(e) {
          _.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, e);
        }
        set numInternalPgsIterations(e) {
          _.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, e);
        }
        set minIslandSize(e) {
          _.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, e);
        }
        set maxCcdSubsteps(e) {
          _.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, e);
        }
        set lengthUnit(e) {
          _.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, e);
        }
        switchToStandardPgsSolver() {
          _.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);
        }
        switchToSmallStepsPgsSolver() {
          _.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);
        }
        switchToSmallStepsPgsSolverWithoutWarmstart() {
          _.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);
        }
      }
      const Gc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawislandmanager_free(s >>> 0, 1));
      class Mn {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Mn.prototype);
          return t.__wbg_ptr = e, Gc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Gc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawislandmanager_free(e, 0);
        }
        constructor() {
          const e = _.rawislandmanager_new();
          return this.__wbg_ptr = e >>> 0, Gc.register(this, this.__wbg_ptr, this), this;
        }
        forEachActiveRigidBodyHandle(e) {
          try {
            _.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
      }
      const hf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawkinematiccharactercontroller_free(s >>> 0, 1));
      class oE {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, hf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawkinematiccharactercontroller_free(e, 0);
        }
        constructor(e) {
          const t = _.rawkinematiccharactercontroller_new(e);
          return this.__wbg_ptr = t >>> 0, hf.register(this, this.__wbg_ptr, this), this;
        }
        up() {
          const e = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return U.__wrap(e);
        }
        setUp(e) {
          L(e, U), _.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, e.__wbg_ptr);
        }
        normalNudgeFactor() {
          return _.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);
        }
        setNormalNudgeFactor(e) {
          _.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, e);
        }
        offset() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        setOffset(e) {
          _.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, e);
        }
        slideEnabled() {
          return _.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr) !== 0;
        }
        setSlideEnabled(e) {
          _.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, e);
        }
        autostepMaxHeight() {
          const e = _.rawkinematiccharactercontroller_autostepMaxHeight(this.__wbg_ptr);
          return e === 4294967297 ? void 0 : e;
        }
        autostepMinWidth() {
          const e = _.rawkinematiccharactercontroller_autostepMinWidth(this.__wbg_ptr);
          return e === 4294967297 ? void 0 : e;
        }
        autostepIncludesDynamicBodies() {
          const e = _.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);
          return e === 16777215 ? void 0 : e !== 0;
        }
        autostepEnabled() {
          return _.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr) !== 0;
        }
        enableAutostep(e, t, i) {
          _.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, e, t, i);
        }
        disableAutostep() {
          _.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);
        }
        maxSlopeClimbAngle() {
          return _.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);
        }
        setMaxSlopeClimbAngle(e) {
          _.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, e);
        }
        minSlopeSlideAngle() {
          return _.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);
        }
        setMinSlopeSlideAngle(e) {
          _.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, e);
        }
        snapToGroundDistance() {
          const e = _.rawkinematiccharactercontroller_snapToGroundDistance(this.__wbg_ptr);
          return e === 4294967297 ? void 0 : e;
        }
        enableSnapToGround(e) {
          _.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, e);
        }
        disableSnapToGround() {
          _.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);
        }
        snapToGroundEnabled() {
          return _.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr) !== 0;
        }
        computeColliderMovement(e, t, i, n, r, a, o, c, l, h, d) {
          try {
            L(t, Et), L(i, Mt), L(n, Xh), L(a, U), _.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a.__wbg_ptr, o, De(c) ? 4294967297 : Math.fround(c), l, De(h) ? 4294967297 : h >>> 0, It(d));
          } finally {
            it[mt++] = void 0;
          }
        }
        computedMovement() {
          const e = _.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);
          return U.__wrap(e);
        }
        computedGrounded() {
          return _.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr) !== 0;
        }
        numComputedCollisions() {
          return _.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr) >>> 0;
        }
        computedCollision(e, t) {
          return L(t, Up), _.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, e, t.__wbg_ptr) !== 0;
        }
      }
      const Hc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawmultibodyjointset_free(s >>> 0, 1));
      class Tn {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Tn.prototype);
          return t.__wbg_ptr = e, Hc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Hc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawmultibodyjointset_free(e, 0);
        }
        jointType(e) {
          return _.rawmultibodyjointset_jointType(this.__wbg_ptr, e);
        }
        jointFrameX1(e) {
          const t = _.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        jointFrameX2(e) {
          const t = _.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        jointAnchor1(e) {
          const t = _.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        jointAnchor2(e) {
          const t = _.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        jointContactsEnabled(e) {
          return _.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, e) !== 0;
        }
        jointSetContactsEnabled(e, t) {
          _.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, e, t);
        }
        jointLimitsEnabled(e, t) {
          return _.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, e, t) !== 0;
        }
        jointLimitsMin(e, t) {
          return _.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, e, t);
        }
        jointLimitsMax(e, t) {
          return _.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, e, t);
        }
        constructor() {
          const e = _.rawmultibodyjointset_new();
          return this.__wbg_ptr = e >>> 0, Hc.register(this, this.__wbg_ptr, this), this;
        }
        createJoint(e, t, i, n) {
          return L(e, Zt), _.rawmultibodyjointset_createJoint(this.__wbg_ptr, e.__wbg_ptr, t, i, n);
        }
        remove(e, t) {
          _.rawmultibodyjointset_remove(this.__wbg_ptr, e, t);
        }
        contains(e) {
          return _.rawmultibodyjointset_contains(this.__wbg_ptr, e) !== 0;
        }
        forEachJointHandle(e) {
          try {
            _.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
        forEachJointAttachedToRigidBody(e, t) {
          try {
            _.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, e, It(t));
          } finally {
            it[mt++] = void 0;
          }
        }
      }
      const Vc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawnarrowphase_free(s >>> 0, 1));
      class Vn {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Vn.prototype);
          return t.__wbg_ptr = e, Vc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Vc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawnarrowphase_free(e, 0);
        }
        constructor() {
          const e = _.rawnarrowphase_new();
          return this.__wbg_ptr = e >>> 0, Vc.register(this, this.__wbg_ptr, this), this;
        }
        contact_pairs_with(e, t) {
          _.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, e, Ot(t));
        }
        contact_pair(e, t) {
          const i = _.rawnarrowphase_contact_pair(this.__wbg_ptr, e, t);
          return i === 0 ? void 0 : jh.__wrap(i);
        }
        intersection_pairs_with(e, t) {
          _.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, e, Ot(t));
        }
        intersection_pair(e, t) {
          return _.rawnarrowphase_intersection_pair(this.__wbg_ptr, e, t) !== 0;
        }
      }
      const df = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawphysicspipeline_free(s >>> 0, 1));
      class cE {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, df.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawphysicspipeline_free(e, 0);
        }
        constructor() {
          const e = _.rawphysicspipeline_new();
          return this.__wbg_ptr = e >>> 0, df.register(this, this.__wbg_ptr, this), this;
        }
        step(e, t, i, n, r, a, o, c, l, h) {
          L(e, U), L(t, br), L(i, Mn), L(n, wr), L(r, Vn), L(a, Et), L(o, Mt), L(c, In), L(l, Tn), L(h, Yl), _.rawphysicspipeline_step(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr);
        }
        stepWithEvents(e, t, i, n, r, a, o, c, l, h, d, u, f, p) {
          L(e, U), L(t, br), L(i, Mn), L(n, wr), L(r, Vn), L(a, Et), L(o, Mt), L(c, In), L(l, Tn), L(h, Yl), L(d, Np), _.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, d.__wbg_ptr, Ot(u), Ot(f), Ot(p));
        }
      }
      const uf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawpidcontroller_free(s >>> 0, 1));
      class lE {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, uf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawpidcontroller_free(e, 0);
        }
        constructor(e, t, i, n) {
          const r = _.rawpidcontroller_new(e, t, i, n);
          return this.__wbg_ptr = r >>> 0, uf.register(this, this.__wbg_ptr, this), this;
        }
        set_kp(e, t) {
          _.rawpidcontroller_set_kp(this.__wbg_ptr, e, t);
        }
        set_ki(e, t) {
          _.rawpidcontroller_set_ki(this.__wbg_ptr, e, t);
        }
        set_kd(e, t) {
          _.rawpidcontroller_set_kd(this.__wbg_ptr, e, t);
        }
        set_axes_mask(e) {
          _.rawpidcontroller_set_axes_mask(this.__wbg_ptr, e);
        }
        reset_integrals() {
          _.rawpidcontroller_reset_integrals(this.__wbg_ptr);
        }
        apply_linear_correction(e, t, i, n, r) {
          L(t, Et), L(n, U), L(r, U), _.rawpidcontroller_apply_linear_correction(this.__wbg_ptr, e, t.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
        }
        apply_angular_correction(e, t, i, n, r) {
          L(t, Et), L(n, Ye), L(r, U), _.rawpidcontroller_apply_angular_correction(this.__wbg_ptr, e, t.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
        }
        linear_correction(e, t, i, n, r) {
          L(t, Et), L(n, U), L(r, U);
          const a = _.rawpidcontroller_linear_correction(this.__wbg_ptr, e, t.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
          return U.__wrap(a);
        }
        angular_correction(e, t, i, n, r) {
          L(t, Et), L(n, Ye), L(r, U);
          const a = _.rawpidcontroller_angular_correction(this.__wbg_ptr, e, t.__wbg_ptr, i, n.__wbg_ptr, r.__wbg_ptr);
          return U.__wrap(a);
        }
      }
      const ff = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawpointcolliderprojection_free(s >>> 0, 1));
      class So {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(So.prototype);
          return t.__wbg_ptr = e, ff.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, ff.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawpointcolliderprojection_free(e, 0);
        }
        colliderHandle() {
          return _.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
        }
        point() {
          const e = _.rawpointcolliderprojection_point(this.__wbg_ptr);
          return U.__wrap(e);
        }
        isInside() {
          return _.rawpointcolliderprojection_isInside(this.__wbg_ptr) !== 0;
        }
        featureType() {
          return _.rawpointcolliderprojection_featureType(this.__wbg_ptr);
        }
        featureId() {
          const e = _.rawpointcolliderprojection_featureId(this.__wbg_ptr);
          return e === 4294967297 ? void 0 : e;
        }
      }
      const pf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawpointprojection_free(s >>> 0, 1));
      class Vo {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Vo.prototype);
          return t.__wbg_ptr = e, pf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, pf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawpointprojection_free(e, 0);
        }
        point() {
          const e = _.rawpointprojection_point(this.__wbg_ptr);
          return U.__wrap(e);
        }
        isInside() {
          return _.rawpointprojection_isInside(this.__wbg_ptr) !== 0;
        }
      }
      const Af = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawquerypipeline_free(s >>> 0, 1));
      class Xh {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Af.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawquerypipeline_free(e, 0);
        }
        constructor() {
          const e = _.rawquerypipeline_new();
          return this.__wbg_ptr = e >>> 0, Af.register(this, this.__wbg_ptr, this), this;
        }
        update(e) {
          L(e, Mt), _.rawquerypipeline_update(this.__wbg_ptr, e.__wbg_ptr);
        }
        castRay(e, t, i, n, r, a, o, c, l, h, d) {
          try {
            L(e, Et), L(t, Mt), L(i, U), L(n, U);
            const u = _.rawquerypipeline_castRay(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, o, De(c) ? 4294967297 : c >>> 0, !De(l), De(l) ? 0 : l, !De(h), De(h) ? 0 : h, It(d));
            return u === 0 ? void 0 : Yh.__wrap(u);
          } finally {
            it[mt++] = void 0;
          }
        }
        castRayAndGetNormal(e, t, i, n, r, a, o, c, l, h, d) {
          try {
            L(e, Et), L(t, Mt), L(i, U), L(n, U);
            const u = _.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, o, De(c) ? 4294967297 : c >>> 0, !De(l), De(l) ? 0 : l, !De(h), De(h) ? 0 : h, It(d));
            return u === 0 ? void 0 : Wo.__wrap(u);
          } finally {
            it[mt++] = void 0;
          }
        }
        intersectionsWithRay(e, t, i, n, r, a, o, c, l, h, d, u) {
          try {
            L(e, Et), L(t, Mt), L(i, U), L(n, U), _.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a, It(o), c, De(l) ? 4294967297 : l >>> 0, !De(h), De(h) ? 0 : h, !De(d), De(d) ? 0 : d, It(u));
          } finally {
            it[mt++] = void 0, it[mt++] = void 0;
          }
        }
        intersectionWithShape(e, t, i, n, r, a, o, c, l, h) {
          try {
            const f = _.__wbindgen_add_to_stack_pointer(-16);
            L(e, Et), L(t, Mt), L(i, U), L(n, Ye), L(r, Be), _.rawquerypipeline_intersectionWithShape(f, this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a, De(o) ? 4294967297 : o >>> 0, !De(c), De(c) ? 0 : c, !De(l), De(l) ? 0 : l, It(h));
            var d = Kt().getInt32(f + 4 * 0, true), u = Kt().getFloat64(f + 8 * 1, true);
            return d === 0 ? void 0 : u;
          } finally {
            _.__wbindgen_add_to_stack_pointer(16), it[mt++] = void 0;
          }
        }
        projectPoint(e, t, i, n, r, a, o, c, l) {
          try {
            L(e, Et), L(t, Mt), L(i, U);
            const h = _.rawquerypipeline_projectPoint(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n, r, De(a) ? 4294967297 : a >>> 0, !De(o), De(o) ? 0 : o, !De(c), De(c) ? 0 : c, It(l));
            return h === 0 ? void 0 : So.__wrap(h);
          } finally {
            it[mt++] = void 0;
          }
        }
        projectPointAndGetFeature(e, t, i, n, r, a, o, c) {
          try {
            L(e, Et), L(t, Mt), L(i, U);
            const l = _.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n, De(r) ? 4294967297 : r >>> 0, !De(a), De(a) ? 0 : a, !De(o), De(o) ? 0 : o, It(c));
            return l === 0 ? void 0 : So.__wrap(l);
          } finally {
            it[mt++] = void 0;
          }
        }
        intersectionsWithPoint(e, t, i, n, r, a, o, c, l) {
          try {
            L(e, Et), L(t, Mt), L(i, U), _.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, It(n), r, De(a) ? 4294967297 : a >>> 0, !De(o), De(o) ? 0 : o, !De(c), De(c) ? 0 : c, It(l));
          } finally {
            it[mt++] = void 0, it[mt++] = void 0;
          }
        }
        castShape(e, t, i, n, r, a, o, c, l, h, d, u, f, p) {
          try {
            L(e, Et), L(t, Mt), L(i, U), L(n, Ye), L(r, U), L(a, Be);
            const m = _.rawquerypipeline_castShape(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o, c, l, h, De(d) ? 4294967297 : d >>> 0, !De(u), De(u) ? 0 : u, !De(f), De(f) ? 0 : f, It(p));
            return m === 0 ? void 0 : Ho.__wrap(m);
          } finally {
            it[mt++] = void 0;
          }
        }
        intersectionsWithShape(e, t, i, n, r, a, o, c, l, h, d) {
          try {
            L(e, Et), L(t, Mt), L(i, U), L(n, Ye), L(r, Be), _.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, It(a), o, De(c) ? 4294967297 : c >>> 0, !De(l), De(l) ? 0 : l, !De(h), De(h) ? 0 : h, It(d));
          } finally {
            it[mt++] = void 0, it[mt++] = void 0;
          }
        }
        collidersWithAabbIntersectingAabb(e, t, i) {
          try {
            L(e, U), L(t, U), _.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, It(i));
          } finally {
            it[mt++] = void 0;
          }
        }
      }
      const gf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawraycolliderhit_free(s >>> 0, 1));
      class Yh {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Yh.prototype);
          return t.__wbg_ptr = e, gf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, gf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawraycolliderhit_free(e, 0);
        }
        colliderHandle() {
          return _.rawcharactercollision_handle(this.__wbg_ptr);
        }
        timeOfImpact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
      }
      const _f = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawraycolliderintersection_free(s >>> 0, 1));
      class Wo {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Wo.prototype);
          return t.__wbg_ptr = e, _f.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, _f.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawraycolliderintersection_free(e, 0);
        }
        colliderHandle() {
          return _.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);
        }
        normal() {
          const e = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        time_of_impact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        featureType() {
          return _.rawpointcolliderprojection_featureType(this.__wbg_ptr);
        }
        featureId() {
          const e = _.rawpointcolliderprojection_featureId(this.__wbg_ptr);
          return e === 4294967297 ? void 0 : e;
        }
      }
      const mf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawrayintersection_free(s >>> 0, 1));
      class jo {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(jo.prototype);
          return t.__wbg_ptr = e, mf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, mf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawrayintersection_free(e, 0);
        }
        normal() {
          const e = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        time_of_impact() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        featureType() {
          return _.rawpointcolliderprojection_featureType(this.__wbg_ptr);
        }
        featureId() {
          const e = _.rawpointcolliderprojection_featureId(this.__wbg_ptr);
          return e === 4294967297 ? void 0 : e;
        }
      }
      const Wc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawrigidbodyset_free(s >>> 0, 1));
      class Et {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Et.prototype);
          return t.__wbg_ptr = e, Wc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Wc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawrigidbodyset_free(e, 0);
        }
        rbTranslation(e) {
          const t = _.rawrigidbodyset_rbTranslation(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbRotation(e) {
          const t = _.rawrigidbodyset_rbRotation(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        rbSleep(e) {
          _.rawrigidbodyset_rbSleep(this.__wbg_ptr, e);
        }
        rbIsSleeping(e) {
          return _.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, e) !== 0;
        }
        rbIsMoving(e) {
          return _.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, e) !== 0;
        }
        rbNextTranslation(e) {
          const t = _.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbNextRotation(e) {
          const t = _.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        rbSetTranslation(e, t, i, n, r) {
          _.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, e, t, i, n, r);
        }
        rbSetRotation(e, t, i, n, r, a) {
          _.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, e, t, i, n, r, a);
        }
        rbSetLinvel(e, t, i) {
          L(t, U), _.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, e, t.__wbg_ptr, i);
        }
        rbSetAngvel(e, t, i) {
          L(t, U), _.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, e, t.__wbg_ptr, i);
        }
        rbSetNextKinematicTranslation(e, t, i, n) {
          _.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, e, t, i, n);
        }
        rbSetNextKinematicRotation(e, t, i, n, r) {
          _.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, e, t, i, n, r);
        }
        rbRecomputeMassPropertiesFromColliders(e, t) {
          L(t, Mt), _.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, e, t.__wbg_ptr);
        }
        rbSetAdditionalMass(e, t, i) {
          _.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, e, t, i);
        }
        rbSetAdditionalMassProperties(e, t, i, n, r, a) {
          L(i, U), L(n, U), L(r, Ye), _.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, e, t, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a);
        }
        rbLinvel(e) {
          const t = _.rawrigidbodyset_rbLinvel(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbAngvel(e) {
          const t = _.rawrigidbodyset_rbAngvel(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbLockTranslations(e, t, i) {
          _.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, e, t, i);
        }
        rbSetEnabledTranslations(e, t, i, n, r) {
          _.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, e, t, i, n, r);
        }
        rbLockRotations(e, t, i) {
          _.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, e, t, i);
        }
        rbSetEnabledRotations(e, t, i, n, r) {
          _.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, e, t, i, n, r);
        }
        rbDominanceGroup(e) {
          return _.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, e);
        }
        rbSetDominanceGroup(e, t) {
          _.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, e, t);
        }
        rbEnableCcd(e, t) {
          _.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, e, t);
        }
        rbSetSoftCcdPrediction(e, t) {
          _.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, e, t);
        }
        rbMass(e) {
          return _.rawrigidbodyset_rbMass(this.__wbg_ptr, e);
        }
        rbInvMass(e) {
          return _.rawrigidbodyset_rbInvMass(this.__wbg_ptr, e);
        }
        rbEffectiveInvMass(e) {
          const t = _.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbLocalCom(e) {
          const t = _.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbWorldCom(e) {
          const t = _.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbInvPrincipalInertiaSqrt(e) {
          const t = _.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbPrincipalInertiaLocalFrame(e) {
          const t = _.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, e);
          return Ye.__wrap(t);
        }
        rbPrincipalInertia(e) {
          const t = _.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbEffectiveWorldInvInertiaSqrt(e) {
          const t = _.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, e);
          return Co.__wrap(t);
        }
        rbEffectiveAngularInertia(e) {
          const t = _.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, e);
          return Co.__wrap(t);
        }
        rbWakeUp(e) {
          _.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, e);
        }
        rbIsCcdEnabled(e) {
          return _.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, e) !== 0;
        }
        rbSoftCcdPrediction(e) {
          return _.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, e);
        }
        rbNumColliders(e) {
          return _.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, e) >>> 0;
        }
        rbCollider(e, t) {
          return _.rawrigidbodyset_rbCollider(this.__wbg_ptr, e, t);
        }
        rbBodyType(e) {
          return _.rawrigidbodyset_rbBodyType(this.__wbg_ptr, e);
        }
        rbSetBodyType(e, t, i) {
          _.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, e, t, i);
        }
        rbIsFixed(e) {
          return _.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, e) !== 0;
        }
        rbIsKinematic(e) {
          return _.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, e) !== 0;
        }
        rbIsDynamic(e) {
          return _.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, e) !== 0;
        }
        rbLinearDamping(e) {
          return _.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, e);
        }
        rbAngularDamping(e) {
          return _.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, e);
        }
        rbSetLinearDamping(e, t) {
          _.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, e, t);
        }
        rbSetAngularDamping(e, t) {
          _.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, e, t);
        }
        rbSetEnabled(e, t) {
          _.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, e, t);
        }
        rbIsEnabled(e) {
          return _.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, e) !== 0;
        }
        rbGravityScale(e) {
          return _.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, e);
        }
        rbSetGravityScale(e, t, i) {
          _.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, e, t, i);
        }
        rbResetForces(e, t) {
          _.rawrigidbodyset_rbResetForces(this.__wbg_ptr, e, t);
        }
        rbResetTorques(e, t) {
          _.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, e, t);
        }
        rbAddForce(e, t, i) {
          L(t, U), _.rawrigidbodyset_rbAddForce(this.__wbg_ptr, e, t.__wbg_ptr, i);
        }
        rbApplyImpulse(e, t, i) {
          L(t, U), _.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, e, t.__wbg_ptr, i);
        }
        rbAddTorque(e, t, i) {
          L(t, U), _.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, e, t.__wbg_ptr, i);
        }
        rbApplyTorqueImpulse(e, t, i) {
          L(t, U), _.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, e, t.__wbg_ptr, i);
        }
        rbAddForceAtPoint(e, t, i, n) {
          L(t, U), L(i, U), _.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n);
        }
        rbApplyImpulseAtPoint(e, t, i, n) {
          L(t, U), L(i, U), _.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n);
        }
        rbAdditionalSolverIterations(e) {
          return _.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, e) >>> 0;
        }
        rbSetAdditionalSolverIterations(e, t) {
          _.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, e, t);
        }
        rbUserData(e) {
          return _.rawrigidbodyset_rbUserData(this.__wbg_ptr, e) >>> 0;
        }
        rbSetUserData(e, t) {
          _.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, e, t);
        }
        rbUserForce(e) {
          const t = _.rawrigidbodyset_rbUserForce(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        rbUserTorque(e) {
          const t = _.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, e);
          return U.__wrap(t);
        }
        constructor() {
          const e = _.rawrigidbodyset_new();
          return this.__wbg_ptr = e >>> 0, Wc.register(this, this.__wbg_ptr, this), this;
        }
        createRigidBody(e, t, i, n, r, a, o, c, l, h, d, u, f, p, m, g, A, x, b, y, I, M, R, D, S, E) {
          return L(t, U), L(i, Ye), L(o, U), L(c, U), L(l, U), L(h, U), L(d, Ye), _.rawrigidbodyset_createRigidBody(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n, r, a, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr, h.__wbg_ptr, d.__wbg_ptr, u, f, p, m, g, A, x, b, y, I, M, R, D, S, E);
        }
        remove(e, t, i, n, r) {
          L(t, Mn), L(i, Mt), L(n, In), L(r, Tn), _.rawrigidbodyset_remove(this.__wbg_ptr, e, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr);
        }
        len() {
          return _.rawcolliderset_len(this.__wbg_ptr) >>> 0;
        }
        contains(e) {
          return _.rawrigidbodyset_contains(this.__wbg_ptr, e) !== 0;
        }
        forEachRigidBodyHandle(e) {
          try {
            _.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, It(e));
          } finally {
            it[mt++] = void 0;
          }
        }
        propagateModifiedBodyPositionsToColliders(e) {
          L(e, Mt), _.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, e.__wbg_ptr);
        }
      }
      const jc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawrotation_free(s >>> 0, 1));
      class Ye {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Ye.prototype);
          return t.__wbg_ptr = e, jc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, jc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawrotation_free(e, 0);
        }
        constructor(e, t, i, n) {
          const r = _.rawrotation_new(e, t, i, n);
          return this.__wbg_ptr = r >>> 0, jc.register(this, this.__wbg_ptr, this), this;
        }
        static identity() {
          const e = _.rawrotation_identity();
          return Ye.__wrap(e);
        }
        get x() {
          return _.rawrotation_x(this.__wbg_ptr);
        }
        get y() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        get z() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        get w() {
          return _.rawrotation_w(this.__wbg_ptr);
        }
      }
      const wf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawsdpmatrix3_free(s >>> 0, 1));
      class Co {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Co.prototype);
          return t.__wbg_ptr = e, wf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, wf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawsdpmatrix3_free(e, 0);
        }
        elements() {
          const e = _.rawsdpmatrix3_elements(this.__wbg_ptr);
          return Js(e);
        }
      }
      const bf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawserializationpipeline_free(s >>> 0, 1));
      class hE {
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, bf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawserializationpipeline_free(e, 0);
        }
        constructor() {
          const e = _.rawserializationpipeline_new();
          return this.__wbg_ptr = e >>> 0, bf.register(this, this.__wbg_ptr, this), this;
        }
        serializeAll(e, t, i, n, r, a, o, c, l) {
          L(e, U), L(t, br), L(i, Mn), L(n, wr), L(r, Vn), L(a, Et), L(o, Mt), L(c, In), L(l, Tn);
          const h = _.rawserializationpipeline_serializeAll(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c.__wbg_ptr, l.__wbg_ptr);
          return Js(h);
        }
        deserializeAll(e) {
          const t = _.rawserializationpipeline_deserializeAll(this.__wbg_ptr, Ot(e));
          return t === 0 ? void 0 : qh.__wrap(t);
        }
      }
      const yf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawshape_free(s >>> 0, 1));
      class Be {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Be.prototype);
          return t.__wbg_ptr = e, yf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, yf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawshape_free(e, 0);
        }
        static cuboid(e, t, i) {
          const n = _.rawshape_cuboid(e, t, i);
          return Be.__wrap(n);
        }
        static roundCuboid(e, t, i, n) {
          const r = _.rawshape_roundCuboid(e, t, i, n);
          return Be.__wrap(r);
        }
        static ball(e) {
          const t = _.rawshape_ball(e);
          return Be.__wrap(t);
        }
        static halfspace(e) {
          L(e, U);
          const t = _.rawshape_halfspace(e.__wbg_ptr);
          return Be.__wrap(t);
        }
        static capsule(e, t) {
          const i = _.rawshape_capsule(e, t);
          return Be.__wrap(i);
        }
        static cylinder(e, t) {
          const i = _.rawshape_cylinder(e, t);
          return Be.__wrap(i);
        }
        static roundCylinder(e, t, i) {
          const n = _.rawshape_roundCylinder(e, t, i);
          return Be.__wrap(n);
        }
        static cone(e, t) {
          const i = _.rawshape_cone(e, t);
          return Be.__wrap(i);
        }
        static roundCone(e, t, i) {
          const n = _.rawshape_roundCone(e, t, i);
          return Be.__wrap(n);
        }
        static polyline(e, t) {
          const i = sr(e, _.__wbindgen_export_2), n = xi, r = Za(t, _.__wbindgen_export_2), a = xi, o = _.rawshape_polyline(i, n, r, a);
          return Be.__wrap(o);
        }
        static trimesh(e, t, i) {
          const n = sr(e, _.__wbindgen_export_2), r = xi, a = Za(t, _.__wbindgen_export_2), o = xi, c = _.rawshape_trimesh(n, r, a, o, i);
          return c === 0 ? void 0 : Be.__wrap(c);
        }
        static heightfield(e, t, i, n, r) {
          const a = sr(i, _.__wbindgen_export_2), o = xi;
          L(n, U);
          const c = _.rawshape_heightfield(e, t, a, o, n.__wbg_ptr, r);
          return Be.__wrap(c);
        }
        static segment(e, t) {
          L(e, U), L(t, U);
          const i = _.rawshape_segment(e.__wbg_ptr, t.__wbg_ptr);
          return Be.__wrap(i);
        }
        static triangle(e, t, i) {
          L(e, U), L(t, U), L(i, U);
          const n = _.rawshape_triangle(e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr);
          return Be.__wrap(n);
        }
        static roundTriangle(e, t, i, n) {
          L(e, U), L(t, U), L(i, U);
          const r = _.rawshape_roundTriangle(e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n);
          return Be.__wrap(r);
        }
        static convexHull(e) {
          const t = sr(e, _.__wbindgen_export_2), i = xi, n = _.rawshape_convexHull(t, i);
          return n === 0 ? void 0 : Be.__wrap(n);
        }
        static roundConvexHull(e, t) {
          const i = sr(e, _.__wbindgen_export_2), n = xi, r = _.rawshape_roundConvexHull(i, n, t);
          return r === 0 ? void 0 : Be.__wrap(r);
        }
        static convexMesh(e, t) {
          const i = sr(e, _.__wbindgen_export_2), n = xi, r = Za(t, _.__wbindgen_export_2), a = xi, o = _.rawshape_convexMesh(i, n, r, a);
          return o === 0 ? void 0 : Be.__wrap(o);
        }
        static roundConvexMesh(e, t, i) {
          const n = sr(e, _.__wbindgen_export_2), r = xi, a = Za(t, _.__wbindgen_export_2), o = xi, c = _.rawshape_roundConvexMesh(n, r, a, o, i);
          return c === 0 ? void 0 : Be.__wrap(c);
        }
        castShape(e, t, i, n, r, a, o, c, l, h) {
          L(e, U), L(t, Ye), L(i, U), L(n, Be), L(r, U), L(a, Ye), L(o, U);
          const d = _.rawshape_castShape(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a.__wbg_ptr, o.__wbg_ptr, c, l, h);
          return d === 0 ? void 0 : qo.__wrap(d);
        }
        intersectsShape(e, t, i, n, r) {
          return L(e, U), L(t, Ye), L(i, Be), L(n, U), L(r, Ye), _.rawshape_intersectsShape(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr) !== 0;
        }
        contactShape(e, t, i, n, r, a) {
          L(e, U), L(t, Ye), L(i, Be), L(n, U), L(r, Ye);
          const o = _.rawshape_contactShape(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r.__wbg_ptr, a);
          return o === 0 ? void 0 : Zs.__wrap(o);
        }
        containsPoint(e, t, i) {
          return L(e, U), L(t, Ye), L(i, U), _.rawshape_containsPoint(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr) !== 0;
        }
        projectPoint(e, t, i, n) {
          L(e, U), L(t, Ye), L(i, U);
          const r = _.rawshape_projectPoint(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n);
          return Vo.__wrap(r);
        }
        intersectsRay(e, t, i, n, r) {
          return L(e, U), L(t, Ye), L(i, U), L(n, U), _.rawshape_intersectsRay(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r) !== 0;
        }
        castRay(e, t, i, n, r, a) {
          return L(e, U), L(t, Ye), L(i, U), L(n, U), _.rawshape_castRay(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a);
        }
        castRayAndGetNormal(e, t, i, n, r, a) {
          L(e, U), L(t, Ye), L(i, U), L(n, U);
          const o = _.rawshape_castRayAndGetNormal(this.__wbg_ptr, e.__wbg_ptr, t.__wbg_ptr, i.__wbg_ptr, n.__wbg_ptr, r, a);
          return o === 0 ? void 0 : jo.__wrap(o);
        }
      }
      const xf = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawshapecasthit_free(s >>> 0, 1));
      class qo {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(qo.prototype);
          return t.__wbg_ptr = e, xf.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, xf.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawshapecasthit_free(e, 0);
        }
        time_of_impact() {
          return _.rawrotation_x(this.__wbg_ptr);
        }
        witness1() {
          const e = _.rawshapecasthit_witness1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        witness2() {
          const e = _.rawcontactforceevent_total_force(this.__wbg_ptr);
          return U.__wrap(e);
        }
        normal1() {
          const e = _.rawshapecasthit_normal1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        normal2() {
          const e = _.rawshapecasthit_normal2(this.__wbg_ptr);
          return U.__wrap(e);
        }
      }
      const Ef = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawshapecontact_free(s >>> 0, 1));
      class Zs {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(Zs.prototype);
          return t.__wbg_ptr = e, Ef.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, Ef.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawshapecontact_free(e, 0);
        }
        distance() {
          return _.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);
        }
        point1() {
          const e = _.rawpointprojection_point(this.__wbg_ptr);
          return U.__wrap(e);
        }
        point2() {
          const e = _.rawcollidershapecasthit_witness1(this.__wbg_ptr);
          return U.__wrap(e);
        }
        normal1() {
          const e = _.rawcollidershapecasthit_witness2(this.__wbg_ptr);
          return U.__wrap(e);
        }
        normal2() {
          const e = _.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);
          return U.__wrap(e);
        }
      }
      const qc = typeof FinalizationRegistry > "u" ? {
        register: () => {
        },
        unregister: () => {
        }
      } : new FinalizationRegistry((s) => _.__wbg_rawvector_free(s >>> 0, 1));
      class U {
        static __wrap(e) {
          e = e >>> 0;
          const t = Object.create(U.prototype);
          return t.__wbg_ptr = e, qc.register(t, t.__wbg_ptr, t), t;
        }
        __destroy_into_raw() {
          const e = this.__wbg_ptr;
          return this.__wbg_ptr = 0, qc.unregister(this), e;
        }
        free() {
          const e = this.__destroy_into_raw();
          _.__wbg_rawvector_free(e, 0);
        }
        static zero() {
          const e = _.rawvector_zero();
          return U.__wrap(e);
        }
        constructor(e, t, i) {
          const n = _.rawvector_new(e, t, i);
          return this.__wbg_ptr = n >>> 0, qc.register(this, this.__wbg_ptr, this), this;
        }
        get x() {
          return _.rawrotation_x(this.__wbg_ptr);
        }
        set x(e) {
          _.rawvector_set_x(this.__wbg_ptr, e);
        }
        get y() {
          return _.rawintegrationparameters_dt(this.__wbg_ptr);
        }
        set y(e) {
          _.rawintegrationparameters_set_dt(this.__wbg_ptr, e);
        }
        get z() {
          return _.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);
        }
        set z(e) {
          _.rawvector_set_z(this.__wbg_ptr, e);
        }
        xyz() {
          const e = _.rawvector_xyz(this.__wbg_ptr);
          return U.__wrap(e);
        }
        yxz() {
          const e = _.rawvector_yxz(this.__wbg_ptr);
          return U.__wrap(e);
        }
        zxy() {
          const e = _.rawvector_zxy(this.__wbg_ptr);
          return U.__wrap(e);
        }
        xzy() {
          const e = _.rawvector_xzy(this.__wbg_ptr);
          return U.__wrap(e);
        }
        yzx() {
          const e = _.rawvector_yzx(this.__wbg_ptr);
          return U.__wrap(e);
        }
        zyx() {
          const e = _.rawvector_zyx(this.__wbg_ptr);
          return U.__wrap(e);
        }
      }
      function dE(s, e, t, i) {
        const n = dt(s).bind(dt(e), dt(t), dt(i));
        return Ot(n);
      }
      function uE(s) {
        const e = dt(s).buffer;
        return Ot(e);
      }
      function fE() {
        return Hh(function(s, e, t) {
          const i = dt(s).call(dt(e), dt(t));
          return Ot(i);
        }, arguments);
      }
      function pE() {
        return Hh(function(s, e, t, i) {
          const n = dt(s).call(dt(e), dt(t), dt(i));
          return Ot(n);
        }, arguments);
      }
      function AE() {
        return Hh(function(s, e, t, i, n) {
          const r = dt(s).call(dt(e), dt(t), dt(i), dt(n));
          return Ot(r);
        }, arguments);
      }
      function gE(s) {
        return dt(s).length;
      }
      function _E(s) {
        return dt(s).length;
      }
      function mE(s) {
        const e = new Uint8Array(dt(s));
        return Ot(e);
      }
      function wE(s, e, t) {
        const i = new Uint8Array(dt(s), e >>> 0, t >>> 0);
        return Ot(i);
      }
      function bE(s, e, t) {
        const i = new Float32Array(dt(s), e >>> 0, t >>> 0);
        return Ot(i);
      }
      function yE(s) {
        const e = new Float32Array(s >>> 0);
        return Ot(e);
      }
      function xE(s) {
        const e = Vh.__wrap(s);
        return Ot(e);
      }
      function EE(s) {
        const e = Wo.__wrap(s);
        return Ot(e);
      }
      function vE(s, e, t) {
        dt(s).set(dt(e), t >>> 0);
      }
      function SE(s, e, t) {
        dt(s).set(dt(e), t >>> 0);
      }
      function CE(s) {
        const e = dt(s);
        return typeof e == "boolean" ? e ? 1 : 0 : 2;
      }
      function IE(s) {
        return typeof dt(s) == "function";
      }
      function ME() {
        const s = _.memory;
        return Ot(s);
      }
      function TE(s, e) {
        const t = dt(e), i = typeof t == "number" ? t : void 0;
        Kt().setFloat64(s + 8 * 1, De(i) ? 0 : i, true), Kt().setInt32(s + 4 * 0, !De(i), true);
      }
      function RE(s) {
        return Ot(s);
      }
      function BE(s) {
        Js(s);
      }
      function DE(s, e) {
        throw new Error(Lp(s, e));
      }
      URL = globalThis.URL;
      const w = await Zx({
        "./rapier_wasm3d_bg.js": {
          __wbindgen_number_new: RE,
          __wbindgen_boolean_get: CE,
          __wbindgen_object_drop_ref: BE,
          __wbindgen_number_get: TE,
          __wbindgen_is_function: IE,
          __wbg_rawraycolliderintersection_new: EE,
          __wbg_rawcontactforceevent_new: xE,
          __wbg_call_7cccdd69e0791ae2: fE,
          __wbg_call_833bed5770ea2041: pE,
          __wbg_call_b8adc8b1d0a0d8eb: AE,
          __wbg_bind_c8359b1cba058168: dE,
          __wbg_buffer_609cc3eee51ed158: uE,
          __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a: wE,
          __wbg_new_a12002a7f91c75be: mE,
          __wbg_set_65595bdd868b3009: SE,
          __wbg_length_a446193dc22c12f8: _E,
          __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354: bE,
          __wbg_set_10bad9bee0e9c58b: vE,
          __wbg_length_3b4f022188ae8db6: gE,
          __wbg_newwithlength_5a5efe313cfd59f1: yE,
          __wbindgen_throw: DE,
          __wbindgen_memory: ME
        }
      }, Jx), PE = w.memory, LE = w.version, FE = w.__wbg_rawkinematiccharactercontroller_free, kE = w.rawkinematiccharactercontroller_new, UE = w.rawkinematiccharactercontroller_setUp, NE = w.rawkinematiccharactercontroller_normalNudgeFactor, QE = w.rawkinematiccharactercontroller_setNormalNudgeFactor, OE = w.rawkinematiccharactercontroller_setOffset, zE = w.rawkinematiccharactercontroller_slideEnabled, GE = w.rawkinematiccharactercontroller_setSlideEnabled, HE = w.rawkinematiccharactercontroller_autostepMaxHeight, VE = w.rawkinematiccharactercontroller_autostepMinWidth, WE = w.rawkinematiccharactercontroller_autostepIncludesDynamicBodies, jE = w.rawkinematiccharactercontroller_autostepEnabled, qE = w.rawkinematiccharactercontroller_enableAutostep, XE = w.rawkinematiccharactercontroller_disableAutostep, YE = w.rawkinematiccharactercontroller_maxSlopeClimbAngle, KE = w.rawkinematiccharactercontroller_setMaxSlopeClimbAngle, JE = w.rawkinematiccharactercontroller_minSlopeSlideAngle, ZE = w.rawkinematiccharactercontroller_setMinSlopeSlideAngle, $E = w.rawkinematiccharactercontroller_snapToGroundDistance, ev = w.rawkinematiccharactercontroller_enableSnapToGround, tv = w.rawkinematiccharactercontroller_disableSnapToGround, iv = w.rawkinematiccharactercontroller_snapToGroundEnabled, nv = w.rawkinematiccharactercontroller_computeColliderMovement, rv = w.rawkinematiccharactercontroller_computedMovement, sv = w.rawkinematiccharactercontroller_computedGrounded, av = w.rawkinematiccharactercontroller_numComputedCollisions, ov = w.rawkinematiccharactercontroller_computedCollision, cv = w.__wbg_rawcharactercollision_free, lv = w.rawcharactercollision_new, hv = w.rawcharactercollision_handle, dv = w.rawcharactercollision_translationDeltaApplied, uv = w.rawcharactercollision_translationDeltaRemaining, fv = w.rawcharactercollision_toi, pv = w.rawcharactercollision_worldWitness1, Av = w.rawcharactercollision_worldWitness2, gv = w.rawcharactercollision_worldNormal1, _v = w.rawcharactercollision_worldNormal2, mv = w.__wbg_rawpidcontroller_free, wv = w.rawpidcontroller_new, bv = w.rawpidcontroller_set_kp, yv = w.rawpidcontroller_set_ki, xv = w.rawpidcontroller_set_kd, Ev = w.rawpidcontroller_set_axes_mask, vv = w.rawpidcontroller_reset_integrals, Sv = w.rawpidcontroller_apply_linear_correction, Cv = w.rawpidcontroller_apply_angular_correction, Iv = w.rawpidcontroller_linear_correction, Mv = w.rawpidcontroller_angular_correction, Tv = w.__wbg_rawdynamicraycastvehiclecontroller_free, Rv = w.rawdynamicraycastvehiclecontroller_new, Bv = w.rawdynamicraycastvehiclecontroller_current_vehicle_speed, Dv = w.rawdynamicraycastvehiclecontroller_chassis, Pv = w.rawdynamicraycastvehiclecontroller_index_up_axis, Lv = w.rawdynamicraycastvehiclecontroller_set_index_up_axis, Fv = w.rawdynamicraycastvehiclecontroller_index_forward_axis, kv = w.rawdynamicraycastvehiclecontroller_set_index_forward_axis, Uv = w.rawdynamicraycastvehiclecontroller_add_wheel, Nv = w.rawdynamicraycastvehiclecontroller_num_wheels, Qv = w.rawdynamicraycastvehiclecontroller_update_vehicle, Ov = w.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs, zv = w.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs, Gv = w.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length, Hv = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length, Vv = w.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel, Wv = w.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel, jv = w.rawdynamicraycastvehiclecontroller_wheel_radius, qv = w.rawdynamicraycastvehiclecontroller_set_wheel_radius, Xv = w.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness, Yv = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness, Kv = w.rawdynamicraycastvehiclecontroller_wheel_suspension_compression, Jv = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression, Zv = w.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation, $v = w.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation, eS = w.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force, tS = w.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force, iS = w.rawdynamicraycastvehiclecontroller_wheel_brake, nS = w.rawdynamicraycastvehiclecontroller_set_wheel_brake, rS = w.rawdynamicraycastvehiclecontroller_wheel_steering, sS = w.rawdynamicraycastvehiclecontroller_set_wheel_steering, aS = w.rawdynamicraycastvehiclecontroller_wheel_engine_force, oS = w.rawdynamicraycastvehiclecontroller_set_wheel_engine_force, cS = w.rawdynamicraycastvehiclecontroller_wheel_direction_cs, lS = w.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs, hS = w.rawdynamicraycastvehiclecontroller_wheel_axle_cs, dS = w.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs, uS = w.rawdynamicraycastvehiclecontroller_wheel_friction_slip, fS = w.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip, pS = w.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness, AS = w.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness, gS = w.rawdynamicraycastvehiclecontroller_wheel_rotation, _S = w.rawdynamicraycastvehiclecontroller_wheel_forward_impulse, mS = w.rawdynamicraycastvehiclecontroller_wheel_side_impulse, wS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_force, bS = w.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws, yS = w.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws, xS = w.rawdynamicraycastvehiclecontroller_wheel_suspension_length, ES = w.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws, vS = w.rawdynamicraycastvehiclecontroller_wheel_is_in_contact, SS = w.rawdynamicraycastvehiclecontroller_wheel_ground_object, CS = w.__wbg_rawccdsolver_free, IS = w.rawccdsolver_new, MS = w.rawimpulsejointset_jointType, TS = w.rawimpulsejointset_jointBodyHandle1, RS = w.rawimpulsejointset_jointBodyHandle2, BS = w.rawimpulsejointset_jointFrameX1, DS = w.rawimpulsejointset_jointFrameX2, PS = w.rawimpulsejointset_jointAnchor1, LS = w.rawimpulsejointset_jointAnchor2, FS = w.rawimpulsejointset_jointSetAnchor1, kS = w.rawimpulsejointset_jointSetAnchor2, US = w.rawimpulsejointset_jointContactsEnabled, NS = w.rawimpulsejointset_jointSetContactsEnabled, QS = w.rawimpulsejointset_jointLimitsEnabled, OS = w.rawimpulsejointset_jointLimitsMin, zS = w.rawimpulsejointset_jointLimitsMax, GS = w.rawimpulsejointset_jointSetLimits, HS = w.rawimpulsejointset_jointConfigureMotorModel, VS = w.rawimpulsejointset_jointConfigureMotorVelocity, WS = w.rawimpulsejointset_jointConfigureMotorPosition, jS = w.rawimpulsejointset_jointConfigureMotor, qS = w.__wbg_rawimpulsejointset_free, XS = w.rawimpulsejointset_new, YS = w.rawimpulsejointset_createJoint, KS = w.rawimpulsejointset_remove, JS = w.rawimpulsejointset_len, ZS = w.rawimpulsejointset_contains, $S = w.rawimpulsejointset_forEachJointHandle, eC = w.rawimpulsejointset_forEachJointAttachedToRigidBody, tC = w.__wbg_rawintegrationparameters_free, iC = w.rawintegrationparameters_new, nC = w.rawintegrationparameters_dt, rC = w.rawintegrationparameters_contact_erp, sC = w.rawintegrationparameters_normalizedAllowedLinearError, aC = w.rawintegrationparameters_numSolverIterations, oC = w.rawintegrationparameters_numAdditionalFrictionIterations, cC = w.rawintegrationparameters_numInternalPgsIterations, lC = w.rawintegrationparameters_maxCcdSubsteps, hC = w.rawintegrationparameters_lengthUnit, dC = w.rawintegrationparameters_set_dt, uC = w.rawintegrationparameters_set_contact_natural_frequency, fC = w.rawintegrationparameters_set_normalizedAllowedLinearError, pC = w.rawintegrationparameters_set_normalizedPredictionDistance, AC = w.rawintegrationparameters_set_numSolverIterations, gC = w.rawintegrationparameters_set_numAdditionalFrictionIterations, _C = w.rawintegrationparameters_set_numInternalPgsIterations, mC = w.rawintegrationparameters_set_minIslandSize, wC = w.rawintegrationparameters_set_maxCcdSubsteps, bC = w.rawintegrationparameters_set_lengthUnit, yC = w.rawintegrationparameters_switchToStandardPgsSolver, xC = w.rawintegrationparameters_switchToSmallStepsPgsSolver, EC = w.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart, vC = w.__wbg_rawislandmanager_free, SC = w.rawislandmanager_new, CC = w.rawislandmanager_forEachActiveRigidBodyHandle, IC = w.__wbg_rawgenericjoint_free, MC = w.rawgenericjoint_generic, TC = w.rawgenericjoint_spring, RC = w.rawgenericjoint_rope, BC = w.rawgenericjoint_spherical, DC = w.rawgenericjoint_prismatic, PC = w.rawgenericjoint_fixed, LC = w.rawgenericjoint_revolute, FC = w.rawmultibodyjointset_jointType, kC = w.rawmultibodyjointset_jointFrameX1, UC = w.rawmultibodyjointset_jointFrameX2, NC = w.rawmultibodyjointset_jointAnchor1, QC = w.rawmultibodyjointset_jointAnchor2, OC = w.rawmultibodyjointset_jointContactsEnabled, zC = w.rawmultibodyjointset_jointSetContactsEnabled, GC = w.rawmultibodyjointset_jointLimitsEnabled, HC = w.rawmultibodyjointset_jointLimitsMin, VC = w.rawmultibodyjointset_jointLimitsMax, WC = w.__wbg_rawmultibodyjointset_free, jC = w.rawmultibodyjointset_new, qC = w.rawmultibodyjointset_createJoint, XC = w.rawmultibodyjointset_remove, YC = w.rawmultibodyjointset_contains, KC = w.rawmultibodyjointset_forEachJointHandle, JC = w.rawmultibodyjointset_forEachJointAttachedToRigidBody, ZC = w.rawrigidbodyset_rbTranslation, $C = w.rawrigidbodyset_rbRotation, eI = w.rawrigidbodyset_rbSleep, tI = w.rawrigidbodyset_rbIsSleeping, iI = w.rawrigidbodyset_rbIsMoving, nI = w.rawrigidbodyset_rbNextTranslation, rI = w.rawrigidbodyset_rbNextRotation, sI = w.rawrigidbodyset_rbSetTranslation, aI = w.rawrigidbodyset_rbSetRotation, oI = w.rawrigidbodyset_rbSetLinvel, cI = w.rawrigidbodyset_rbSetAngvel, lI = w.rawrigidbodyset_rbSetNextKinematicTranslation, hI = w.rawrigidbodyset_rbSetNextKinematicRotation, dI = w.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders, uI = w.rawrigidbodyset_rbSetAdditionalMass, fI = w.rawrigidbodyset_rbSetAdditionalMassProperties, pI = w.rawrigidbodyset_rbLinvel, AI = w.rawrigidbodyset_rbAngvel, gI = w.rawrigidbodyset_rbLockTranslations, _I = w.rawrigidbodyset_rbSetEnabledTranslations, mI = w.rawrigidbodyset_rbLockRotations, wI = w.rawrigidbodyset_rbSetEnabledRotations, bI = w.rawrigidbodyset_rbDominanceGroup, yI = w.rawrigidbodyset_rbSetDominanceGroup, xI = w.rawrigidbodyset_rbEnableCcd, EI = w.rawrigidbodyset_rbSetSoftCcdPrediction, vI = w.rawrigidbodyset_rbMass, SI = w.rawrigidbodyset_rbInvMass, CI = w.rawrigidbodyset_rbEffectiveInvMass, II = w.rawrigidbodyset_rbLocalCom, MI = w.rawrigidbodyset_rbWorldCom, TI = w.rawrigidbodyset_rbInvPrincipalInertiaSqrt, RI = w.rawrigidbodyset_rbPrincipalInertiaLocalFrame, BI = w.rawrigidbodyset_rbPrincipalInertia, DI = w.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt, PI = w.rawrigidbodyset_rbEffectiveAngularInertia, LI = w.rawrigidbodyset_rbWakeUp, FI = w.rawrigidbodyset_rbIsCcdEnabled, kI = w.rawrigidbodyset_rbSoftCcdPrediction, UI = w.rawrigidbodyset_rbNumColliders, NI = w.rawrigidbodyset_rbCollider, QI = w.rawrigidbodyset_rbBodyType, OI = w.rawrigidbodyset_rbSetBodyType, zI = w.rawrigidbodyset_rbIsFixed, GI = w.rawrigidbodyset_rbIsKinematic, HI = w.rawrigidbodyset_rbIsDynamic, VI = w.rawrigidbodyset_rbLinearDamping, WI = w.rawrigidbodyset_rbAngularDamping, jI = w.rawrigidbodyset_rbSetLinearDamping, qI = w.rawrigidbodyset_rbSetAngularDamping, XI = w.rawrigidbodyset_rbSetEnabled, YI = w.rawrigidbodyset_rbIsEnabled, KI = w.rawrigidbodyset_rbGravityScale, JI = w.rawrigidbodyset_rbSetGravityScale, ZI = w.rawrigidbodyset_rbResetForces, $I = w.rawrigidbodyset_rbResetTorques, eM = w.rawrigidbodyset_rbAddForce, tM = w.rawrigidbodyset_rbApplyImpulse, iM = w.rawrigidbodyset_rbAddTorque, nM = w.rawrigidbodyset_rbApplyTorqueImpulse, rM = w.rawrigidbodyset_rbAddForceAtPoint, sM = w.rawrigidbodyset_rbApplyImpulseAtPoint, aM = w.rawrigidbodyset_rbAdditionalSolverIterations, oM = w.rawrigidbodyset_rbSetAdditionalSolverIterations, cM = w.rawrigidbodyset_rbUserData, lM = w.rawrigidbodyset_rbSetUserData, hM = w.rawrigidbodyset_rbUserForce, dM = w.rawrigidbodyset_rbUserTorque, uM = w.__wbg_rawrigidbodyset_free, fM = w.rawrigidbodyset_new, pM = w.rawrigidbodyset_createRigidBody, AM = w.rawrigidbodyset_remove, gM = w.rawrigidbodyset_contains, _M = w.rawrigidbodyset_forEachRigidBodyHandle, mM = w.rawrigidbodyset_propagateModifiedBodyPositionsToColliders, wM = w.__wbg_rawbroadphase_free, bM = w.rawbroadphase_new, yM = w.rawcolliderset_coTranslation, xM = w.rawcolliderset_coRotation, EM = w.rawcolliderset_coSetTranslation, vM = w.rawcolliderset_coSetTranslationWrtParent, SM = w.rawcolliderset_coSetRotation, CM = w.rawcolliderset_coSetRotationWrtParent, IM = w.rawcolliderset_coIsSensor, MM = w.rawcolliderset_coShapeType, TM = w.rawcolliderset_coHalfspaceNormal, RM = w.rawcolliderset_coHalfExtents, BM = w.rawcolliderset_coSetHalfExtents, DM = w.rawcolliderset_coRadius, PM = w.rawcolliderset_coSetRadius, LM = w.rawcolliderset_coHalfHeight, FM = w.rawcolliderset_coSetHalfHeight, kM = w.rawcolliderset_coRoundRadius, UM = w.rawcolliderset_coSetRoundRadius, NM = w.rawcolliderset_coVertices, QM = w.rawcolliderset_coIndices, OM = w.rawcolliderset_coTriMeshFlags, zM = w.rawcolliderset_coHeightFieldFlags, GM = w.rawcolliderset_coHeightfieldHeights, HM = w.rawcolliderset_coHeightfieldScale, VM = w.rawcolliderset_coHeightfieldNRows, WM = w.rawcolliderset_coHeightfieldNCols, jM = w.rawcolliderset_coParent, qM = w.rawcolliderset_coSetEnabled, XM = w.rawcolliderset_coIsEnabled, YM = w.rawcolliderset_coSetContactSkin, KM = w.rawcolliderset_coContactSkin, JM = w.rawcolliderset_coFriction, ZM = w.rawcolliderset_coRestitution, $M = w.rawcolliderset_coDensity, eT = w.rawcolliderset_coMass, tT = w.rawcolliderset_coVolume, iT = w.rawcolliderset_coCollisionGroups, nT = w.rawcolliderset_coSolverGroups, rT = w.rawcolliderset_coActiveHooks, sT = w.rawcolliderset_coActiveCollisionTypes, aT = w.rawcolliderset_coActiveEvents, oT = w.rawcolliderset_coContactForceEventThreshold, cT = w.rawcolliderset_coContainsPoint, lT = w.rawcolliderset_coCastShape, hT = w.rawcolliderset_coCastCollider, dT = w.rawcolliderset_coIntersectsShape, uT = w.rawcolliderset_coContactShape, fT = w.rawcolliderset_coContactCollider, pT = w.rawcolliderset_coProjectPoint, AT = w.rawcolliderset_coIntersectsRay, gT = w.rawcolliderset_coCastRay, _T = w.rawcolliderset_coCastRayAndGetNormal, mT = w.rawcolliderset_coSetSensor, wT = w.rawcolliderset_coSetRestitution, bT = w.rawcolliderset_coSetFriction, yT = w.rawcolliderset_coFrictionCombineRule, xT = w.rawcolliderset_coSetFrictionCombineRule, ET = w.rawcolliderset_coRestitutionCombineRule, vT = w.rawcolliderset_coSetRestitutionCombineRule, ST = w.rawcolliderset_coSetCollisionGroups, CT = w.rawcolliderset_coSetSolverGroups, IT = w.rawcolliderset_coSetActiveHooks, MT = w.rawcolliderset_coSetActiveEvents, TT = w.rawcolliderset_coSetActiveCollisionTypes, RT = w.rawcolliderset_coSetShape, BT = w.rawcolliderset_coSetContactForceEventThreshold, DT = w.rawcolliderset_coSetDensity, PT = w.rawcolliderset_coSetMass, LT = w.rawcolliderset_coSetMassProperties, FT = w.__wbg_rawcolliderset_free, kT = w.rawcolliderset_new, UT = w.rawcolliderset_len, NT = w.rawcolliderset_contains, QT = w.rawcolliderset_createCollider, OT = w.rawcolliderset_remove, zT = w.rawcolliderset_forEachColliderHandle, GT = w.__wbg_rawshapecontact_free, HT = w.__wbg_rawnarrowphase_free, VT = w.rawnarrowphase_new, WT = w.rawnarrowphase_contact_pairs_with, jT = w.rawnarrowphase_contact_pair, qT = w.rawnarrowphase_intersection_pairs_with, XT = w.rawnarrowphase_intersection_pair, YT = w.__wbg_rawcontactmanifold_free, KT = w.rawcontactpair_collider1, JT = w.rawcontactpair_collider2, ZT = w.rawcontactpair_numContactManifolds, $T = w.rawcontactpair_contactManifold, eR = w.rawcontactmanifold_normal, tR = w.rawcontactmanifold_local_n1, iR = w.rawcontactmanifold_local_n2, nR = w.rawcontactmanifold_subshape1, rR = w.rawcontactmanifold_subshape2, sR = w.rawcontactmanifold_num_contacts, aR = w.rawcontactmanifold_contact_local_p1, oR = w.rawcontactmanifold_contact_local_p2, cR = w.rawcontactmanifold_contact_dist, lR = w.rawcontactmanifold_contact_fid1, hR = w.rawcontactmanifold_contact_fid2, dR = w.rawcontactmanifold_contact_impulse, uR = w.rawcontactmanifold_contact_tangent_impulse_x, fR = w.rawcontactmanifold_contact_tangent_impulse_y, pR = w.rawcontactmanifold_num_solver_contacts, AR = w.rawcontactmanifold_solver_contact_point, gR = w.rawcontactmanifold_solver_contact_dist, _R = w.rawcontactmanifold_solver_contact_friction, mR = w.rawcontactmanifold_solver_contact_restitution, wR = w.rawcontactmanifold_solver_contact_tangent_velocity, bR = w.__wbg_rawpointprojection_free, yR = w.rawpointprojection_point, xR = w.rawpointprojection_isInside, ER = w.__wbg_rawpointcolliderprojection_free, vR = w.rawpointcolliderprojection_colliderHandle, SR = w.rawpointcolliderprojection_point, CR = w.rawpointcolliderprojection_isInside, IR = w.rawpointcolliderprojection_featureType, MR = w.rawpointcolliderprojection_featureId, TR = w.__wbg_rawrayintersection_free, RR = w.__wbg_rawraycolliderhit_free, BR = w.__wbg_rawshape_free, DR = w.rawshape_cuboid, PR = w.rawshape_roundCuboid, LR = w.rawshape_ball, FR = w.rawshape_halfspace, kR = w.rawshape_capsule, UR = w.rawshape_cylinder, NR = w.rawshape_roundCylinder, QR = w.rawshape_cone, OR = w.rawshape_roundCone, zR = w.rawshape_polyline, GR = w.rawshape_trimesh, HR = w.rawshape_heightfield, VR = w.rawshape_segment, WR = w.rawshape_triangle, jR = w.rawshape_roundTriangle, qR = w.rawshape_convexHull, XR = w.rawshape_roundConvexHull, YR = w.rawshape_convexMesh, KR = w.rawshape_roundConvexMesh, JR = w.rawshape_castShape, ZR = w.rawshape_intersectsShape, $R = w.rawshape_contactShape, eB = w.rawshape_containsPoint, tB = w.rawshape_projectPoint, iB = w.rawshape_intersectsRay, nB = w.rawshape_castRay, rB = w.rawshape_castRayAndGetNormal, sB = w.__wbg_rawshapecasthit_free, aB = w.rawshapecasthit_witness1, oB = w.rawshapecasthit_normal1, cB = w.rawshapecasthit_normal2, lB = w.__wbg_rawcollidershapecasthit_free, hB = w.rawcollidershapecasthit_time_of_impact, dB = w.rawcollidershapecasthit_witness1, uB = w.rawcollidershapecasthit_witness2, fB = w.rawrotation_new, pB = w.rawrotation_identity, AB = w.rawrotation_x, gB = w.rawrotation_w, _B = w.rawvector_zero, mB = w.rawvector_new, wB = w.rawvector_set_x, bB = w.rawvector_set_z, yB = w.rawvector_xyz, xB = w.rawvector_yxz, EB = w.rawvector_zxy, vB = w.rawvector_xzy, SB = w.rawvector_yzx, CB = w.rawvector_zyx, IB = w.rawsdpmatrix3_elements, MB = w.__wbg_rawdebugrenderpipeline_free, TB = w.rawdebugrenderpipeline_new, RB = w.rawdebugrenderpipeline_vertices, BB = w.rawdebugrenderpipeline_colors, DB = w.rawdebugrenderpipeline_render, PB = w.__wbg_raweventqueue_free, LB = w.__wbg_rawcontactforceevent_free, FB = w.rawcontactforceevent_collider2, kB = w.rawcontactforceevent_total_force, UB = w.rawcontactforceevent_total_force_magnitude, NB = w.rawcontactforceevent_max_force_direction, QB = w.rawcontactforceevent_max_force_magnitude, OB = w.raweventqueue_new, zB = w.raweventqueue_drainCollisionEvents, GB = w.raweventqueue_drainContactForceEvents, HB = w.raweventqueue_clear, VB = w.__wbg_rawphysicspipeline_free, WB = w.rawphysicspipeline_new, jB = w.rawphysicspipeline_step, qB = w.rawphysicspipeline_stepWithEvents, XB = w.rawquerypipeline_new, YB = w.rawquerypipeline_update, KB = w.rawquerypipeline_castRay, JB = w.rawquerypipeline_castRayAndGetNormal, ZB = w.rawquerypipeline_intersectionsWithRay, $B = w.rawquerypipeline_intersectionWithShape, e1 = w.rawquerypipeline_projectPoint, t1 = w.rawquerypipeline_projectPointAndGetFeature, i1 = w.rawquerypipeline_intersectionsWithPoint, n1 = w.rawquerypipeline_castShape, r1 = w.rawquerypipeline_intersectionsWithShape, s1 = w.rawquerypipeline_collidersWithAabbIntersectingAabb, a1 = w.__wbg_rawdeserializedworld_free, o1 = w.rawdeserializedworld_takeGravity, c1 = w.rawdeserializedworld_takeIntegrationParameters, l1 = w.rawdeserializedworld_takeIslandManager, h1 = w.rawdeserializedworld_takeBroadPhase, d1 = w.rawdeserializedworld_takeNarrowPhase, u1 = w.rawdeserializedworld_takeBodies, f1 = w.rawdeserializedworld_takeColliders, p1 = w.rawdeserializedworld_takeImpulseJoints, A1 = w.rawdeserializedworld_takeMultibodyJoints, g1 = w.__wbg_rawserializationpipeline_free, _1 = w.rawserializationpipeline_new, m1 = w.rawserializationpipeline_serializeAll, w1 = w.rawserializationpipeline_deserializeAll, b1 = w.rawkinematiccharactercontroller_offset, y1 = w.rawintegrationparameters_minIslandSize, x1 = w.rawrigidbodyset_len, E1 = w.rawshapecontact_distance, v1 = w.rawrayintersection_featureType, S1 = w.rawraycolliderintersection_colliderHandle, C1 = w.rawrayintersection_time_of_impact, I1 = w.rawraycolliderintersection_featureType, M1 = w.rawraycolliderhit_colliderHandle, T1 = w.rawraycolliderintersection_time_of_impact, R1 = w.rawcollidershapecasthit_colliderHandle, B1 = w.rawraycolliderhit_timeOfImpact, D1 = w.rawshapecasthit_time_of_impact, P1 = w.rawrotation_y, L1 = w.rawrotation_z, F1 = w.rawvector_x, k1 = w.rawvector_y, U1 = w.rawvector_z, N1 = w.rawcontactforceevent_collider1, Q1 = w.rawintegrationparameters_normalizedPredictionDistance, O1 = w.rawcolliderset_isHandleValid, z1 = w.rawrayintersection_featureId, G1 = w.rawraycolliderintersection_featureId, H1 = w.rawkinematiccharactercontroller_up, V1 = w.rawshapecontact_normal2, W1 = w.rawshapecontact_point1, j1 = w.rawshapecontact_point2, q1 = w.rawrayintersection_normal, X1 = w.rawraycolliderintersection_normal, Y1 = w.rawshapecontact_normal1, K1 = w.rawcollidershapecasthit_normal1, J1 = w.rawcollidershapecasthit_normal2, Z1 = w.rawshapecasthit_witness2, $1 = w.__wbg_rawcontactpair_free, eD = w.__wbg_rawraycolliderintersection_free, tD = w.__wbg_rawrotation_free, iD = w.__wbg_rawvector_free, nD = w.__wbg_rawsdpmatrix3_free, rD = w.__wbg_rawquerypipeline_free, sD = w.rawvector_set_y, aD = w.__wbindgen_export_0, oD = w.__wbindgen_add_to_stack_pointer, cD = w.__wbindgen_export_1, lD = w.__wbindgen_export_2, hD = Object.freeze(Object.defineProperty({
        __proto__: null,
        __wbg_rawbroadphase_free: wM,
        __wbg_rawccdsolver_free: CS,
        __wbg_rawcharactercollision_free: cv,
        __wbg_rawcolliderset_free: FT,
        __wbg_rawcollidershapecasthit_free: lB,
        __wbg_rawcontactforceevent_free: LB,
        __wbg_rawcontactmanifold_free: YT,
        __wbg_rawcontactpair_free: $1,
        __wbg_rawdebugrenderpipeline_free: MB,
        __wbg_rawdeserializedworld_free: a1,
        __wbg_rawdynamicraycastvehiclecontroller_free: Tv,
        __wbg_raweventqueue_free: PB,
        __wbg_rawgenericjoint_free: IC,
        __wbg_rawimpulsejointset_free: qS,
        __wbg_rawintegrationparameters_free: tC,
        __wbg_rawislandmanager_free: vC,
        __wbg_rawkinematiccharactercontroller_free: FE,
        __wbg_rawmultibodyjointset_free: WC,
        __wbg_rawnarrowphase_free: HT,
        __wbg_rawphysicspipeline_free: VB,
        __wbg_rawpidcontroller_free: mv,
        __wbg_rawpointcolliderprojection_free: ER,
        __wbg_rawpointprojection_free: bR,
        __wbg_rawquerypipeline_free: rD,
        __wbg_rawraycolliderhit_free: RR,
        __wbg_rawraycolliderintersection_free: eD,
        __wbg_rawrayintersection_free: TR,
        __wbg_rawrigidbodyset_free: uM,
        __wbg_rawrotation_free: tD,
        __wbg_rawsdpmatrix3_free: nD,
        __wbg_rawserializationpipeline_free: g1,
        __wbg_rawshape_free: BR,
        __wbg_rawshapecasthit_free: sB,
        __wbg_rawshapecontact_free: GT,
        __wbg_rawvector_free: iD,
        __wbindgen_add_to_stack_pointer: oD,
        __wbindgen_export_0: aD,
        __wbindgen_export_1: cD,
        __wbindgen_export_2: lD,
        memory: PE,
        rawbroadphase_new: bM,
        rawccdsolver_new: IS,
        rawcharactercollision_handle: hv,
        rawcharactercollision_new: lv,
        rawcharactercollision_toi: fv,
        rawcharactercollision_translationDeltaApplied: dv,
        rawcharactercollision_translationDeltaRemaining: uv,
        rawcharactercollision_worldNormal1: gv,
        rawcharactercollision_worldNormal2: _v,
        rawcharactercollision_worldWitness1: pv,
        rawcharactercollision_worldWitness2: Av,
        rawcolliderset_coActiveCollisionTypes: sT,
        rawcolliderset_coActiveEvents: aT,
        rawcolliderset_coActiveHooks: rT,
        rawcolliderset_coCastCollider: hT,
        rawcolliderset_coCastRay: gT,
        rawcolliderset_coCastRayAndGetNormal: _T,
        rawcolliderset_coCastShape: lT,
        rawcolliderset_coCollisionGroups: iT,
        rawcolliderset_coContactCollider: fT,
        rawcolliderset_coContactForceEventThreshold: oT,
        rawcolliderset_coContactShape: uT,
        rawcolliderset_coContactSkin: KM,
        rawcolliderset_coContainsPoint: cT,
        rawcolliderset_coDensity: $M,
        rawcolliderset_coFriction: JM,
        rawcolliderset_coFrictionCombineRule: yT,
        rawcolliderset_coHalfExtents: RM,
        rawcolliderset_coHalfHeight: LM,
        rawcolliderset_coHalfspaceNormal: TM,
        rawcolliderset_coHeightFieldFlags: zM,
        rawcolliderset_coHeightfieldHeights: GM,
        rawcolliderset_coHeightfieldNCols: WM,
        rawcolliderset_coHeightfieldNRows: VM,
        rawcolliderset_coHeightfieldScale: HM,
        rawcolliderset_coIndices: QM,
        rawcolliderset_coIntersectsRay: AT,
        rawcolliderset_coIntersectsShape: dT,
        rawcolliderset_coIsEnabled: XM,
        rawcolliderset_coIsSensor: IM,
        rawcolliderset_coMass: eT,
        rawcolliderset_coParent: jM,
        rawcolliderset_coProjectPoint: pT,
        rawcolliderset_coRadius: DM,
        rawcolliderset_coRestitution: ZM,
        rawcolliderset_coRestitutionCombineRule: ET,
        rawcolliderset_coRotation: xM,
        rawcolliderset_coRoundRadius: kM,
        rawcolliderset_coSetActiveCollisionTypes: TT,
        rawcolliderset_coSetActiveEvents: MT,
        rawcolliderset_coSetActiveHooks: IT,
        rawcolliderset_coSetCollisionGroups: ST,
        rawcolliderset_coSetContactForceEventThreshold: BT,
        rawcolliderset_coSetContactSkin: YM,
        rawcolliderset_coSetDensity: DT,
        rawcolliderset_coSetEnabled: qM,
        rawcolliderset_coSetFriction: bT,
        rawcolliderset_coSetFrictionCombineRule: xT,
        rawcolliderset_coSetHalfExtents: BM,
        rawcolliderset_coSetHalfHeight: FM,
        rawcolliderset_coSetMass: PT,
        rawcolliderset_coSetMassProperties: LT,
        rawcolliderset_coSetRadius: PM,
        rawcolliderset_coSetRestitution: wT,
        rawcolliderset_coSetRestitutionCombineRule: vT,
        rawcolliderset_coSetRotation: SM,
        rawcolliderset_coSetRotationWrtParent: CM,
        rawcolliderset_coSetRoundRadius: UM,
        rawcolliderset_coSetSensor: mT,
        rawcolliderset_coSetShape: RT,
        rawcolliderset_coSetSolverGroups: CT,
        rawcolliderset_coSetTranslation: EM,
        rawcolliderset_coSetTranslationWrtParent: vM,
        rawcolliderset_coShapeType: MM,
        rawcolliderset_coSolverGroups: nT,
        rawcolliderset_coTranslation: yM,
        rawcolliderset_coTriMeshFlags: OM,
        rawcolliderset_coVertices: NM,
        rawcolliderset_coVolume: tT,
        rawcolliderset_contains: NT,
        rawcolliderset_createCollider: QT,
        rawcolliderset_forEachColliderHandle: zT,
        rawcolliderset_isHandleValid: O1,
        rawcolliderset_len: UT,
        rawcolliderset_new: kT,
        rawcolliderset_remove: OT,
        rawcollidershapecasthit_colliderHandle: R1,
        rawcollidershapecasthit_normal1: K1,
        rawcollidershapecasthit_normal2: J1,
        rawcollidershapecasthit_time_of_impact: hB,
        rawcollidershapecasthit_witness1: dB,
        rawcollidershapecasthit_witness2: uB,
        rawcontactforceevent_collider1: N1,
        rawcontactforceevent_collider2: FB,
        rawcontactforceevent_max_force_direction: NB,
        rawcontactforceevent_max_force_magnitude: QB,
        rawcontactforceevent_total_force: kB,
        rawcontactforceevent_total_force_magnitude: UB,
        rawcontactmanifold_contact_dist: cR,
        rawcontactmanifold_contact_fid1: lR,
        rawcontactmanifold_contact_fid2: hR,
        rawcontactmanifold_contact_impulse: dR,
        rawcontactmanifold_contact_local_p1: aR,
        rawcontactmanifold_contact_local_p2: oR,
        rawcontactmanifold_contact_tangent_impulse_x: uR,
        rawcontactmanifold_contact_tangent_impulse_y: fR,
        rawcontactmanifold_local_n1: tR,
        rawcontactmanifold_local_n2: iR,
        rawcontactmanifold_normal: eR,
        rawcontactmanifold_num_contacts: sR,
        rawcontactmanifold_num_solver_contacts: pR,
        rawcontactmanifold_solver_contact_dist: gR,
        rawcontactmanifold_solver_contact_friction: _R,
        rawcontactmanifold_solver_contact_point: AR,
        rawcontactmanifold_solver_contact_restitution: mR,
        rawcontactmanifold_solver_contact_tangent_velocity: wR,
        rawcontactmanifold_subshape1: nR,
        rawcontactmanifold_subshape2: rR,
        rawcontactpair_collider1: KT,
        rawcontactpair_collider2: JT,
        rawcontactpair_contactManifold: $T,
        rawcontactpair_numContactManifolds: ZT,
        rawdebugrenderpipeline_colors: BB,
        rawdebugrenderpipeline_new: TB,
        rawdebugrenderpipeline_render: DB,
        rawdebugrenderpipeline_vertices: RB,
        rawdeserializedworld_takeBodies: u1,
        rawdeserializedworld_takeBroadPhase: h1,
        rawdeserializedworld_takeColliders: f1,
        rawdeserializedworld_takeGravity: o1,
        rawdeserializedworld_takeImpulseJoints: p1,
        rawdeserializedworld_takeIntegrationParameters: c1,
        rawdeserializedworld_takeIslandManager: l1,
        rawdeserializedworld_takeMultibodyJoints: A1,
        rawdeserializedworld_takeNarrowPhase: d1,
        rawdynamicraycastvehiclecontroller_add_wheel: Uv,
        rawdynamicraycastvehiclecontroller_chassis: Dv,
        rawdynamicraycastvehiclecontroller_current_vehicle_speed: Bv,
        rawdynamicraycastvehiclecontroller_index_forward_axis: Fv,
        rawdynamicraycastvehiclecontroller_index_up_axis: Pv,
        rawdynamicraycastvehiclecontroller_new: Rv,
        rawdynamicraycastvehiclecontroller_num_wheels: Nv,
        rawdynamicraycastvehiclecontroller_set_index_forward_axis: kv,
        rawdynamicraycastvehiclecontroller_set_index_up_axis: Lv,
        rawdynamicraycastvehiclecontroller_set_wheel_axle_cs: dS,
        rawdynamicraycastvehiclecontroller_set_wheel_brake: nS,
        rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs: zv,
        rawdynamicraycastvehiclecontroller_set_wheel_direction_cs: lS,
        rawdynamicraycastvehiclecontroller_set_wheel_engine_force: oS,
        rawdynamicraycastvehiclecontroller_set_wheel_friction_slip: fS,
        rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force: tS,
        rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel: Wv,
        rawdynamicraycastvehiclecontroller_set_wheel_radius: qv,
        rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness: AS,
        rawdynamicraycastvehiclecontroller_set_wheel_steering: sS,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression: Jv,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation: $v,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length: Hv,
        rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness: Yv,
        rawdynamicraycastvehiclecontroller_update_vehicle: Qv,
        rawdynamicraycastvehiclecontroller_wheel_axle_cs: hS,
        rawdynamicraycastvehiclecontroller_wheel_brake: iS,
        rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs: Ov,
        rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws: bS,
        rawdynamicraycastvehiclecontroller_wheel_contact_point_ws: yS,
        rawdynamicraycastvehiclecontroller_wheel_direction_cs: cS,
        rawdynamicraycastvehiclecontroller_wheel_engine_force: aS,
        rawdynamicraycastvehiclecontroller_wheel_forward_impulse: _S,
        rawdynamicraycastvehiclecontroller_wheel_friction_slip: uS,
        rawdynamicraycastvehiclecontroller_wheel_ground_object: SS,
        rawdynamicraycastvehiclecontroller_wheel_hard_point_ws: ES,
        rawdynamicraycastvehiclecontroller_wheel_is_in_contact: vS,
        rawdynamicraycastvehiclecontroller_wheel_max_suspension_force: eS,
        rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel: Vv,
        rawdynamicraycastvehiclecontroller_wheel_radius: jv,
        rawdynamicraycastvehiclecontroller_wheel_rotation: gS,
        rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness: pS,
        rawdynamicraycastvehiclecontroller_wheel_side_impulse: mS,
        rawdynamicraycastvehiclecontroller_wheel_steering: rS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_compression: Kv,
        rawdynamicraycastvehiclecontroller_wheel_suspension_force: wS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_length: xS,
        rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation: Zv,
        rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length: Gv,
        rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness: Xv,
        raweventqueue_clear: HB,
        raweventqueue_drainCollisionEvents: zB,
        raweventqueue_drainContactForceEvents: GB,
        raweventqueue_new: OB,
        rawgenericjoint_fixed: PC,
        rawgenericjoint_generic: MC,
        rawgenericjoint_prismatic: DC,
        rawgenericjoint_revolute: LC,
        rawgenericjoint_rope: RC,
        rawgenericjoint_spherical: BC,
        rawgenericjoint_spring: TC,
        rawimpulsejointset_contains: ZS,
        rawimpulsejointset_createJoint: YS,
        rawimpulsejointset_forEachJointAttachedToRigidBody: eC,
        rawimpulsejointset_forEachJointHandle: $S,
        rawimpulsejointset_jointAnchor1: PS,
        rawimpulsejointset_jointAnchor2: LS,
        rawimpulsejointset_jointBodyHandle1: TS,
        rawimpulsejointset_jointBodyHandle2: RS,
        rawimpulsejointset_jointConfigureMotor: jS,
        rawimpulsejointset_jointConfigureMotorModel: HS,
        rawimpulsejointset_jointConfigureMotorPosition: WS,
        rawimpulsejointset_jointConfigureMotorVelocity: VS,
        rawimpulsejointset_jointContactsEnabled: US,
        rawimpulsejointset_jointFrameX1: BS,
        rawimpulsejointset_jointFrameX2: DS,
        rawimpulsejointset_jointLimitsEnabled: QS,
        rawimpulsejointset_jointLimitsMax: zS,
        rawimpulsejointset_jointLimitsMin: OS,
        rawimpulsejointset_jointSetAnchor1: FS,
        rawimpulsejointset_jointSetAnchor2: kS,
        rawimpulsejointset_jointSetContactsEnabled: NS,
        rawimpulsejointset_jointSetLimits: GS,
        rawimpulsejointset_jointType: MS,
        rawimpulsejointset_len: JS,
        rawimpulsejointset_new: XS,
        rawimpulsejointset_remove: KS,
        rawintegrationparameters_contact_erp: rC,
        rawintegrationparameters_dt: nC,
        rawintegrationparameters_lengthUnit: hC,
        rawintegrationparameters_maxCcdSubsteps: lC,
        rawintegrationparameters_minIslandSize: y1,
        rawintegrationparameters_new: iC,
        rawintegrationparameters_normalizedAllowedLinearError: sC,
        rawintegrationparameters_normalizedPredictionDistance: Q1,
        rawintegrationparameters_numAdditionalFrictionIterations: oC,
        rawintegrationparameters_numInternalPgsIterations: cC,
        rawintegrationparameters_numSolverIterations: aC,
        rawintegrationparameters_set_contact_natural_frequency: uC,
        rawintegrationparameters_set_dt: dC,
        rawintegrationparameters_set_lengthUnit: bC,
        rawintegrationparameters_set_maxCcdSubsteps: wC,
        rawintegrationparameters_set_minIslandSize: mC,
        rawintegrationparameters_set_normalizedAllowedLinearError: fC,
        rawintegrationparameters_set_normalizedPredictionDistance: pC,
        rawintegrationparameters_set_numAdditionalFrictionIterations: gC,
        rawintegrationparameters_set_numInternalPgsIterations: _C,
        rawintegrationparameters_set_numSolverIterations: AC,
        rawintegrationparameters_switchToSmallStepsPgsSolver: xC,
        rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart: EC,
        rawintegrationparameters_switchToStandardPgsSolver: yC,
        rawislandmanager_forEachActiveRigidBodyHandle: CC,
        rawislandmanager_new: SC,
        rawkinematiccharactercontroller_autostepEnabled: jE,
        rawkinematiccharactercontroller_autostepIncludesDynamicBodies: WE,
        rawkinematiccharactercontroller_autostepMaxHeight: HE,
        rawkinematiccharactercontroller_autostepMinWidth: VE,
        rawkinematiccharactercontroller_computeColliderMovement: nv,
        rawkinematiccharactercontroller_computedCollision: ov,
        rawkinematiccharactercontroller_computedGrounded: sv,
        rawkinematiccharactercontroller_computedMovement: rv,
        rawkinematiccharactercontroller_disableAutostep: XE,
        rawkinematiccharactercontroller_disableSnapToGround: tv,
        rawkinematiccharactercontroller_enableAutostep: qE,
        rawkinematiccharactercontroller_enableSnapToGround: ev,
        rawkinematiccharactercontroller_maxSlopeClimbAngle: YE,
        rawkinematiccharactercontroller_minSlopeSlideAngle: JE,
        rawkinematiccharactercontroller_new: kE,
        rawkinematiccharactercontroller_normalNudgeFactor: NE,
        rawkinematiccharactercontroller_numComputedCollisions: av,
        rawkinematiccharactercontroller_offset: b1,
        rawkinematiccharactercontroller_setMaxSlopeClimbAngle: KE,
        rawkinematiccharactercontroller_setMinSlopeSlideAngle: ZE,
        rawkinematiccharactercontroller_setNormalNudgeFactor: QE,
        rawkinematiccharactercontroller_setOffset: OE,
        rawkinematiccharactercontroller_setSlideEnabled: GE,
        rawkinematiccharactercontroller_setUp: UE,
        rawkinematiccharactercontroller_slideEnabled: zE,
        rawkinematiccharactercontroller_snapToGroundDistance: $E,
        rawkinematiccharactercontroller_snapToGroundEnabled: iv,
        rawkinematiccharactercontroller_up: H1,
        rawmultibodyjointset_contains: YC,
        rawmultibodyjointset_createJoint: qC,
        rawmultibodyjointset_forEachJointAttachedToRigidBody: JC,
        rawmultibodyjointset_forEachJointHandle: KC,
        rawmultibodyjointset_jointAnchor1: NC,
        rawmultibodyjointset_jointAnchor2: QC,
        rawmultibodyjointset_jointContactsEnabled: OC,
        rawmultibodyjointset_jointFrameX1: kC,
        rawmultibodyjointset_jointFrameX2: UC,
        rawmultibodyjointset_jointLimitsEnabled: GC,
        rawmultibodyjointset_jointLimitsMax: VC,
        rawmultibodyjointset_jointLimitsMin: HC,
        rawmultibodyjointset_jointSetContactsEnabled: zC,
        rawmultibodyjointset_jointType: FC,
        rawmultibodyjointset_new: jC,
        rawmultibodyjointset_remove: XC,
        rawnarrowphase_contact_pair: jT,
        rawnarrowphase_contact_pairs_with: WT,
        rawnarrowphase_intersection_pair: XT,
        rawnarrowphase_intersection_pairs_with: qT,
        rawnarrowphase_new: VT,
        rawphysicspipeline_new: WB,
        rawphysicspipeline_step: jB,
        rawphysicspipeline_stepWithEvents: qB,
        rawpidcontroller_angular_correction: Mv,
        rawpidcontroller_apply_angular_correction: Cv,
        rawpidcontroller_apply_linear_correction: Sv,
        rawpidcontroller_linear_correction: Iv,
        rawpidcontroller_new: wv,
        rawpidcontroller_reset_integrals: vv,
        rawpidcontroller_set_axes_mask: Ev,
        rawpidcontroller_set_kd: xv,
        rawpidcontroller_set_ki: yv,
        rawpidcontroller_set_kp: bv,
        rawpointcolliderprojection_colliderHandle: vR,
        rawpointcolliderprojection_featureId: MR,
        rawpointcolliderprojection_featureType: IR,
        rawpointcolliderprojection_isInside: CR,
        rawpointcolliderprojection_point: SR,
        rawpointprojection_isInside: xR,
        rawpointprojection_point: yR,
        rawquerypipeline_castRay: KB,
        rawquerypipeline_castRayAndGetNormal: JB,
        rawquerypipeline_castShape: n1,
        rawquerypipeline_collidersWithAabbIntersectingAabb: s1,
        rawquerypipeline_intersectionWithShape: $B,
        rawquerypipeline_intersectionsWithPoint: i1,
        rawquerypipeline_intersectionsWithRay: ZB,
        rawquerypipeline_intersectionsWithShape: r1,
        rawquerypipeline_new: XB,
        rawquerypipeline_projectPoint: e1,
        rawquerypipeline_projectPointAndGetFeature: t1,
        rawquerypipeline_update: YB,
        rawraycolliderhit_colliderHandle: M1,
        rawraycolliderhit_timeOfImpact: B1,
        rawraycolliderintersection_colliderHandle: S1,
        rawraycolliderintersection_featureId: G1,
        rawraycolliderintersection_featureType: I1,
        rawraycolliderintersection_normal: X1,
        rawraycolliderintersection_time_of_impact: T1,
        rawrayintersection_featureId: z1,
        rawrayintersection_featureType: v1,
        rawrayintersection_normal: q1,
        rawrayintersection_time_of_impact: C1,
        rawrigidbodyset_contains: gM,
        rawrigidbodyset_createRigidBody: pM,
        rawrigidbodyset_forEachRigidBodyHandle: _M,
        rawrigidbodyset_len: x1,
        rawrigidbodyset_new: fM,
        rawrigidbodyset_propagateModifiedBodyPositionsToColliders: mM,
        rawrigidbodyset_rbAddForce: eM,
        rawrigidbodyset_rbAddForceAtPoint: rM,
        rawrigidbodyset_rbAddTorque: iM,
        rawrigidbodyset_rbAdditionalSolverIterations: aM,
        rawrigidbodyset_rbAngularDamping: WI,
        rawrigidbodyset_rbAngvel: AI,
        rawrigidbodyset_rbApplyImpulse: tM,
        rawrigidbodyset_rbApplyImpulseAtPoint: sM,
        rawrigidbodyset_rbApplyTorqueImpulse: nM,
        rawrigidbodyset_rbBodyType: QI,
        rawrigidbodyset_rbCollider: NI,
        rawrigidbodyset_rbDominanceGroup: bI,
        rawrigidbodyset_rbEffectiveAngularInertia: PI,
        rawrigidbodyset_rbEffectiveInvMass: CI,
        rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt: DI,
        rawrigidbodyset_rbEnableCcd: xI,
        rawrigidbodyset_rbGravityScale: KI,
        rawrigidbodyset_rbInvMass: SI,
        rawrigidbodyset_rbInvPrincipalInertiaSqrt: TI,
        rawrigidbodyset_rbIsCcdEnabled: FI,
        rawrigidbodyset_rbIsDynamic: HI,
        rawrigidbodyset_rbIsEnabled: YI,
        rawrigidbodyset_rbIsFixed: zI,
        rawrigidbodyset_rbIsKinematic: GI,
        rawrigidbodyset_rbIsMoving: iI,
        rawrigidbodyset_rbIsSleeping: tI,
        rawrigidbodyset_rbLinearDamping: VI,
        rawrigidbodyset_rbLinvel: pI,
        rawrigidbodyset_rbLocalCom: II,
        rawrigidbodyset_rbLockRotations: mI,
        rawrigidbodyset_rbLockTranslations: gI,
        rawrigidbodyset_rbMass: vI,
        rawrigidbodyset_rbNextRotation: rI,
        rawrigidbodyset_rbNextTranslation: nI,
        rawrigidbodyset_rbNumColliders: UI,
        rawrigidbodyset_rbPrincipalInertia: BI,
        rawrigidbodyset_rbPrincipalInertiaLocalFrame: RI,
        rawrigidbodyset_rbRecomputeMassPropertiesFromColliders: dI,
        rawrigidbodyset_rbResetForces: ZI,
        rawrigidbodyset_rbResetTorques: $I,
        rawrigidbodyset_rbRotation: $C,
        rawrigidbodyset_rbSetAdditionalMass: uI,
        rawrigidbodyset_rbSetAdditionalMassProperties: fI,
        rawrigidbodyset_rbSetAdditionalSolverIterations: oM,
        rawrigidbodyset_rbSetAngularDamping: qI,
        rawrigidbodyset_rbSetAngvel: cI,
        rawrigidbodyset_rbSetBodyType: OI,
        rawrigidbodyset_rbSetDominanceGroup: yI,
        rawrigidbodyset_rbSetEnabled: XI,
        rawrigidbodyset_rbSetEnabledRotations: wI,
        rawrigidbodyset_rbSetEnabledTranslations: _I,
        rawrigidbodyset_rbSetGravityScale: JI,
        rawrigidbodyset_rbSetLinearDamping: jI,
        rawrigidbodyset_rbSetLinvel: oI,
        rawrigidbodyset_rbSetNextKinematicRotation: hI,
        rawrigidbodyset_rbSetNextKinematicTranslation: lI,
        rawrigidbodyset_rbSetRotation: aI,
        rawrigidbodyset_rbSetSoftCcdPrediction: EI,
        rawrigidbodyset_rbSetTranslation: sI,
        rawrigidbodyset_rbSetUserData: lM,
        rawrigidbodyset_rbSleep: eI,
        rawrigidbodyset_rbSoftCcdPrediction: kI,
        rawrigidbodyset_rbTranslation: ZC,
        rawrigidbodyset_rbUserData: cM,
        rawrigidbodyset_rbUserForce: hM,
        rawrigidbodyset_rbUserTorque: dM,
        rawrigidbodyset_rbWakeUp: LI,
        rawrigidbodyset_rbWorldCom: MI,
        rawrigidbodyset_remove: AM,
        rawrotation_identity: pB,
        rawrotation_new: fB,
        rawrotation_w: gB,
        rawrotation_x: AB,
        rawrotation_y: P1,
        rawrotation_z: L1,
        rawsdpmatrix3_elements: IB,
        rawserializationpipeline_deserializeAll: w1,
        rawserializationpipeline_new: _1,
        rawserializationpipeline_serializeAll: m1,
        rawshape_ball: LR,
        rawshape_capsule: kR,
        rawshape_castRay: nB,
        rawshape_castRayAndGetNormal: rB,
        rawshape_castShape: JR,
        rawshape_cone: QR,
        rawshape_contactShape: $R,
        rawshape_containsPoint: eB,
        rawshape_convexHull: qR,
        rawshape_convexMesh: YR,
        rawshape_cuboid: DR,
        rawshape_cylinder: UR,
        rawshape_halfspace: FR,
        rawshape_heightfield: HR,
        rawshape_intersectsRay: iB,
        rawshape_intersectsShape: ZR,
        rawshape_polyline: zR,
        rawshape_projectPoint: tB,
        rawshape_roundCone: OR,
        rawshape_roundConvexHull: XR,
        rawshape_roundConvexMesh: KR,
        rawshape_roundCuboid: PR,
        rawshape_roundCylinder: NR,
        rawshape_roundTriangle: jR,
        rawshape_segment: VR,
        rawshape_triangle: WR,
        rawshape_trimesh: GR,
        rawshapecasthit_normal1: oB,
        rawshapecasthit_normal2: cB,
        rawshapecasthit_time_of_impact: D1,
        rawshapecasthit_witness1: aB,
        rawshapecasthit_witness2: Z1,
        rawshapecontact_distance: E1,
        rawshapecontact_normal1: Y1,
        rawshapecontact_normal2: V1,
        rawshapecontact_point1: W1,
        rawshapecontact_point2: j1,
        rawvector_new: mB,
        rawvector_set_x: wB,
        rawvector_set_y: sD,
        rawvector_set_z: bB,
        rawvector_x: F1,
        rawvector_xyz: yB,
        rawvector_xzy: vB,
        rawvector_y: k1,
        rawvector_yxz: xB,
        rawvector_yzx: SB,
        rawvector_z: U1,
        rawvector_zero: _B,
        rawvector_zxy: EB,
        rawvector_zyx: CB,
        version: LE
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      $x(hD);
      class Qp {
        constructor(e, t, i) {
          this.x = e, this.y = t, this.z = i;
        }
      }
      class k {
        static new(e, t, i) {
          return new Qp(e, t, i);
        }
        static intoRaw(e) {
          return new U(e.x, e.y, e.z);
        }
        static zeros() {
          return k.new(0, 0, 0);
        }
        static fromRaw(e) {
          if (!e) return null;
          let t = k.new(e.x, e.y, e.z);
          return e.free(), t;
        }
        static copy(e, t) {
          e.x = t.x, e.y = t.y, e.z = t.z;
        }
      }
      class Kl {
        constructor(e, t, i, n) {
          this.x = e, this.y = t, this.z = i, this.w = n;
        }
      }
      class Ge {
        static identity() {
          return new Kl(0, 0, 0, 1);
        }
        static fromRaw(e) {
          if (!e) return null;
          let t = new Kl(e.x, e.y, e.z, e.w);
          return e.free(), t;
        }
        static intoRaw(e) {
          return new Ye(e.x, e.y, e.z, e.w);
        }
        static copy(e, t) {
          e.x = t.x, e.y = t.y, e.z = t.z, e.w = t.w;
        }
      }
      class Op {
        get m11() {
          return this.elements[0];
        }
        get m12() {
          return this.elements[1];
        }
        get m21() {
          return this.m12;
        }
        get m13() {
          return this.elements[2];
        }
        get m31() {
          return this.m13;
        }
        get m22() {
          return this.elements[3];
        }
        get m23() {
          return this.elements[4];
        }
        get m32() {
          return this.m23;
        }
        get m33() {
          return this.elements[5];
        }
        constructor(e) {
          this.elements = e;
        }
      }
      class Jl {
        static fromRaw(e) {
          const t = new Op(e.elements());
          return e.free(), t;
        }
      }
      var Wi;
      (function(s) {
        s[s.Dynamic = 0] = "Dynamic", s[s.Fixed = 1] = "Fixed", s[s.KinematicPositionBased = 2] = "KinematicPositionBased", s[s.KinematicVelocityBased = 3] = "KinematicVelocityBased";
      })(Wi || (Wi = {}));
      class Zl {
        constructor(e, t, i) {
          this.rawSet = e, this.colliderSet = t, this.handle = i;
        }
        finalizeDeserialization(e) {
          this.colliderSet = e;
        }
        isValid() {
          return this.rawSet.contains(this.handle);
        }
        lockTranslations(e, t) {
          return this.rawSet.rbLockTranslations(this.handle, e, t);
        }
        lockRotations(e, t) {
          return this.rawSet.rbLockRotations(this.handle, e, t);
        }
        setEnabledTranslations(e, t, i, n) {
          return this.rawSet.rbSetEnabledTranslations(this.handle, e, t, i, n);
        }
        restrictTranslations(e, t, i, n) {
          this.setEnabledTranslations(e, t, i, n);
        }
        setEnabledRotations(e, t, i, n) {
          return this.rawSet.rbSetEnabledRotations(this.handle, e, t, i, n);
        }
        restrictRotations(e, t, i, n) {
          this.setEnabledRotations(e, t, i, n);
        }
        dominanceGroup() {
          return this.rawSet.rbDominanceGroup(this.handle);
        }
        setDominanceGroup(e) {
          this.rawSet.rbSetDominanceGroup(this.handle, e);
        }
        additionalSolverIterations() {
          return this.rawSet.rbAdditionalSolverIterations(this.handle);
        }
        setAdditionalSolverIterations(e) {
          this.rawSet.rbSetAdditionalSolverIterations(this.handle, e);
        }
        enableCcd(e) {
          this.rawSet.rbEnableCcd(this.handle, e);
        }
        setSoftCcdPrediction(e) {
          this.rawSet.rbSetSoftCcdPrediction(this.handle, e);
        }
        softCcdPrediction() {
          return this.rawSet.rbSoftCcdPrediction(this.handle);
        }
        translation() {
          let e = this.rawSet.rbTranslation(this.handle);
          return k.fromRaw(e);
        }
        rotation() {
          let e = this.rawSet.rbRotation(this.handle);
          return Ge.fromRaw(e);
        }
        nextTranslation() {
          let e = this.rawSet.rbNextTranslation(this.handle);
          return k.fromRaw(e);
        }
        nextRotation() {
          let e = this.rawSet.rbNextRotation(this.handle);
          return Ge.fromRaw(e);
        }
        setTranslation(e, t) {
          this.rawSet.rbSetTranslation(this.handle, e.x, e.y, e.z, t);
        }
        setLinvel(e, t) {
          let i = k.intoRaw(e);
          this.rawSet.rbSetLinvel(this.handle, i, t), i.free();
        }
        gravityScale() {
          return this.rawSet.rbGravityScale(this.handle);
        }
        setGravityScale(e, t) {
          this.rawSet.rbSetGravityScale(this.handle, e, t);
        }
        setRotation(e, t) {
          this.rawSet.rbSetRotation(this.handle, e.x, e.y, e.z, e.w, t);
        }
        setAngvel(e, t) {
          let i = k.intoRaw(e);
          this.rawSet.rbSetAngvel(this.handle, i, t), i.free();
        }
        setNextKinematicTranslation(e) {
          this.rawSet.rbSetNextKinematicTranslation(this.handle, e.x, e.y, e.z);
        }
        setNextKinematicRotation(e) {
          this.rawSet.rbSetNextKinematicRotation(this.handle, e.x, e.y, e.z, e.w);
        }
        linvel() {
          return k.fromRaw(this.rawSet.rbLinvel(this.handle));
        }
        angvel() {
          return k.fromRaw(this.rawSet.rbAngvel(this.handle));
        }
        mass() {
          return this.rawSet.rbMass(this.handle);
        }
        effectiveInvMass() {
          return k.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));
        }
        invMass() {
          return this.rawSet.rbInvMass(this.handle);
        }
        localCom() {
          return k.fromRaw(this.rawSet.rbLocalCom(this.handle));
        }
        worldCom() {
          return k.fromRaw(this.rawSet.rbWorldCom(this.handle));
        }
        invPrincipalInertiaSqrt() {
          return k.fromRaw(this.rawSet.rbInvPrincipalInertiaSqrt(this.handle));
        }
        principalInertia() {
          return k.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));
        }
        principalInertiaLocalFrame() {
          return Ge.fromRaw(this.rawSet.rbPrincipalInertiaLocalFrame(this.handle));
        }
        effectiveWorldInvInertiaSqrt() {
          return Jl.fromRaw(this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle));
        }
        effectiveAngularInertia() {
          return Jl.fromRaw(this.rawSet.rbEffectiveAngularInertia(this.handle));
        }
        sleep() {
          this.rawSet.rbSleep(this.handle);
        }
        wakeUp() {
          this.rawSet.rbWakeUp(this.handle);
        }
        isCcdEnabled() {
          return this.rawSet.rbIsCcdEnabled(this.handle);
        }
        numColliders() {
          return this.rawSet.rbNumColliders(this.handle);
        }
        collider(e) {
          return this.colliderSet.get(this.rawSet.rbCollider(this.handle, e));
        }
        setEnabled(e) {
          this.rawSet.rbSetEnabled(this.handle, e);
        }
        isEnabled() {
          return this.rawSet.rbIsEnabled(this.handle);
        }
        bodyType() {
          return this.rawSet.rbBodyType(this.handle);
        }
        setBodyType(e, t) {
          return this.rawSet.rbSetBodyType(this.handle, e, t);
        }
        isSleeping() {
          return this.rawSet.rbIsSleeping(this.handle);
        }
        isMoving() {
          return this.rawSet.rbIsMoving(this.handle);
        }
        isFixed() {
          return this.rawSet.rbIsFixed(this.handle);
        }
        isKinematic() {
          return this.rawSet.rbIsKinematic(this.handle);
        }
        isDynamic() {
          return this.rawSet.rbIsDynamic(this.handle);
        }
        linearDamping() {
          return this.rawSet.rbLinearDamping(this.handle);
        }
        angularDamping() {
          return this.rawSet.rbAngularDamping(this.handle);
        }
        setLinearDamping(e) {
          this.rawSet.rbSetLinearDamping(this.handle, e);
        }
        recomputeMassPropertiesFromColliders() {
          this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);
        }
        setAdditionalMass(e, t) {
          this.rawSet.rbSetAdditionalMass(this.handle, e, t);
        }
        setAdditionalMassProperties(e, t, i, n, r) {
          let a = k.intoRaw(t), o = k.intoRaw(i), c = Ge.intoRaw(n);
          this.rawSet.rbSetAdditionalMassProperties(this.handle, e, a, o, c, r), a.free(), o.free(), c.free();
        }
        setAngularDamping(e) {
          this.rawSet.rbSetAngularDamping(this.handle, e);
        }
        resetForces(e) {
          this.rawSet.rbResetForces(this.handle, e);
        }
        resetTorques(e) {
          this.rawSet.rbResetTorques(this.handle, e);
        }
        addForce(e, t) {
          const i = k.intoRaw(e);
          this.rawSet.rbAddForce(this.handle, i, t), i.free();
        }
        applyImpulse(e, t) {
          const i = k.intoRaw(e);
          this.rawSet.rbApplyImpulse(this.handle, i, t), i.free();
        }
        addTorque(e, t) {
          const i = k.intoRaw(e);
          this.rawSet.rbAddTorque(this.handle, i, t), i.free();
        }
        applyTorqueImpulse(e, t) {
          const i = k.intoRaw(e);
          this.rawSet.rbApplyTorqueImpulse(this.handle, i, t), i.free();
        }
        addForceAtPoint(e, t, i) {
          const n = k.intoRaw(e), r = k.intoRaw(t);
          this.rawSet.rbAddForceAtPoint(this.handle, n, r, i), n.free(), r.free();
        }
        applyImpulseAtPoint(e, t, i) {
          const n = k.intoRaw(e), r = k.intoRaw(t);
          this.rawSet.rbApplyImpulseAtPoint(this.handle, n, r, i), n.free(), r.free();
        }
        userForce() {
          return k.fromRaw(this.rawSet.rbUserForce(this.handle));
        }
        userTorque() {
          return k.fromRaw(this.rawSet.rbUserTorque(this.handle));
        }
      }
      class rn {
        constructor(e) {
          this.enabled = true, this.status = e, this.translation = k.zeros(), this.rotation = Ge.identity(), this.gravityScale = 1, this.linvel = k.zeros(), this.mass = 0, this.massOnly = false, this.centerOfMass = k.zeros(), this.translationsEnabledX = true, this.translationsEnabledY = true, this.angvel = k.zeros(), this.principalAngularInertia = k.zeros(), this.angularInertiaLocalFrame = Ge.identity(), this.translationsEnabledZ = true, this.rotationsEnabledX = true, this.rotationsEnabledY = true, this.rotationsEnabledZ = true, this.linearDamping = 0, this.angularDamping = 0, this.canSleep = true, this.sleeping = false, this.ccdEnabled = false, this.softCcdPrediction = 0, this.dominanceGroup = 0, this.additionalSolverIterations = 0;
        }
        static dynamic() {
          return new rn(Wi.Dynamic);
        }
        static kinematicPositionBased() {
          return new rn(Wi.KinematicPositionBased);
        }
        static kinematicVelocityBased() {
          return new rn(Wi.KinematicVelocityBased);
        }
        static fixed() {
          return new rn(Wi.Fixed);
        }
        static newDynamic() {
          return new rn(Wi.Dynamic);
        }
        static newKinematicPositionBased() {
          return new rn(Wi.KinematicPositionBased);
        }
        static newKinematicVelocityBased() {
          return new rn(Wi.KinematicVelocityBased);
        }
        static newStatic() {
          return new rn(Wi.Fixed);
        }
        setDominanceGroup(e) {
          return this.dominanceGroup = e, this;
        }
        setAdditionalSolverIterations(e) {
          return this.additionalSolverIterations = e, this;
        }
        setEnabled(e) {
          return this.enabled = e, this;
        }
        setTranslation(e, t, i) {
          if (typeof e != "number" || typeof t != "number" || typeof i != "number") throw TypeError("The translation components must be numbers.");
          return this.translation = {
            x: e,
            y: t,
            z: i
          }, this;
        }
        setRotation(e) {
          return Ge.copy(this.rotation, e), this;
        }
        setGravityScale(e) {
          return this.gravityScale = e, this;
        }
        setAdditionalMass(e) {
          return this.mass = e, this.massOnly = true, this;
        }
        setLinvel(e, t, i) {
          if (typeof e != "number" || typeof t != "number" || typeof i != "number") throw TypeError("The linvel components must be numbers.");
          return this.linvel = {
            x: e,
            y: t,
            z: i
          }, this;
        }
        setAngvel(e) {
          return k.copy(this.angvel, e), this;
        }
        setAdditionalMassProperties(e, t, i, n) {
          return this.mass = e, k.copy(this.centerOfMass, t), k.copy(this.principalAngularInertia, i), Ge.copy(this.angularInertiaLocalFrame, n), this.massOnly = false, this;
        }
        enabledTranslations(e, t, i) {
          return this.translationsEnabledX = e, this.translationsEnabledY = t, this.translationsEnabledZ = i, this;
        }
        restrictTranslations(e, t, i) {
          return this.enabledTranslations(e, t, i);
        }
        lockTranslations() {
          return this.enabledTranslations(false, false, false);
        }
        enabledRotations(e, t, i) {
          return this.rotationsEnabledX = e, this.rotationsEnabledY = t, this.rotationsEnabledZ = i, this;
        }
        restrictRotations(e, t, i) {
          return this.enabledRotations(e, t, i);
        }
        lockRotations() {
          return this.restrictRotations(false, false, false);
        }
        setLinearDamping(e) {
          return this.linearDamping = e, this;
        }
        setAngularDamping(e) {
          return this.angularDamping = e, this;
        }
        setCanSleep(e) {
          return this.canSleep = e, this;
        }
        setSleeping(e) {
          return this.sleeping = e, this;
        }
        setCcdEnabled(e) {
          return this.ccdEnabled = e, this;
        }
        setSoftCcdPrediction(e) {
          return this.softCcdPrediction = e, this;
        }
        setUserData(e) {
          return this.userData = e, this;
        }
      }
      class Xo {
        constructor() {
          this.fconv = new Float64Array(1), this.uconv = new Uint32Array(this.fconv.buffer), this.data = new Array(), this.size = 0;
        }
        set(e, t) {
          let i = this.index(e);
          for (; this.data.length <= i; ) this.data.push(null);
          this.data[i] == null && (this.size += 1), this.data[i] = t;
        }
        len() {
          return this.size;
        }
        delete(e) {
          let t = this.index(e);
          t < this.data.length && (this.data[t] != null && (this.size -= 1), this.data[t] = null);
        }
        clear() {
          this.data = new Array();
        }
        get(e) {
          let t = this.index(e);
          return t < this.data.length ? this.data[t] : null;
        }
        forEach(e) {
          for (const t of this.data) t != null && e(t);
        }
        getAll() {
          return this.data.filter((e) => e != null);
        }
        index(e) {
          return this.fconv[0] = e, this.uconv[0];
        }
      }
      class zp {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(e) {
          this.raw = e || new Et(), this.map = new Xo(), e && e.forEachRigidBodyHandle((t) => {
            this.map.set(t, new Zl(e, null, t));
          });
        }
        finalizeDeserialization(e) {
          this.map.forEach((t) => t.finalizeDeserialization(e));
        }
        createRigidBody(e, t) {
          let i = k.intoRaw(t.translation), n = Ge.intoRaw(t.rotation), r = k.intoRaw(t.linvel), a = k.intoRaw(t.centerOfMass), o = k.intoRaw(t.angvel), c = k.intoRaw(t.principalAngularInertia), l = Ge.intoRaw(t.angularInertiaLocalFrame), h = this.raw.createRigidBody(t.enabled, i, n, t.gravityScale, t.mass, t.massOnly, a, r, o, c, l, t.translationsEnabledX, t.translationsEnabledY, t.translationsEnabledZ, t.rotationsEnabledX, t.rotationsEnabledY, t.rotationsEnabledZ, t.linearDamping, t.angularDamping, t.status, t.canSleep, t.sleeping, t.softCcdPrediction, t.ccdEnabled, t.dominanceGroup, t.additionalSolverIterations);
          i.free(), n.free(), r.free(), a.free(), o.free(), c.free(), l.free();
          const d = new Zl(this.raw, e, h);
          return d.userData = t.userData, this.map.set(h, d), d;
        }
        remove(e, t, i, n, r) {
          for (let a = 0; a < this.raw.rbNumColliders(e); a += 1) i.unmap(this.raw.rbCollider(e, a));
          n.forEachJointHandleAttachedToRigidBody(e, (a) => n.unmap(a)), r.forEachJointHandleAttachedToRigidBody(e, (a) => r.unmap(a)), this.raw.remove(e, t.raw, i.raw, n.raw, r.raw), this.map.delete(e);
        }
        len() {
          return this.map.len();
        }
        contains(e) {
          return this.get(e) != null;
        }
        get(e) {
          return this.map.get(e);
        }
        forEach(e) {
          this.map.forEach(e);
        }
        forEachActiveRigidBody(e, t) {
          e.forEachActiveRigidBodyHandle((i) => {
            t(this.get(i));
          });
        }
        getAll() {
          return this.map.getAll();
        }
      }
      class Gp {
        constructor(e) {
          this.raw = e || new br();
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        get dt() {
          return this.raw.dt;
        }
        get contact_erp() {
          return this.raw.contact_erp;
        }
        get lengthUnit() {
          return this.raw.lengthUnit;
        }
        get normalizedAllowedLinearError() {
          return this.raw.normalizedAllowedLinearError;
        }
        get normalizedPredictionDistance() {
          return this.raw.normalizedPredictionDistance;
        }
        get numSolverIterations() {
          return this.raw.numSolverIterations;
        }
        get numAdditionalFrictionIterations() {
          return this.raw.numAdditionalFrictionIterations;
        }
        get numInternalPgsIterations() {
          return this.raw.numInternalPgsIterations;
        }
        get minIslandSize() {
          return this.raw.minIslandSize;
        }
        get maxCcdSubsteps() {
          return this.raw.maxCcdSubsteps;
        }
        set dt(e) {
          this.raw.dt = e;
        }
        set contact_natural_frequency(e) {
          this.raw.contact_natural_frequency = e;
        }
        set lengthUnit(e) {
          this.raw.lengthUnit = e;
        }
        set normalizedAllowedLinearError(e) {
          this.raw.normalizedAllowedLinearError = e;
        }
        set normalizedPredictionDistance(e) {
          this.raw.normalizedPredictionDistance = e;
        }
        set numSolverIterations(e) {
          this.raw.numSolverIterations = e;
        }
        set numAdditionalFrictionIterations(e) {
          this.raw.numAdditionalFrictionIterations = e;
        }
        set numInternalPgsIterations(e) {
          this.raw.numInternalPgsIterations = e;
        }
        set minIslandSize(e) {
          this.raw.minIslandSize = e;
        }
        set maxCcdSubsteps(e) {
          this.raw.maxCcdSubsteps = e;
        }
        switchToStandardPgsSolver() {
          this.raw.switchToStandardPgsSolver();
        }
        switchToSmallStepsPgsSolver() {
          this.raw.switchToSmallStepsPgsSolver();
        }
        switchToSmallStepsPgsSolverWithoutWarmstart() {
          this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();
        }
      }
      var ti;
      (function(s) {
        s[s.Revolute = 0] = "Revolute", s[s.Fixed = 1] = "Fixed", s[s.Prismatic = 2] = "Prismatic", s[s.Rope = 3] = "Rope", s[s.Spring = 4] = "Spring", s[s.Spherical = 5] = "Spherical", s[s.Generic = 6] = "Generic";
      })(ti || (ti = {}));
      var $l;
      (function(s) {
        s[s.AccelerationBased = 0] = "AccelerationBased", s[s.ForceBased = 1] = "ForceBased";
      })($l || ($l = {}));
      var eh;
      (function(s) {
        s[s.LinX = 1] = "LinX", s[s.LinY = 2] = "LinY", s[s.LinZ = 4] = "LinZ", s[s.AngX = 8] = "AngX", s[s.AngY = 16] = "AngY", s[s.AngZ = 32] = "AngZ";
      })(eh || (eh = {}));
      class tn {
        constructor(e, t, i) {
          this.rawSet = e, this.bodySet = t, this.handle = i;
        }
        static newTyped(e, t, i) {
          switch (e.jointType(i)) {
            case qi.Revolute:
              return new qp(e, t, i);
            case qi.Prismatic:
              return new jp(e, t, i);
            case qi.Fixed:
              return new Hp(e, t, i);
            case qi.Spring:
              return new Wp(e, t, i);
            case qi.Rope:
              return new Vp(e, t, i);
            case qi.Spherical:
              return new Yp(e, t, i);
            case qi.Generic:
              return new Xp(e, t, i);
            default:
              return new tn(e, t, i);
          }
        }
        finalizeDeserialization(e) {
          this.bodySet = e;
        }
        isValid() {
          return this.rawSet.contains(this.handle);
        }
        body1() {
          return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));
        }
        body2() {
          return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));
        }
        type() {
          return this.rawSet.jointType(this.handle);
        }
        frameX1() {
          return Ge.fromRaw(this.rawSet.jointFrameX1(this.handle));
        }
        frameX2() {
          return Ge.fromRaw(this.rawSet.jointFrameX2(this.handle));
        }
        anchor1() {
          return k.fromRaw(this.rawSet.jointAnchor1(this.handle));
        }
        anchor2() {
          return k.fromRaw(this.rawSet.jointAnchor2(this.handle));
        }
        setAnchor1(e) {
          const t = k.intoRaw(e);
          this.rawSet.jointSetAnchor1(this.handle, t), t.free();
        }
        setAnchor2(e) {
          const t = k.intoRaw(e);
          this.rawSet.jointSetAnchor2(this.handle, t), t.free();
        }
        setContactsEnabled(e) {
          this.rawSet.jointSetContactsEnabled(this.handle, e);
        }
        contactsEnabled() {
          return this.rawSet.jointContactsEnabled(this.handle);
        }
      }
      class Kh extends tn {
        limitsEnabled() {
          return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());
        }
        limitsMin() {
          return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());
        }
        limitsMax() {
          return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());
        }
        setLimits(e, t) {
          this.rawSet.jointSetLimits(this.handle, this.rawAxis(), e, t);
        }
        configureMotorModel(e) {
          this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), e);
        }
        configureMotorVelocity(e, t) {
          this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), e, t);
        }
        configureMotorPosition(e, t, i) {
          this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), e, t, i);
        }
        configureMotor(e, t, i, n) {
          this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), e, t, i, n);
        }
      }
      class Hp extends tn {
      }
      class Vp extends tn {
      }
      class Wp extends tn {
      }
      class jp extends Kh {
        rawAxis() {
          return Go.LinX;
        }
      }
      class qp extends Kh {
        rawAxis() {
          return Go.AngX;
        }
      }
      class Xp extends tn {
      }
      class Yp extends tn {
      }
      class wn {
        constructor() {
        }
        static fixed(e, t, i, n) {
          let r = new wn();
          return r.anchor1 = e, r.anchor2 = i, r.frame1 = t, r.frame2 = n, r.jointType = ti.Fixed, r;
        }
        static spring(e, t, i, n, r) {
          let a = new wn();
          return a.anchor1 = n, a.anchor2 = r, a.length = e, a.stiffness = t, a.damping = i, a.jointType = ti.Spring, a;
        }
        static rope(e, t, i) {
          let n = new wn();
          return n.anchor1 = t, n.anchor2 = i, n.length = e, n.jointType = ti.Rope, n;
        }
        static generic(e, t, i, n) {
          let r = new wn();
          return r.anchor1 = e, r.anchor2 = t, r.axis = i, r.axesMask = n, r.jointType = ti.Generic, r;
        }
        static spherical(e, t) {
          let i = new wn();
          return i.anchor1 = e, i.anchor2 = t, i.jointType = ti.Spherical, i;
        }
        static prismatic(e, t, i) {
          let n = new wn();
          return n.anchor1 = e, n.anchor2 = t, n.axis = i, n.jointType = ti.Prismatic, n;
        }
        static revolute(e, t, i) {
          let n = new wn();
          return n.anchor1 = e, n.anchor2 = t, n.axis = i, n.jointType = ti.Revolute, n;
        }
        intoRaw() {
          let e = k.intoRaw(this.anchor1), t = k.intoRaw(this.anchor2), i, n, r = false, a = 0, o = 0;
          switch (this.jointType) {
            case ti.Fixed:
              let c = Ge.intoRaw(this.frame1), l = Ge.intoRaw(this.frame2);
              n = Zt.fixed(e, c, t, l), c.free(), l.free();
              break;
            case ti.Spring:
              n = Zt.spring(this.length, this.stiffness, this.damping, e, t);
              break;
            case ti.Rope:
              n = Zt.rope(this.length, e, t);
              break;
            case ti.Prismatic:
              i = k.intoRaw(this.axis), this.limitsEnabled && (r = true, a = this.limits[0], o = this.limits[1]), n = Zt.prismatic(e, t, i, r, a, o), i.free();
              break;
            case ti.Generic:
              i = k.intoRaw(this.axis);
              let h = this.axesMask;
              n = Zt.generic(e, t, i, h);
              break;
            case ti.Spherical:
              n = Zt.spherical(e, t);
              break;
            case ti.Revolute:
              i = k.intoRaw(this.axis), n = Zt.revolute(e, t, i), i.free();
              break;
          }
          return e.free(), t.free(), n;
        }
      }
      class Kp {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(e) {
          this.raw = e || new In(), this.map = new Xo(), e && e.forEachJointHandle((t) => {
            this.map.set(t, tn.newTyped(e, null, t));
          });
        }
        finalizeDeserialization(e) {
          this.map.forEach((t) => t.finalizeDeserialization(e));
        }
        createJoint(e, t, i, n, r) {
          const a = t.intoRaw(), o = this.raw.createJoint(a, i, n, r);
          a.free();
          let c = tn.newTyped(this.raw, e, o);
          return this.map.set(o, c), c;
        }
        remove(e, t) {
          this.raw.remove(e, t), this.unmap(e);
        }
        forEachJointHandleAttachedToRigidBody(e, t) {
          this.raw.forEachJointAttachedToRigidBody(e, t);
        }
        unmap(e) {
          this.map.delete(e);
        }
        len() {
          return this.map.len();
        }
        contains(e) {
          return this.get(e) != null;
        }
        get(e) {
          return this.map.get(e);
        }
        forEach(e) {
          this.map.forEach(e);
        }
        getAll() {
          return this.map.getAll();
        }
      }
      class Wn {
        constructor(e, t) {
          this.rawSet = e, this.handle = t;
        }
        static newTyped(e, t) {
          switch (e.jointType(t)) {
            case qi.Revolute:
              return new $p(e, t);
            case qi.Prismatic:
              return new Zp(e, t);
            case qi.Fixed:
              return new Jp(e, t);
            case qi.Spherical:
              return new eA(e, t);
            default:
              return new Wn(e, t);
          }
        }
        isValid() {
          return this.rawSet.contains(this.handle);
        }
        setContactsEnabled(e) {
          this.rawSet.jointSetContactsEnabled(this.handle, e);
        }
        contactsEnabled() {
          return this.rawSet.jointContactsEnabled(this.handle);
        }
      }
      class Jh extends Wn {
      }
      class Jp extends Wn {
      }
      class Zp extends Jh {
        rawAxis() {
          return Go.LinX;
        }
      }
      class $p extends Jh {
        rawAxis() {
          return Go.AngX;
        }
      }
      class eA extends Wn {
      }
      class tA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(e) {
          this.raw = e || new Tn(), this.map = new Xo(), e && e.forEachJointHandle((t) => {
            this.map.set(t, Wn.newTyped(this.raw, t));
          });
        }
        createJoint(e, t, i, n) {
          const r = e.intoRaw(), a = this.raw.createJoint(r, t, i, n);
          r.free();
          let o = Wn.newTyped(this.raw, a);
          return this.map.set(a, o), o;
        }
        remove(e, t) {
          this.raw.remove(e, t), this.map.delete(e);
        }
        unmap(e) {
          this.map.delete(e);
        }
        len() {
          return this.map.len();
        }
        contains(e) {
          return this.get(e) != null;
        }
        get(e) {
          return this.map.get(e);
        }
        forEach(e) {
          this.map.forEach(e);
        }
        forEachJointHandleAttachedToRigidBody(e, t) {
          this.raw.forEachJointAttachedToRigidBody(e, t);
        }
        getAll() {
          return this.map.getAll();
        }
      }
      var $s;
      (function(s) {
        s[s.Average = 0] = "Average", s[s.Min = 1] = "Min", s[s.Multiply = 2] = "Multiply", s[s.Max = 3] = "Max";
      })($s || ($s = {}));
      class iA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new Yl();
        }
      }
      class nA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new Mn();
        }
        forEachActiveRigidBodyHandle(e) {
          this.raw.forEachActiveRigidBodyHandle(e);
        }
      }
      class rA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new wr();
        }
      }
      class sA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new Vn(), this.tempManifold = new aA(null);
        }
        contactPairsWith(e, t) {
          this.raw.contact_pairs_with(e, t);
        }
        intersectionPairsWith(e, t) {
          this.raw.intersection_pairs_with(e, t);
        }
        contactPair(e, t, i) {
          const n = this.raw.contact_pair(e, t);
          if (n) {
            const r = n.collider1() != e;
            let a;
            for (a = 0; a < n.numContactManifolds(); ++a) this.tempManifold.raw = n.contactManifold(a), this.tempManifold.raw && i(this.tempManifold, r), this.tempManifold.free();
            n.free();
          }
        }
        intersectionPair(e, t) {
          return this.raw.intersection_pair(e, t);
        }
      }
      class aA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e;
        }
        normal() {
          return k.fromRaw(this.raw.normal());
        }
        localNormal1() {
          return k.fromRaw(this.raw.local_n1());
        }
        localNormal2() {
          return k.fromRaw(this.raw.local_n2());
        }
        subshape1() {
          return this.raw.subshape1();
        }
        subshape2() {
          return this.raw.subshape2();
        }
        numContacts() {
          return this.raw.num_contacts();
        }
        localContactPoint1(e) {
          return k.fromRaw(this.raw.contact_local_p1(e));
        }
        localContactPoint2(e) {
          return k.fromRaw(this.raw.contact_local_p2(e));
        }
        contactDist(e) {
          return this.raw.contact_dist(e);
        }
        contactFid1(e) {
          return this.raw.contact_fid1(e);
        }
        contactFid2(e) {
          return this.raw.contact_fid2(e);
        }
        contactImpulse(e) {
          return this.raw.contact_impulse(e);
        }
        contactTangentImpulseX(e) {
          return this.raw.contact_tangent_impulse_x(e);
        }
        contactTangentImpulseY(e) {
          return this.raw.contact_tangent_impulse_y(e);
        }
        numSolverContacts() {
          return this.raw.num_solver_contacts();
        }
        solverContactPoint(e) {
          return k.fromRaw(this.raw.solver_contact_point(e));
        }
        solverContactDist(e) {
          return this.raw.solver_contact_dist(e);
        }
        solverContactFriction(e) {
          return this.raw.solver_contact_friction(e);
        }
        solverContactRestitution(e) {
          return this.raw.solver_contact_restitution(e);
        }
        solverContactTangentVelocity(e) {
          return k.fromRaw(this.raw.solver_contact_tangent_velocity(e));
        }
      }
      class rs {
        constructor(e, t, i, n, r) {
          this.distance = e, this.point1 = t, this.point2 = i, this.normal1 = n, this.normal2 = r;
        }
        static fromRaw(e) {
          if (!e) return null;
          const t = new rs(e.distance(), k.fromRaw(e.point1()), k.fromRaw(e.point2()), k.fromRaw(e.normal1()), k.fromRaw(e.normal2()));
          return e.free(), t;
        }
      }
      var ss;
      (function(s) {
        s[s.Vertex = 0] = "Vertex", s[s.Edge = 1] = "Edge", s[s.Face = 2] = "Face", s[s.Unknown = 3] = "Unknown";
      })(ss || (ss = {}));
      class la {
        constructor(e, t) {
          this.point = e, this.isInside = t;
        }
        static fromRaw(e) {
          if (!e) return null;
          const t = new la(k.fromRaw(e.point()), e.isInside());
          return e.free(), t;
        }
      }
      class ea {
        constructor(e, t, i, n, r) {
          this.featureType = ss.Unknown, this.featureId = void 0, this.collider = e, this.point = t, this.isInside = i, r !== void 0 && (this.featureId = r), n !== void 0 && (this.featureType = n);
        }
        static fromRaw(e, t) {
          if (!t) return null;
          const i = new ea(e.get(t.colliderHandle()), k.fromRaw(t.point()), t.isInside(), t.featureType(), t.featureId());
          return t.free(), i;
        }
      }
      class dD {
        constructor(e, t) {
          this.origin = e, this.dir = t;
        }
        pointAt(e) {
          return {
            x: this.origin.x + this.dir.x * e,
            y: this.origin.y + this.dir.y * e,
            z: this.origin.z + this.dir.z * e
          };
        }
      }
      class ha {
        constructor(e, t, i, n) {
          this.featureType = ss.Unknown, this.featureId = void 0, this.timeOfImpact = e, this.normal = t, n !== void 0 && (this.featureId = n), i !== void 0 && (this.featureType = i);
        }
        static fromRaw(e) {
          if (!e) return null;
          const t = new ha(e.time_of_impact(), k.fromRaw(e.normal()), e.featureType(), e.featureId());
          return e.free(), t;
        }
      }
      class ta {
        constructor(e, t, i, n, r) {
          this.featureType = ss.Unknown, this.featureId = void 0, this.collider = e, this.timeOfImpact = t, this.normal = i, r !== void 0 && (this.featureId = r), n !== void 0 && (this.featureType = n);
        }
        static fromRaw(e, t) {
          if (!t) return null;
          const i = new ta(e.get(t.colliderHandle()), t.time_of_impact(), k.fromRaw(t.normal()), t.featureType(), t.featureId());
          return t.free(), i;
        }
      }
      class Yo {
        constructor(e, t) {
          this.collider = e, this.timeOfImpact = t;
        }
        static fromRaw(e, t) {
          if (!t) return null;
          const i = new Yo(e.get(t.colliderHandle()), t.timeOfImpact());
          return t.free(), i;
        }
      }
      class us {
        constructor(e, t, i, n, r) {
          this.time_of_impact = e, this.witness1 = t, this.witness2 = i, this.normal1 = n, this.normal2 = r;
        }
        static fromRaw(e, t) {
          if (!t) return null;
          const i = new us(t.time_of_impact(), k.fromRaw(t.witness1()), k.fromRaw(t.witness2()), k.fromRaw(t.normal1()), k.fromRaw(t.normal2()));
          return t.free(), i;
        }
      }
      class da extends us {
        constructor(e, t, i, n, r, a) {
          super(t, i, n, r, a), this.collider = e;
        }
        static fromRaw(e, t) {
          if (!t) return null;
          const i = new da(e.get(t.colliderHandle()), t.time_of_impact(), k.fromRaw(t.witness1()), k.fromRaw(t.witness2()), k.fromRaw(t.normal1()), k.fromRaw(t.normal2()));
          return t.free(), i;
        }
      }
      class Xt {
        static fromRaw(e, t) {
          const i = e.coShapeType(t);
          let n, r, a, o, c, l, h;
          switch (i) {
            case ei.Ball:
              return new Zh(e.coRadius(t));
            case ei.Cuboid:
              return n = e.coHalfExtents(t), new $h(n.x, n.y, n.z);
            case ei.RoundCuboid:
              return n = e.coHalfExtents(t), r = e.coRoundRadius(t), new ed(n.x, n.y, n.z, r);
            case ei.Capsule:
              return c = e.coHalfHeight(t), l = e.coRadius(t), new td(c, l);
            case ei.Segment:
              return a = e.coVertices(t), new id(k.new(a[0], a[1], a[2]), k.new(a[3], a[4], a[5]));
            case ei.Polyline:
              return a = e.coVertices(t), o = e.coIndices(t), new sd(a, o);
            case ei.Triangle:
              return a = e.coVertices(t), new nd(k.new(a[0], a[1], a[2]), k.new(a[3], a[4], a[5]), k.new(a[6], a[7], a[8]));
            case ei.RoundTriangle:
              return a = e.coVertices(t), r = e.coRoundRadius(t), new rd(k.new(a[0], a[1], a[2]), k.new(a[3], a[4], a[5]), k.new(a[6], a[7], a[8]), r);
            case ei.HalfSpace:
              return h = k.fromRaw(e.coHalfspaceNormal(t)), new oA(h);
            case ei.TriMesh:
              a = e.coVertices(t), o = e.coIndices(t);
              const d = e.coTriMeshFlags(t);
              return new ad(a, o, d);
            case ei.HeightField:
              const u = e.coHeightfieldScale(t), f = e.coHeightfieldHeights(t), p = e.coHeightfieldNRows(t), m = e.coHeightfieldNCols(t), g = e.coHeightFieldFlags(t);
              return new od(p, m, f, u, g);
            case ei.ConvexPolyhedron:
              return a = e.coVertices(t), o = e.coIndices(t), new Io(a, o);
            case ei.RoundConvexPolyhedron:
              return a = e.coVertices(t), o = e.coIndices(t), r = e.coRoundRadius(t), new Mo(a, o, r);
            case ei.Cylinder:
              return c = e.coHalfHeight(t), l = e.coRadius(t), new cd(c, l);
            case ei.RoundCylinder:
              return c = e.coHalfHeight(t), l = e.coRadius(t), r = e.coRoundRadius(t), new ld(c, l, r);
            case ei.Cone:
              return c = e.coHalfHeight(t), l = e.coRadius(t), new hd(c, l);
            case ei.RoundCone:
              return c = e.coHalfHeight(t), l = e.coRadius(t), r = e.coRoundRadius(t), new dd(c, l, r);
            default:
              throw new Error("unknown shape type: " + i);
          }
        }
        castShape(e, t, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(e), u = Ge.intoRaw(t), f = k.intoRaw(i), p = k.intoRaw(r), m = Ge.intoRaw(a), g = k.intoRaw(o), A = this.intoRaw(), x = n.intoRaw(), b = us.fromRaw(null, A.castShape(d, u, f, x, p, m, g, c, l, h));
          return d.free(), u.free(), f.free(), p.free(), m.free(), g.free(), A.free(), x.free(), b;
        }
        intersectsShape(e, t, i, n, r) {
          let a = k.intoRaw(e), o = Ge.intoRaw(t), c = k.intoRaw(n), l = Ge.intoRaw(r), h = this.intoRaw(), d = i.intoRaw(), u = h.intersectsShape(a, o, d, c, l);
          return a.free(), o.free(), c.free(), l.free(), h.free(), d.free(), u;
        }
        contactShape(e, t, i, n, r, a) {
          let o = k.intoRaw(e), c = Ge.intoRaw(t), l = k.intoRaw(n), h = Ge.intoRaw(r), d = this.intoRaw(), u = i.intoRaw(), f = rs.fromRaw(d.contactShape(o, c, u, l, h, a));
          return o.free(), c.free(), l.free(), h.free(), d.free(), u.free(), f;
        }
        containsPoint(e, t, i) {
          let n = k.intoRaw(e), r = Ge.intoRaw(t), a = k.intoRaw(i), o = this.intoRaw(), c = o.containsPoint(n, r, a);
          return n.free(), r.free(), a.free(), o.free(), c;
        }
        projectPoint(e, t, i, n) {
          let r = k.intoRaw(e), a = Ge.intoRaw(t), o = k.intoRaw(i), c = this.intoRaw(), l = la.fromRaw(c.projectPoint(r, a, o, n));
          return r.free(), a.free(), o.free(), c.free(), l;
        }
        intersectsRay(e, t, i, n) {
          let r = k.intoRaw(t), a = Ge.intoRaw(i), o = k.intoRaw(e.origin), c = k.intoRaw(e.dir), l = this.intoRaw(), h = l.intersectsRay(r, a, o, c, n);
          return r.free(), a.free(), o.free(), c.free(), l.free(), h;
        }
        castRay(e, t, i, n, r) {
          let a = k.intoRaw(t), o = Ge.intoRaw(i), c = k.intoRaw(e.origin), l = k.intoRaw(e.dir), h = this.intoRaw(), d = h.castRay(a, o, c, l, n, r);
          return a.free(), o.free(), c.free(), l.free(), h.free(), d;
        }
        castRayAndGetNormal(e, t, i, n, r) {
          let a = k.intoRaw(t), o = Ge.intoRaw(i), c = k.intoRaw(e.origin), l = k.intoRaw(e.dir), h = this.intoRaw(), d = ha.fromRaw(h.castRayAndGetNormal(a, o, c, l, n, r));
          return a.free(), o.free(), c.free(), l.free(), h.free(), d;
        }
      }
      var zt;
      (function(s) {
        s[s.Ball = 0] = "Ball", s[s.Cuboid = 1] = "Cuboid", s[s.Capsule = 2] = "Capsule", s[s.Segment = 3] = "Segment", s[s.Polyline = 4] = "Polyline", s[s.Triangle = 5] = "Triangle", s[s.TriMesh = 6] = "TriMesh", s[s.HeightField = 7] = "HeightField", s[s.ConvexPolyhedron = 9] = "ConvexPolyhedron", s[s.Cylinder = 10] = "Cylinder", s[s.Cone = 11] = "Cone", s[s.RoundCuboid = 12] = "RoundCuboid", s[s.RoundTriangle = 13] = "RoundTriangle", s[s.RoundCylinder = 14] = "RoundCylinder", s[s.RoundCone = 15] = "RoundCone", s[s.RoundConvexPolyhedron = 16] = "RoundConvexPolyhedron", s[s.HalfSpace = 17] = "HalfSpace";
      })(zt || (zt = {}));
      var th;
      (function(s) {
        s[s.FIX_INTERNAL_EDGES = 1] = "FIX_INTERNAL_EDGES";
      })(th || (th = {}));
      var ih;
      (function(s) {
        s[s.DELETE_BAD_TOPOLOGY_TRIANGLES = 4] = "DELETE_BAD_TOPOLOGY_TRIANGLES", s[s.ORIENTED = 8] = "ORIENTED", s[s.MERGE_DUPLICATE_VERTICES = 16] = "MERGE_DUPLICATE_VERTICES", s[s.DELETE_DEGENERATE_TRIANGLES = 32] = "DELETE_DEGENERATE_TRIANGLES", s[s.DELETE_DUPLICATE_TRIANGLES = 64] = "DELETE_DUPLICATE_TRIANGLES", s[s.FIX_INTERNAL_EDGES = 152] = "FIX_INTERNAL_EDGES";
      })(ih || (ih = {}));
      class Zh extends Xt {
        constructor(e) {
          super(), this.type = zt.Ball, this.radius = e;
        }
        intoRaw() {
          return Be.ball(this.radius);
        }
      }
      class oA extends Xt {
        constructor(e) {
          super(), this.type = zt.HalfSpace, this.normal = e;
        }
        intoRaw() {
          let e = k.intoRaw(this.normal), t = Be.halfspace(e);
          return e.free(), t;
        }
      }
      class $h extends Xt {
        constructor(e, t, i) {
          super(), this.type = zt.Cuboid, this.halfExtents = k.new(e, t, i);
        }
        intoRaw() {
          return Be.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);
        }
      }
      class ed extends Xt {
        constructor(e, t, i, n) {
          super(), this.type = zt.RoundCuboid, this.halfExtents = k.new(e, t, i), this.borderRadius = n;
        }
        intoRaw() {
          return Be.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);
        }
      }
      class td extends Xt {
        constructor(e, t) {
          super(), this.type = zt.Capsule, this.halfHeight = e, this.radius = t;
        }
        intoRaw() {
          return Be.capsule(this.halfHeight, this.radius);
        }
      }
      class id extends Xt {
        constructor(e, t) {
          super(), this.type = zt.Segment, this.a = e, this.b = t;
        }
        intoRaw() {
          let e = k.intoRaw(this.a), t = k.intoRaw(this.b), i = Be.segment(e, t);
          return e.free(), t.free(), i;
        }
      }
      class nd extends Xt {
        constructor(e, t, i) {
          super(), this.type = zt.Triangle, this.a = e, this.b = t, this.c = i;
        }
        intoRaw() {
          let e = k.intoRaw(this.a), t = k.intoRaw(this.b), i = k.intoRaw(this.c), n = Be.triangle(e, t, i);
          return e.free(), t.free(), i.free(), n;
        }
      }
      class rd extends Xt {
        constructor(e, t, i, n) {
          super(), this.type = zt.RoundTriangle, this.a = e, this.b = t, this.c = i, this.borderRadius = n;
        }
        intoRaw() {
          let e = k.intoRaw(this.a), t = k.intoRaw(this.b), i = k.intoRaw(this.c), n = Be.roundTriangle(e, t, i, this.borderRadius);
          return e.free(), t.free(), i.free(), n;
        }
      }
      class sd extends Xt {
        constructor(e, t) {
          super(), this.type = zt.Polyline, this.vertices = e, this.indices = t ?? new Uint32Array(0);
        }
        intoRaw() {
          return Be.polyline(this.vertices, this.indices);
        }
      }
      class ad extends Xt {
        constructor(e, t, i) {
          super(), this.type = zt.TriMesh, this.vertices = e, this.indices = t, this.flags = i;
        }
        intoRaw() {
          return Be.trimesh(this.vertices, this.indices, this.flags);
        }
      }
      class Io extends Xt {
        constructor(e, t) {
          super(), this.type = zt.ConvexPolyhedron, this.vertices = e, this.indices = t;
        }
        intoRaw() {
          return this.indices ? Be.convexMesh(this.vertices, this.indices) : Be.convexHull(this.vertices);
        }
      }
      class Mo extends Xt {
        constructor(e, t, i) {
          super(), this.type = zt.RoundConvexPolyhedron, this.vertices = e, this.indices = t, this.borderRadius = i;
        }
        intoRaw() {
          return this.indices ? Be.roundConvexMesh(this.vertices, this.indices, this.borderRadius) : Be.roundConvexHull(this.vertices, this.borderRadius);
        }
      }
      class od extends Xt {
        constructor(e, t, i, n, r) {
          super(), this.type = zt.HeightField, this.nrows = e, this.ncols = t, this.heights = i, this.scale = n, this.flags = r;
        }
        intoRaw() {
          let e = k.intoRaw(this.scale), t = Be.heightfield(this.nrows, this.ncols, this.heights, e, this.flags);
          return e.free(), t;
        }
      }
      class cd extends Xt {
        constructor(e, t) {
          super(), this.type = zt.Cylinder, this.halfHeight = e, this.radius = t;
        }
        intoRaw() {
          return Be.cylinder(this.halfHeight, this.radius);
        }
      }
      class ld extends Xt {
        constructor(e, t, i) {
          super(), this.type = zt.RoundCylinder, this.borderRadius = i, this.halfHeight = e, this.radius = t;
        }
        intoRaw() {
          return Be.roundCylinder(this.halfHeight, this.radius, this.borderRadius);
        }
      }
      class hd extends Xt {
        constructor(e, t) {
          super(), this.type = zt.Cone, this.halfHeight = e, this.radius = t;
        }
        intoRaw() {
          return Be.cone(this.halfHeight, this.radius);
        }
      }
      class dd extends Xt {
        constructor(e, t, i) {
          super(), this.type = zt.RoundCone, this.halfHeight = e, this.radius = t, this.borderRadius = i;
        }
        intoRaw() {
          return Be.roundCone(this.halfHeight, this.radius, this.borderRadius);
        }
      }
      class cA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new cE();
        }
        step(e, t, i, n, r, a, o, c, l, h, d, u) {
          let f = k.intoRaw(e);
          d ? this.raw.stepWithEvents(f, t.raw, i.raw, n.raw, r.raw, a.raw, o.raw, c.raw, l.raw, h.raw, d.raw, u, u ? u.filterContactPair : null, u ? u.filterIntersectionPair : null) : this.raw.step(f, t.raw, i.raw, n.raw, r.raw, a.raw, o.raw, c.raw, l.raw, h.raw), f.free();
        }
      }
      var nh;
      (function(s) {
        s[s.EXCLUDE_FIXED = 1] = "EXCLUDE_FIXED", s[s.EXCLUDE_KINEMATIC = 2] = "EXCLUDE_KINEMATIC", s[s.EXCLUDE_DYNAMIC = 4] = "EXCLUDE_DYNAMIC", s[s.EXCLUDE_SENSORS = 8] = "EXCLUDE_SENSORS", s[s.EXCLUDE_SOLIDS = 16] = "EXCLUDE_SOLIDS", s[s.ONLY_DYNAMIC = 3] = "ONLY_DYNAMIC", s[s.ONLY_KINEMATIC = 5] = "ONLY_KINEMATIC", s[s.ONLY_FIXED = 6] = "ONLY_FIXED";
      })(nh || (nh = {}));
      class lA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new Xh();
        }
        update(e) {
          this.raw.update(e.raw);
        }
        castRay(e, t, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(i.origin), u = k.intoRaw(i.dir), f = Yo.fromRaw(t, this.raw.castRay(e.raw, t.raw, d, u, n, r, a, o, c, l, h));
          return d.free(), u.free(), f;
        }
        castRayAndGetNormal(e, t, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(i.origin), u = k.intoRaw(i.dir), f = ta.fromRaw(t, this.raw.castRayAndGetNormal(e.raw, t.raw, d, u, n, r, a, o, c, l, h));
          return d.free(), u.free(), f;
        }
        intersectionsWithRay(e, t, i, n, r, a, o, c, l, h, d) {
          let u = k.intoRaw(i.origin), f = k.intoRaw(i.dir), p = (m) => a(ta.fromRaw(t, m));
          this.raw.intersectionsWithRay(e.raw, t.raw, u, f, n, r, p, o, c, l, h, d), u.free(), f.free();
        }
        intersectionWithShape(e, t, i, n, r, a, o, c, l, h) {
          let d = k.intoRaw(i), u = Ge.intoRaw(n), f = r.intoRaw(), p = this.raw.intersectionWithShape(e.raw, t.raw, d, u, f, a, o, c, l, h);
          return d.free(), u.free(), f.free(), p;
        }
        projectPoint(e, t, i, n, r, a, o, c, l) {
          let h = k.intoRaw(i), d = ea.fromRaw(t, this.raw.projectPoint(e.raw, t.raw, h, n, r, a, o, c, l));
          return h.free(), d;
        }
        projectPointAndGetFeature(e, t, i, n, r, a, o, c) {
          let l = k.intoRaw(i), h = ea.fromRaw(t, this.raw.projectPointAndGetFeature(e.raw, t.raw, l, n, r, a, o, c));
          return l.free(), h;
        }
        intersectionsWithPoint(e, t, i, n, r, a, o, c, l) {
          let h = k.intoRaw(i);
          this.raw.intersectionsWithPoint(e.raw, t.raw, h, n, r, a, o, c, l), h.free();
        }
        castShape(e, t, i, n, r, a, o, c, l, h, d, u, f, p) {
          let m = k.intoRaw(i), g = Ge.intoRaw(n), A = k.intoRaw(r), x = a.intoRaw(), b = da.fromRaw(t, this.raw.castShape(e.raw, t.raw, m, g, A, x, o, c, l, h, d, u, f, p));
          return m.free(), g.free(), A.free(), x.free(), b;
        }
        intersectionsWithShape(e, t, i, n, r, a, o, c, l, h, d) {
          let u = k.intoRaw(i), f = Ge.intoRaw(n), p = r.intoRaw();
          this.raw.intersectionsWithShape(e.raw, t.raw, u, f, p, a, o, c, l, h, d), u.free(), f.free(), p.free();
        }
        collidersWithAabbIntersectingAabb(e, t, i) {
          let n = k.intoRaw(e), r = k.intoRaw(t);
          this.raw.collidersWithAabbIntersectingAabb(n, r, i), n.free(), r.free();
        }
      }
      class rh {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        constructor(e) {
          this.raw = e || new hE();
        }
        serializeAll(e, t, i, n, r, a, o, c, l) {
          let h = k.intoRaw(e);
          const d = this.raw.serializeAll(h, t.raw, i.raw, n.raw, r.raw, a.raw, o.raw, c.raw, l.raw);
          return h.free(), d;
        }
        deserializeAll(e) {
          return Ko.fromRaw(this.raw.deserializeAll(e));
        }
      }
      class hA {
        constructor(e, t) {
          this.vertices = e, this.colors = t;
        }
      }
      class dA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.vertices = void 0, this.colors = void 0;
        }
        constructor(e) {
          this.raw = e || new sE();
        }
        render(e, t, i, n, r) {
          this.raw.render(e.raw, t.raw, i.raw, n.raw, r.raw), this.vertices = this.raw.vertices(), this.colors = this.raw.colors();
        }
      }
      class uA {
      }
      class fA {
        constructor(e, t, i, n, r) {
          this.params = t, this.bodies = i, this.colliders = n, this.queries = r, this.raw = new oE(e), this.rawCharacterCollision = new Up(), this._applyImpulsesToDynamicBodies = false, this._characterMass = null;
        }
        free() {
          this.raw && (this.raw.free(), this.rawCharacterCollision.free()), this.raw = void 0, this.rawCharacterCollision = void 0;
        }
        up() {
          return this.raw.up();
        }
        setUp(e) {
          let t = k.intoRaw(e);
          return this.raw.setUp(t);
        }
        applyImpulsesToDynamicBodies() {
          return this._applyImpulsesToDynamicBodies;
        }
        setApplyImpulsesToDynamicBodies(e) {
          this._applyImpulsesToDynamicBodies = e;
        }
        characterMass() {
          return this._characterMass;
        }
        setCharacterMass(e) {
          this._characterMass = e;
        }
        offset() {
          return this.raw.offset();
        }
        setOffset(e) {
          this.raw.setOffset(e);
        }
        normalNudgeFactor() {
          return this.raw.normalNudgeFactor();
        }
        setNormalNudgeFactor(e) {
          this.raw.setNormalNudgeFactor(e);
        }
        slideEnabled() {
          return this.raw.slideEnabled();
        }
        setSlideEnabled(e) {
          this.raw.setSlideEnabled(e);
        }
        autostepMaxHeight() {
          return this.raw.autostepMaxHeight();
        }
        autostepMinWidth() {
          return this.raw.autostepMinWidth();
        }
        autostepIncludesDynamicBodies() {
          return this.raw.autostepIncludesDynamicBodies();
        }
        autostepEnabled() {
          return this.raw.autostepEnabled();
        }
        enableAutostep(e, t, i) {
          this.raw.enableAutostep(e, t, i);
        }
        disableAutostep() {
          return this.raw.disableAutostep();
        }
        maxSlopeClimbAngle() {
          return this.raw.maxSlopeClimbAngle();
        }
        setMaxSlopeClimbAngle(e) {
          this.raw.setMaxSlopeClimbAngle(e);
        }
        minSlopeSlideAngle() {
          return this.raw.minSlopeSlideAngle();
        }
        setMinSlopeSlideAngle(e) {
          this.raw.setMinSlopeSlideAngle(e);
        }
        snapToGroundDistance() {
          return this.raw.snapToGroundDistance();
        }
        enableSnapToGround(e) {
          this.raw.enableSnapToGround(e);
        }
        disableSnapToGround() {
          this.raw.disableSnapToGround();
        }
        snapToGroundEnabled() {
          return this.raw.snapToGroundEnabled();
        }
        computeColliderMovement(e, t, i, n, r) {
          let a = k.intoRaw(t);
          this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, e.handle, a, this._applyImpulsesToDynamicBodies, this._characterMass, i, n, this.colliders.castClosure(r)), a.free();
        }
        computedMovement() {
          return k.fromRaw(this.raw.computedMovement());
        }
        computedGrounded() {
          return this.raw.computedGrounded();
        }
        numComputedCollisions() {
          return this.raw.numComputedCollisions();
        }
        computedCollision(e, t) {
          if (this.raw.computedCollision(e, this.rawCharacterCollision)) {
            let i = this.rawCharacterCollision;
            return t = t ?? new uA(), t.translationDeltaApplied = k.fromRaw(i.translationDeltaApplied()), t.translationDeltaRemaining = k.fromRaw(i.translationDeltaRemaining()), t.toi = i.toi(), t.witness1 = k.fromRaw(i.worldWitness1()), t.witness2 = k.fromRaw(i.worldWitness2()), t.normal1 = k.fromRaw(i.worldNormal1()), t.normal2 = k.fromRaw(i.worldNormal2()), t.collider = this.colliders.get(i.handle()), t;
          } else return null;
        }
      }
      var sh;
      (function(s) {
        s[s.None = 0] = "None", s[s.LinX = 1] = "LinX", s[s.LinY = 2] = "LinY", s[s.LinZ = 4] = "LinZ", s[s.AngX = 8] = "AngX", s[s.AngY = 16] = "AngY", s[s.AngZ = 32] = "AngZ", s[s.AllLin = 7] = "AllLin", s[s.AllAng = 56] = "AllAng", s[s.All = 63] = "All";
      })(sh || (sh = {}));
      class pA {
        constructor(e, t, i, n, r, a) {
          this.params = e, this.bodies = t, this.raw = new lE(i, n, r, a);
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        setKp(e, t) {
          this.raw.set_kp(e, t);
        }
        setKi(e, t) {
          this.raw.set_kp(e, t);
        }
        setKd(e, t) {
          this.raw.set_kp(e, t);
        }
        setAxes(e) {
          this.raw.set_axes_mask(e);
        }
        resetIntegrals() {
          this.raw.reset_integrals();
        }
        applyLinearCorrection(e, t, i) {
          let n = k.intoRaw(t), r = k.intoRaw(i);
          this.raw.apply_linear_correction(this.params.dt, this.bodies.raw, e.handle, n, r), n.free(), r.free();
        }
        applyAngularCorrection(e, t, i) {
          let n = Ge.intoRaw(t), r = k.intoRaw(i);
          this.raw.apply_angular_correction(this.params.dt, this.bodies.raw, e.handle, n, r), n.free(), r.free();
        }
        linearCorrection(e, t, i) {
          let n = k.intoRaw(t), r = k.intoRaw(i), a = this.raw.linear_correction(this.params.dt, this.bodies.raw, e.handle, n, r);
          return n.free(), r.free(), k.fromRaw(a);
        }
        angularCorrection(e, t, i) {
          let n = Ge.intoRaw(t), r = k.intoRaw(i), a = this.raw.angular_correction(this.params.dt, this.bodies.raw, e.handle, n, r);
          return n.free(), r.free(), k.fromRaw(a);
        }
      }
      class AA {
        constructor(e, t, i, n) {
          this.raw = new aE(e.handle), this.bodies = t, this.colliders = i, this.queries = n, this._chassis = e;
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        updateVehicle(e, t, i, n) {
          this.raw.update_vehicle(e, this.bodies.raw, this.colliders.raw, this.queries.raw, t, i, this.colliders.castClosure(n));
        }
        currentVehicleSpeed() {
          return this.raw.current_vehicle_speed();
        }
        chassis() {
          return this._chassis;
        }
        get indexUpAxis() {
          return this.raw.index_up_axis();
        }
        set indexUpAxis(e) {
          this.raw.set_index_up_axis(e);
        }
        get indexForwardAxis() {
          return this.raw.index_forward_axis();
        }
        set setIndexForwardAxis(e) {
          this.raw.set_index_forward_axis(e);
        }
        addWheel(e, t, i, n, r) {
          let a = k.intoRaw(e), o = k.intoRaw(t), c = k.intoRaw(i);
          this.raw.add_wheel(a, o, c, n, r), a.free(), o.free(), c.free();
        }
        numWheels() {
          return this.raw.num_wheels();
        }
        wheelChassisConnectionPointCs(e) {
          return k.fromRaw(this.raw.wheel_chassis_connection_point_cs(e));
        }
        setWheelChassisConnectionPointCs(e, t) {
          let i = k.intoRaw(t);
          this.raw.set_wheel_chassis_connection_point_cs(e, i), i.free();
        }
        wheelSuspensionRestLength(e) {
          return this.raw.wheel_suspension_rest_length(e);
        }
        setWheelSuspensionRestLength(e, t) {
          this.raw.set_wheel_suspension_rest_length(e, t);
        }
        wheelMaxSuspensionTravel(e) {
          return this.raw.wheel_max_suspension_travel(e);
        }
        setWheelMaxSuspensionTravel(e, t) {
          this.raw.set_wheel_max_suspension_travel(e, t);
        }
        wheelRadius(e) {
          return this.raw.wheel_radius(e);
        }
        setWheelRadius(e, t) {
          this.raw.set_wheel_radius(e, t);
        }
        wheelSuspensionStiffness(e) {
          return this.raw.wheel_suspension_stiffness(e);
        }
        setWheelSuspensionStiffness(e, t) {
          this.raw.set_wheel_suspension_stiffness(e, t);
        }
        wheelSuspensionCompression(e) {
          return this.raw.wheel_suspension_compression(e);
        }
        setWheelSuspensionCompression(e, t) {
          this.raw.set_wheel_suspension_compression(e, t);
        }
        wheelSuspensionRelaxation(e) {
          return this.raw.wheel_suspension_relaxation(e);
        }
        setWheelSuspensionRelaxation(e, t) {
          this.raw.set_wheel_suspension_relaxation(e, t);
        }
        wheelMaxSuspensionForce(e) {
          return this.raw.wheel_max_suspension_force(e);
        }
        setWheelMaxSuspensionForce(e, t) {
          this.raw.set_wheel_max_suspension_force(e, t);
        }
        wheelBrake(e) {
          return this.raw.wheel_brake(e);
        }
        setWheelBrake(e, t) {
          this.raw.set_wheel_brake(e, t);
        }
        wheelSteering(e) {
          return this.raw.wheel_steering(e);
        }
        setWheelSteering(e, t) {
          this.raw.set_wheel_steering(e, t);
        }
        wheelEngineForce(e) {
          return this.raw.wheel_engine_force(e);
        }
        setWheelEngineForce(e, t) {
          this.raw.set_wheel_engine_force(e, t);
        }
        wheelDirectionCs(e) {
          return k.fromRaw(this.raw.wheel_direction_cs(e));
        }
        setWheelDirectionCs(e, t) {
          let i = k.intoRaw(t);
          this.raw.set_wheel_direction_cs(e, i), i.free();
        }
        wheelAxleCs(e) {
          return k.fromRaw(this.raw.wheel_axle_cs(e));
        }
        setWheelAxleCs(e, t) {
          let i = k.intoRaw(t);
          this.raw.set_wheel_axle_cs(e, i), i.free();
        }
        wheelFrictionSlip(e) {
          return this.raw.wheel_friction_slip(e);
        }
        setWheelFrictionSlip(e, t) {
          this.raw.set_wheel_friction_slip(e, t);
        }
        wheelSideFrictionStiffness(e) {
          return this.raw.wheel_side_friction_stiffness(e);
        }
        setWheelSideFrictionStiffness(e, t) {
          this.raw.set_wheel_side_friction_stiffness(e, t);
        }
        wheelRotation(e) {
          return this.raw.wheel_rotation(e);
        }
        wheelForwardImpulse(e) {
          return this.raw.wheel_forward_impulse(e);
        }
        wheelSideImpulse(e) {
          return this.raw.wheel_side_impulse(e);
        }
        wheelSuspensionForce(e) {
          return this.raw.wheel_suspension_force(e);
        }
        wheelContactNormal(e) {
          return k.fromRaw(this.raw.wheel_contact_normal_ws(e));
        }
        wheelContactPoint(e) {
          return k.fromRaw(this.raw.wheel_contact_point_ws(e));
        }
        wheelSuspensionLength(e) {
          return this.raw.wheel_suspension_length(e);
        }
        wheelHardPoint(e) {
          return k.fromRaw(this.raw.wheel_hard_point_ws(e));
        }
        wheelIsInContact(e) {
          return this.raw.wheel_is_in_contact(e);
        }
        wheelGroundObject(e) {
          return this.colliders.get(this.raw.wheel_ground_object(e));
        }
      }
      class Ko {
        free() {
          this.integrationParameters.free(), this.islands.free(), this.broadPhase.free(), this.narrowPhase.free(), this.bodies.free(), this.colliders.free(), this.impulseJoints.free(), this.multibodyJoints.free(), this.ccdSolver.free(), this.queryPipeline.free(), this.physicsPipeline.free(), this.serializationPipeline.free(), this.debugRenderPipeline.free(), this.characterControllers.forEach((e) => e.free()), this.pidControllers.forEach((e) => e.free()), this.vehicleControllers.forEach((e) => e.free()), this.integrationParameters = void 0, this.islands = void 0, this.broadPhase = void 0, this.narrowPhase = void 0, this.bodies = void 0, this.colliders = void 0, this.ccdSolver = void 0, this.impulseJoints = void 0, this.multibodyJoints = void 0, this.queryPipeline = void 0, this.physicsPipeline = void 0, this.serializationPipeline = void 0, this.debugRenderPipeline = void 0, this.characterControllers = void 0, this.pidControllers = void 0, this.vehicleControllers = void 0;
        }
        constructor(e, t, i, n, r, a, o, c, l, h, d, u, f, p) {
          this.gravity = e, this.integrationParameters = new Gp(t), this.islands = new nA(i), this.broadPhase = new rA(n), this.narrowPhase = new sA(r), this.bodies = new zp(a), this.colliders = new _A(o), this.impulseJoints = new Kp(c), this.multibodyJoints = new tA(l), this.ccdSolver = new iA(h), this.queryPipeline = new lA(d), this.physicsPipeline = new cA(u), this.serializationPipeline = new rh(f), this.debugRenderPipeline = new dA(p), this.characterControllers = /* @__PURE__ */ new Set(), this.pidControllers = /* @__PURE__ */ new Set(), this.vehicleControllers = /* @__PURE__ */ new Set(), this.impulseJoints.finalizeDeserialization(this.bodies), this.bodies.finalizeDeserialization(this.colliders), this.colliders.finalizeDeserialization(this.bodies);
        }
        static fromRaw(e) {
          return e ? new Ko(k.fromRaw(e.takeGravity()), e.takeIntegrationParameters(), e.takeIslandManager(), e.takeBroadPhase(), e.takeNarrowPhase(), e.takeBodies(), e.takeColliders(), e.takeImpulseJoints(), e.takeMultibodyJoints()) : null;
        }
        takeSnapshot() {
          return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);
        }
        static restoreSnapshot(e) {
          return new rh().deserializeAll(e);
        }
        debugRender() {
          return this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase), new hA(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);
        }
        step(e, t) {
          this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, e, t), this.queryPipeline.update(this.colliders);
        }
        propagateModifiedBodyPositionsToColliders() {
          this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);
        }
        updateSceneQueries() {
          this.propagateModifiedBodyPositionsToColliders(), this.queryPipeline.update(this.colliders);
        }
        get timestep() {
          return this.integrationParameters.dt;
        }
        set timestep(e) {
          this.integrationParameters.dt = e;
        }
        get lengthUnit() {
          return this.integrationParameters.lengthUnit;
        }
        set lengthUnit(e) {
          this.integrationParameters.lengthUnit = e;
        }
        get numSolverIterations() {
          return this.integrationParameters.numSolverIterations;
        }
        set numSolverIterations(e) {
          this.integrationParameters.numSolverIterations = e;
        }
        get numAdditionalFrictionIterations() {
          return this.integrationParameters.numAdditionalFrictionIterations;
        }
        set numAdditionalFrictionIterations(e) {
          this.integrationParameters.numAdditionalFrictionIterations = e;
        }
        get numInternalPgsIterations() {
          return this.integrationParameters.numInternalPgsIterations;
        }
        set numInternalPgsIterations(e) {
          this.integrationParameters.numInternalPgsIterations = e;
        }
        switchToStandardPgsSolver() {
          this.integrationParameters.switchToStandardPgsSolver();
        }
        switchToSmallStepsPgsSolver() {
          this.integrationParameters.switchToSmallStepsPgsSolver();
        }
        switchToSmallStepsPgsSolverWithoutWarmstart() {
          this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();
        }
        createRigidBody(e) {
          return this.bodies.createRigidBody(this.colliders, e);
        }
        createCharacterController(e) {
          let t = new fA(e, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);
          return this.characterControllers.add(t), t;
        }
        removeCharacterController(e) {
          this.characterControllers.delete(e), e.free();
        }
        createPidController(e, t, i, n) {
          let r = new pA(this.integrationParameters, this.bodies, e, t, i, n);
          return this.pidControllers.add(r), r;
        }
        removePidController(e) {
          this.pidControllers.delete(e), e.free();
        }
        createVehicleController(e) {
          let t = new AA(e, this.bodies, this.colliders, this.queryPipeline);
          return this.vehicleControllers.add(t), t;
        }
        removeVehicleController(e) {
          this.vehicleControllers.delete(e), e.free();
        }
        createCollider(e, t) {
          let i = t ? t.handle : void 0;
          return this.colliders.createCollider(this.bodies, e, i);
        }
        createImpulseJoint(e, t, i, n) {
          return this.impulseJoints.createJoint(this.bodies, e, t.handle, i.handle, n);
        }
        createMultibodyJoint(e, t, i, n) {
          return this.multibodyJoints.createJoint(e, t.handle, i.handle, n);
        }
        getRigidBody(e) {
          return this.bodies.get(e);
        }
        getCollider(e) {
          return this.colliders.get(e);
        }
        getImpulseJoint(e) {
          return this.impulseJoints.get(e);
        }
        getMultibodyJoint(e) {
          return this.multibodyJoints.get(e);
        }
        removeRigidBody(e) {
          this.bodies && this.bodies.remove(e.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);
        }
        removeCollider(e, t) {
          this.colliders && this.colliders.remove(e.handle, this.islands, this.bodies, t);
        }
        removeImpulseJoint(e, t) {
          this.impulseJoints && this.impulseJoints.remove(e.handle, t);
        }
        removeMultibodyJoint(e, t) {
          this.impulseJoints && this.multibodyJoints.remove(e.handle, t);
        }
        forEachCollider(e) {
          this.colliders.forEach(e);
        }
        forEachRigidBody(e) {
          this.bodies.forEach(e);
        }
        forEachActiveRigidBody(e) {
          this.bodies.forEachActiveRigidBody(this.islands, e);
        }
        castRay(e, t, i, n, r, a, o, c) {
          return this.queryPipeline.castRay(this.bodies, this.colliders, e, t, i, n, r, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
        }
        castRayAndGetNormal(e, t, i, n, r, a, o, c) {
          return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, e, t, i, n, r, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
        }
        intersectionsWithRay(e, t, i, n, r, a, o, c, l) {
          this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, e, t, i, n, r, a, o ? o.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
        }
        intersectionWithShape(e, t, i, n, r, a, o, c) {
          let l = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, e, t, i, n, r, a ? a.handle : null, o ? o.handle : null, this.colliders.castClosure(c));
          return l != null ? this.colliders.get(l) : null;
        }
        projectPoint(e, t, i, n, r, a, o) {
          return this.queryPipeline.projectPoint(this.bodies, this.colliders, e, t, i, n, r ? r.handle : null, a ? a.handle : null, this.colliders.castClosure(o));
        }
        projectPointAndGetFeature(e, t, i, n, r, a) {
          return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, e, t, i, n ? n.handle : null, r ? r.handle : null, this.colliders.castClosure(a));
        }
        intersectionsWithPoint(e, t, i, n, r, a, o) {
          this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, e, this.colliders.castClosure(t), i, n, r ? r.handle : null, a ? a.handle : null, this.colliders.castClosure(o));
        }
        castShape(e, t, i, n, r, a, o, c, l, h, d, u) {
          return this.queryPipeline.castShape(this.bodies, this.colliders, e, t, i, n, r, a, o, c, l, h ? h.handle : null, d ? d.handle : null, this.colliders.castClosure(u));
        }
        intersectionsWithShape(e, t, i, n, r, a, o, c, l) {
          this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, e, t, i, this.colliders.castClosure(n), r, a, o ? o.handle : null, c ? c.handle : null, this.colliders.castClosure(l));
        }
        collidersWithAabbIntersectingAabb(e, t, i) {
          this.queryPipeline.collidersWithAabbIntersectingAabb(e, t, this.colliders.castClosure(i));
        }
        contactPairsWith(e, t) {
          this.narrowPhase.contactPairsWith(e.handle, this.colliders.castClosure(t));
        }
        intersectionPairsWith(e, t) {
          this.narrowPhase.intersectionPairsWith(e.handle, this.colliders.castClosure(t));
        }
        contactPair(e, t, i) {
          this.narrowPhase.contactPair(e.handle, t.handle, i);
        }
        intersectionPair(e, t) {
          return this.narrowPhase.intersectionPair(e.handle, t.handle);
        }
      }
      var To;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.COLLISION_EVENTS = 1] = "COLLISION_EVENTS", s[s.CONTACT_FORCE_EVENTS = 2] = "CONTACT_FORCE_EVENTS";
      })(To || (To = {}));
      class gA {
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        collider1() {
          return this.raw.collider1();
        }
        collider2() {
          return this.raw.collider2();
        }
        totalForce() {
          return k.fromRaw(this.raw.total_force());
        }
        totalForceMagnitude() {
          return this.raw.total_force_magnitude();
        }
        maxForceDirection() {
          return k.fromRaw(this.raw.max_force_direction());
        }
        maxForceMagnitude() {
          return this.raw.max_force_magnitude();
        }
      }
      class uD {
        constructor(e, t) {
          this.raw = t || new Np(e);
        }
        free() {
          this.raw && this.raw.free(), this.raw = void 0;
        }
        drainCollisionEvents(e) {
          this.raw.drainCollisionEvents(e);
        }
        drainContactForceEvents(e) {
          let t = new gA();
          this.raw.drainContactForceEvents((i) => {
            t.raw = i, e(t), t.free();
          });
        }
        clear() {
          this.raw.clear();
        }
      }
      var Ro;
      (function(s) {
        s[s.NONE = 0] = "NONE", s[s.FILTER_CONTACT_PAIRS = 1] = "FILTER_CONTACT_PAIRS", s[s.FILTER_INTERSECTION_PAIRS = 2] = "FILTER_INTERSECTION_PAIRS";
      })(Ro || (Ro = {}));
      var ah;
      (function(s) {
        s[s.EMPTY = 0] = "EMPTY", s[s.COMPUTE_IMPULSE = 1] = "COMPUTE_IMPULSE";
      })(ah || (ah = {}));
      var Bo;
      (function(s) {
        s[s.DYNAMIC_DYNAMIC = 1] = "DYNAMIC_DYNAMIC", s[s.DYNAMIC_KINEMATIC = 12] = "DYNAMIC_KINEMATIC", s[s.DYNAMIC_FIXED = 2] = "DYNAMIC_FIXED", s[s.KINEMATIC_KINEMATIC = 52224] = "KINEMATIC_KINEMATIC", s[s.KINEMATIC_FIXED = 8704] = "KINEMATIC_FIXED", s[s.FIXED_FIXED = 32] = "FIXED_FIXED", s[s.DEFAULT = 15] = "DEFAULT", s[s.ALL = 60943] = "ALL";
      })(Bo || (Bo = {}));
      class oh {
        constructor(e, t, i, n) {
          this.colliderSet = e, this.handle = t, this._parent = i, this._shape = n;
        }
        finalizeDeserialization(e) {
          this.handle != null && (this._parent = e.get(this.colliderSet.raw.coParent(this.handle)));
        }
        ensureShapeIsCached() {
          this._shape || (this._shape = Xt.fromRaw(this.colliderSet.raw, this.handle));
        }
        get shape() {
          return this.ensureShapeIsCached(), this._shape;
        }
        isValid() {
          return this.colliderSet.raw.contains(this.handle);
        }
        translation() {
          return k.fromRaw(this.colliderSet.raw.coTranslation(this.handle));
        }
        rotation() {
          return Ge.fromRaw(this.colliderSet.raw.coRotation(this.handle));
        }
        isSensor() {
          return this.colliderSet.raw.coIsSensor(this.handle);
        }
        setSensor(e) {
          this.colliderSet.raw.coSetSensor(this.handle, e);
        }
        setShape(e) {
          let t = e.intoRaw();
          this.colliderSet.raw.coSetShape(this.handle, t), t.free(), this._shape = e;
        }
        setEnabled(e) {
          this.colliderSet.raw.coSetEnabled(this.handle, e);
        }
        isEnabled() {
          return this.colliderSet.raw.coIsEnabled(this.handle);
        }
        setRestitution(e) {
          this.colliderSet.raw.coSetRestitution(this.handle, e);
        }
        setFriction(e) {
          this.colliderSet.raw.coSetFriction(this.handle, e);
        }
        frictionCombineRule() {
          return this.colliderSet.raw.coFrictionCombineRule(this.handle);
        }
        setFrictionCombineRule(e) {
          this.colliderSet.raw.coSetFrictionCombineRule(this.handle, e);
        }
        restitutionCombineRule() {
          return this.colliderSet.raw.coRestitutionCombineRule(this.handle);
        }
        setRestitutionCombineRule(e) {
          this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, e);
        }
        setCollisionGroups(e) {
          this.colliderSet.raw.coSetCollisionGroups(this.handle, e);
        }
        setSolverGroups(e) {
          this.colliderSet.raw.coSetSolverGroups(this.handle, e);
        }
        contactSkin() {
          return this.colliderSet.raw.coContactSkin(this.handle);
        }
        setContactSkin(e) {
          return this.colliderSet.raw.coSetContactSkin(this.handle, e);
        }
        activeHooks() {
          return this.colliderSet.raw.coActiveHooks(this.handle);
        }
        setActiveHooks(e) {
          this.colliderSet.raw.coSetActiveHooks(this.handle, e);
        }
        activeEvents() {
          return this.colliderSet.raw.coActiveEvents(this.handle);
        }
        setActiveEvents(e) {
          this.colliderSet.raw.coSetActiveEvents(this.handle, e);
        }
        activeCollisionTypes() {
          return this.colliderSet.raw.coActiveCollisionTypes(this.handle);
        }
        setContactForceEventThreshold(e) {
          return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, e);
        }
        contactForceEventThreshold() {
          return this.colliderSet.raw.coContactForceEventThreshold(this.handle);
        }
        setActiveCollisionTypes(e) {
          this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, e);
        }
        setDensity(e) {
          this.colliderSet.raw.coSetDensity(this.handle, e);
        }
        setMass(e) {
          this.colliderSet.raw.coSetMass(this.handle, e);
        }
        setMassProperties(e, t, i, n) {
          let r = k.intoRaw(t), a = k.intoRaw(i), o = Ge.intoRaw(n);
          this.colliderSet.raw.coSetMassProperties(this.handle, e, r, a, o), r.free(), a.free(), o.free();
        }
        setTranslation(e) {
          this.colliderSet.raw.coSetTranslation(this.handle, e.x, e.y, e.z);
        }
        setTranslationWrtParent(e) {
          this.colliderSet.raw.coSetTranslationWrtParent(this.handle, e.x, e.y, e.z);
        }
        setRotation(e) {
          this.colliderSet.raw.coSetRotation(this.handle, e.x, e.y, e.z, e.w);
        }
        setRotationWrtParent(e) {
          this.colliderSet.raw.coSetRotationWrtParent(this.handle, e.x, e.y, e.z, e.w);
        }
        shapeType() {
          return this.colliderSet.raw.coShapeType(this.handle);
        }
        halfExtents() {
          return k.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));
        }
        setHalfExtents(e) {
          const t = k.intoRaw(e);
          this.colliderSet.raw.coSetHalfExtents(this.handle, t);
        }
        radius() {
          return this.colliderSet.raw.coRadius(this.handle);
        }
        setRadius(e) {
          this.colliderSet.raw.coSetRadius(this.handle, e);
        }
        roundRadius() {
          return this.colliderSet.raw.coRoundRadius(this.handle);
        }
        setRoundRadius(e) {
          this.colliderSet.raw.coSetRoundRadius(this.handle, e);
        }
        halfHeight() {
          return this.colliderSet.raw.coHalfHeight(this.handle);
        }
        setHalfHeight(e) {
          this.colliderSet.raw.coSetHalfHeight(this.handle, e);
        }
        vertices() {
          return this.colliderSet.raw.coVertices(this.handle);
        }
        indices() {
          return this.colliderSet.raw.coIndices(this.handle);
        }
        heightfieldHeights() {
          return this.colliderSet.raw.coHeightfieldHeights(this.handle);
        }
        heightfieldScale() {
          let e = this.colliderSet.raw.coHeightfieldScale(this.handle);
          return k.fromRaw(e);
        }
        heightfieldNRows() {
          return this.colliderSet.raw.coHeightfieldNRows(this.handle);
        }
        heightfieldNCols() {
          return this.colliderSet.raw.coHeightfieldNCols(this.handle);
        }
        parent() {
          return this._parent;
        }
        friction() {
          return this.colliderSet.raw.coFriction(this.handle);
        }
        restitution() {
          return this.colliderSet.raw.coRestitution(this.handle);
        }
        density() {
          return this.colliderSet.raw.coDensity(this.handle);
        }
        mass() {
          return this.colliderSet.raw.coMass(this.handle);
        }
        volume() {
          return this.colliderSet.raw.coVolume(this.handle);
        }
        collisionGroups() {
          return this.colliderSet.raw.coCollisionGroups(this.handle);
        }
        solverGroups() {
          return this.colliderSet.raw.coSolverGroups(this.handle);
        }
        containsPoint(e) {
          let t = k.intoRaw(e), i = this.colliderSet.raw.coContainsPoint(this.handle, t);
          return t.free(), i;
        }
        projectPoint(e, t) {
          let i = k.intoRaw(e), n = la.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, i, t));
          return i.free(), n;
        }
        intersectsRay(e, t) {
          let i = k.intoRaw(e.origin), n = k.intoRaw(e.dir), r = this.colliderSet.raw.coIntersectsRay(this.handle, i, n, t);
          return i.free(), n.free(), r;
        }
        castShape(e, t, i, n, r, a, o, c) {
          let l = k.intoRaw(e), h = k.intoRaw(i), d = Ge.intoRaw(n), u = k.intoRaw(r), f = t.intoRaw(), p = us.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, l, f, h, d, u, a, o, c));
          return l.free(), h.free(), d.free(), u.free(), f.free(), p;
        }
        castCollider(e, t, i, n, r, a) {
          let o = k.intoRaw(e), c = k.intoRaw(i), l = da.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, o, t.handle, c, n, r, a));
          return o.free(), c.free(), l;
        }
        intersectsShape(e, t, i) {
          let n = k.intoRaw(t), r = Ge.intoRaw(i), a = e.intoRaw(), o = this.colliderSet.raw.coIntersectsShape(this.handle, a, n, r);
          return n.free(), r.free(), a.free(), o;
        }
        contactShape(e, t, i, n) {
          let r = k.intoRaw(t), a = Ge.intoRaw(i), o = e.intoRaw(), c = rs.fromRaw(this.colliderSet.raw.coContactShape(this.handle, o, r, a, n));
          return r.free(), a.free(), o.free(), c;
        }
        contactCollider(e, t) {
          return rs.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, e.handle, t));
        }
        castRay(e, t, i) {
          let n = k.intoRaw(e.origin), r = k.intoRaw(e.dir), a = this.colliderSet.raw.coCastRay(this.handle, n, r, t, i);
          return n.free(), r.free(), a;
        }
        castRayAndGetNormal(e, t, i) {
          let n = k.intoRaw(e.origin), r = k.intoRaw(e.dir), a = ha.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, n, r, t, i));
          return n.free(), r.free(), a;
        }
      }
      var ur;
      (function(s) {
        s[s.Density = 0] = "Density", s[s.Mass = 1] = "Mass", s[s.MassProps = 2] = "MassProps";
      })(ur || (ur = {}));
      class kt {
        constructor(e) {
          this.enabled = true, this.shape = e, this.massPropsMode = ur.Density, this.density = 1, this.friction = 0.5, this.restitution = 0, this.rotation = Ge.identity(), this.translation = k.zeros(), this.isSensor = false, this.collisionGroups = 4294967295, this.solverGroups = 4294967295, this.frictionCombineRule = $s.Average, this.restitutionCombineRule = $s.Average, this.activeCollisionTypes = Bo.DEFAULT, this.activeEvents = To.NONE, this.activeHooks = Ro.NONE, this.mass = 0, this.centerOfMass = k.zeros(), this.contactForceEventThreshold = 0, this.contactSkin = 0, this.principalAngularInertia = k.zeros(), this.angularInertiaLocalFrame = Ge.identity();
        }
        static ball(e) {
          const t = new Zh(e);
          return new kt(t);
        }
        static capsule(e, t) {
          const i = new td(e, t);
          return new kt(i);
        }
        static segment(e, t) {
          const i = new id(e, t);
          return new kt(i);
        }
        static triangle(e, t, i) {
          const n = new nd(e, t, i);
          return new kt(n);
        }
        static roundTriangle(e, t, i, n) {
          const r = new rd(e, t, i, n);
          return new kt(r);
        }
        static polyline(e, t) {
          const i = new sd(e, t);
          return new kt(i);
        }
        static trimesh(e, t, i) {
          const n = new ad(e, t, i);
          return new kt(n);
        }
        static cuboid(e, t, i) {
          const n = new $h(e, t, i);
          return new kt(n);
        }
        static roundCuboid(e, t, i, n) {
          const r = new ed(e, t, i, n);
          return new kt(r);
        }
        static heightfield(e, t, i, n, r) {
          const a = new od(e, t, i, n, r);
          return new kt(a);
        }
        static cylinder(e, t) {
          const i = new cd(e, t);
          return new kt(i);
        }
        static roundCylinder(e, t, i) {
          const n = new ld(e, t, i);
          return new kt(n);
        }
        static cone(e, t) {
          const i = new hd(e, t);
          return new kt(i);
        }
        static roundCone(e, t, i) {
          const n = new dd(e, t, i);
          return new kt(n);
        }
        static convexHull(e) {
          const t = new Io(e, null);
          return new kt(t);
        }
        static convexMesh(e, t) {
          const i = new Io(e, t);
          return new kt(i);
        }
        static roundConvexHull(e, t) {
          const i = new Mo(e, null, t);
          return new kt(i);
        }
        static roundConvexMesh(e, t, i) {
          const n = new Mo(e, t, i);
          return new kt(n);
        }
        setTranslation(e, t, i) {
          if (typeof e != "number" || typeof t != "number" || typeof i != "number") throw TypeError("The translation components must be numbers.");
          return this.translation = {
            x: e,
            y: t,
            z: i
          }, this;
        }
        setRotation(e) {
          return Ge.copy(this.rotation, e), this;
        }
        setSensor(e) {
          return this.isSensor = e, this;
        }
        setEnabled(e) {
          return this.enabled = e, this;
        }
        setContactSkin(e) {
          return this.contactSkin = e, this;
        }
        setDensity(e) {
          return this.massPropsMode = ur.Density, this.density = e, this;
        }
        setMass(e) {
          return this.massPropsMode = ur.Mass, this.mass = e, this;
        }
        setMassProperties(e, t, i, n) {
          return this.massPropsMode = ur.MassProps, this.mass = e, k.copy(this.centerOfMass, t), k.copy(this.principalAngularInertia, i), Ge.copy(this.angularInertiaLocalFrame, n), this;
        }
        setRestitution(e) {
          return this.restitution = e, this;
        }
        setFriction(e) {
          return this.friction = e, this;
        }
        setFrictionCombineRule(e) {
          return this.frictionCombineRule = e, this;
        }
        setRestitutionCombineRule(e) {
          return this.restitutionCombineRule = e, this;
        }
        setCollisionGroups(e) {
          return this.collisionGroups = e, this;
        }
        setSolverGroups(e) {
          return this.solverGroups = e, this;
        }
        setActiveHooks(e) {
          return this.activeHooks = e, this;
        }
        setActiveEvents(e) {
          return this.activeEvents = e, this;
        }
        setActiveCollisionTypes(e) {
          return this.activeCollisionTypes = e, this;
        }
        setContactForceEventThreshold(e) {
          return this.contactForceEventThreshold = e, this;
        }
      }
      class _A {
        free() {
          this.raw && this.raw.free(), this.raw = void 0, this.map && this.map.clear(), this.map = void 0;
        }
        constructor(e) {
          this.raw = e || new Mt(), this.map = new Xo(), e && e.forEachColliderHandle((t) => {
            this.map.set(t, new oh(this, t, null));
          });
        }
        castClosure(e) {
          return (t) => {
            if (e) return e(this.get(t));
          };
        }
        finalizeDeserialization(e) {
          this.map.forEach((t) => t.finalizeDeserialization(e));
        }
        createCollider(e, t, i) {
          let n = i != null && i != null;
          if (n && isNaN(i)) throw Error("Cannot create a collider with a parent rigid-body handle that is not a number.");
          let r = t.shape.intoRaw(), a = k.intoRaw(t.translation), o = Ge.intoRaw(t.rotation), c = k.intoRaw(t.centerOfMass), l = k.intoRaw(t.principalAngularInertia), h = Ge.intoRaw(t.angularInertiaLocalFrame), d = this.raw.createCollider(t.enabled, r, a, o, t.massPropsMode, t.mass, c, l, h, t.density, t.friction, t.restitution, t.frictionCombineRule, t.restitutionCombineRule, t.isSensor, t.collisionGroups, t.solverGroups, t.activeCollisionTypes, t.activeHooks, t.activeEvents, t.contactForceEventThreshold, t.contactSkin, n, n ? i : 0, e.raw);
          r.free(), a.free(), o.free(), c.free(), l.free(), h.free();
          let u = n ? e.get(i) : null, f = new oh(this, d, u, t.shape);
          return this.map.set(d, f), f;
        }
        remove(e, t, i, n) {
          this.raw.remove(e, t.raw, i.raw, n), this.unmap(e);
        }
        unmap(e) {
          this.map.delete(e);
        }
        get(e) {
          return this.map.get(e);
        }
        len() {
          return this.map.len();
        }
        contains(e) {
          return this.get(e) != null;
        }
        forEach(e) {
          this.map.forEach(e);
        }
        getAll() {
          return this.map.getAll();
        }
      }
      function fD() {
        return nE();
      }
      const en = Object.freeze(Object.defineProperty({
        __proto__: null,
        get ActiveCollisionTypes() {
          return Bo;
        },
        get ActiveEvents() {
          return To;
        },
        get ActiveHooks() {
          return Ro;
        },
        Ball: Zh,
        BroadPhase: rA,
        CCDSolver: iA,
        Capsule: td,
        CharacterCollision: uA,
        get CoefficientCombineRule() {
          return $s;
        },
        Collider: oh,
        ColliderDesc: kt,
        ColliderSet: _A,
        ColliderShapeCastHit: da,
        Cone: hd,
        ConvexPolyhedron: Io,
        Cuboid: $h,
        Cylinder: cd,
        DebugRenderBuffers: hA,
        DebugRenderPipeline: dA,
        DynamicRayCastVehicleController: AA,
        EventQueue: uD,
        get FeatureType() {
          return ss;
        },
        FixedImpulseJoint: Hp,
        FixedMultibodyJoint: Jp,
        GenericImpulseJoint: Xp,
        HalfSpace: oA,
        get HeightFieldFlags() {
          return th;
        },
        Heightfield: od,
        ImpulseJoint: tn,
        ImpulseJointSet: Kp,
        IntegrationParameters: Gp,
        IslandManager: nA,
        get JointAxesMask() {
          return eh;
        },
        JointData: wn,
        get JointType() {
          return ti;
        },
        KinematicCharacterController: fA,
        get MassPropsMode() {
          return ur;
        },
        get MotorModel() {
          return $l;
        },
        MultibodyJoint: Wn,
        MultibodyJointSet: tA,
        NarrowPhase: sA,
        PhysicsPipeline: cA,
        get PidAxesMask() {
          return sh;
        },
        PidController: pA,
        PointColliderProjection: ea,
        PointProjection: la,
        Polyline: sd,
        PrismaticImpulseJoint: jp,
        PrismaticMultibodyJoint: Zp,
        Quaternion: Kl,
        get QueryFilterFlags() {
          return nh;
        },
        QueryPipeline: lA,
        Ray: dD,
        RayColliderHit: Yo,
        RayColliderIntersection: ta,
        RayIntersection: ha,
        RevoluteImpulseJoint: qp,
        RevoluteMultibodyJoint: $p,
        RigidBody: Zl,
        RigidBodyDesc: rn,
        RigidBodySet: zp,
        get RigidBodyType() {
          return Wi;
        },
        RopeImpulseJoint: Vp,
        RotationOps: Ge,
        RoundCone: dd,
        RoundConvexPolyhedron: Mo,
        RoundCuboid: ed,
        RoundCylinder: ld,
        RoundTriangle: rd,
        SdpMatrix3: Op,
        SdpMatrix3Ops: Jl,
        Segment: id,
        SerializationPipeline: rh,
        Shape: Xt,
        ShapeCastHit: us,
        ShapeContact: rs,
        get ShapeType() {
          return zt;
        },
        get SolverFlags() {
          return ah;
        },
        SphericalImpulseJoint: Yp,
        SphericalMultibodyJoint: eA,
        SpringImpulseJoint: Wp,
        TempContactForceEvent: gA,
        TempContactManifold: aA,
        TriMesh: ad,
        get TriMeshFlags() {
          return ih;
        },
        Triangle: nd,
        UnitImpulseJoint: Kh,
        UnitMultibodyJoint: Jh,
        Vector3: Qp,
        VectorOps: k,
        World: Ko,
        version: fD
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      class mA extends Ui {
        constructor(e) {
          super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
            return new mD(t);
          }), this.register(function(t) {
            return new wD(t);
          }), this.register(function(t) {
            return new MD(t);
          }), this.register(function(t) {
            return new TD(t);
          }), this.register(function(t) {
            return new RD(t);
          }), this.register(function(t) {
            return new yD(t);
          }), this.register(function(t) {
            return new xD(t);
          }), this.register(function(t) {
            return new ED(t);
          }), this.register(function(t) {
            return new vD(t);
          }), this.register(function(t) {
            return new _D(t);
          }), this.register(function(t) {
            return new SD(t);
          }), this.register(function(t) {
            return new bD(t);
          }), this.register(function(t) {
            return new ID(t);
          }), this.register(function(t) {
            return new CD(t);
          }), this.register(function(t) {
            return new AD(t);
          }), this.register(function(t) {
            return new BD(t);
          }), this.register(function(t) {
            return new DD(t);
          });
        }
        load(e, t, i, n) {
          const r = this;
          let a;
          if (this.resourcePath !== "") a = this.resourcePath;
          else if (this.path !== "") {
            const l = Kr.extractUrlBase(e);
            a = Kr.resolveURL(l, this.path);
          } else a = Kr.extractUrlBase(e);
          this.manager.itemStart(e);
          const o = function(l) {
            n ? n(l) : console.error(l), r.manager.itemError(e), r.manager.itemEnd(e);
          }, c = new fr(this.manager);
          c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(e, function(l) {
            try {
              r.parse(l, a, function(h) {
                t(h), r.manager.itemEnd(e);
              }, o);
            } catch (h) {
              o(h);
            }
          }, i, o);
        }
        setDRACOLoader(e) {
          return this.dracoLoader = e, this;
        }
        setKTX2Loader(e) {
          return this.ktx2Loader = e, this;
        }
        setMeshoptDecoder(e) {
          return this.meshoptDecoder = e, this;
        }
        register(e) {
          return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
        }
        unregister(e) {
          return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
        }
        parse(e, t, i, n) {
          let r;
          const a = {}, o = {}, c = new TextDecoder();
          if (typeof e == "string") r = JSON.parse(e);
          else if (e instanceof ArrayBuffer) if (c.decode(new Uint8Array(e, 0, 4)) === wA) {
            try {
              a[Je.KHR_BINARY_GLTF] = new PD(e);
            } catch (d) {
              n && n(d);
              return;
            }
            r = JSON.parse(a[Je.KHR_BINARY_GLTF].content);
          } else r = JSON.parse(c.decode(e));
          else r = e;
          if (r.asset === void 0 || r.asset.version[0] < 2) {
            n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const l = new jD(r, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
          });
          l.fileLoader.setRequestHeader(this.requestHeader);
          for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const d = this.pluginCallbacks[h](l);
            d.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[d.name] = d, a[d.name] = true;
          }
          if (r.extensionsUsed) for (let h = 0; h < r.extensionsUsed.length; ++h) {
            const d = r.extensionsUsed[h], u = r.extensionsRequired || [];
            switch (d) {
              case Je.KHR_MATERIALS_UNLIT:
                a[d] = new gD();
                break;
              case Je.KHR_DRACO_MESH_COMPRESSION:
                a[d] = new LD(r, this.dracoLoader);
                break;
              case Je.KHR_TEXTURE_TRANSFORM:
                a[d] = new FD();
                break;
              case Je.KHR_MESH_QUANTIZATION:
                a[d] = new kD();
                break;
              default:
                u.indexOf(d) >= 0 && o[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
            }
          }
          l.setExtensions(a), l.setPlugins(o), l.parse(i, n);
        }
        parseAsync(e, t) {
          const i = this;
          return new Promise(function(n, r) {
            i.parse(e, t, n, r);
          });
        }
      }
      function pD() {
        let s = {};
        return {
          get: function(e) {
            return s[e];
          },
          add: function(e, t) {
            s[e] = t;
          },
          remove: function(e) {
            delete s[e];
          },
          removeAll: function() {
            s = {};
          }
        };
      }
      const Je = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
      };
      class AD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
          };
        }
        _markDefs() {
          const e = this.parser, t = this.parser.json.nodes || [];
          for (let i = 0, n = t.length; i < n; i++) {
            const r = t[i];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser, i = "light:" + e;
          let n = t.cache.get(i);
          if (n) return n;
          const r = t.json, c = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
          let l;
          const h = new ue(16777215);
          c.color !== void 0 && h.setRGB(c.color[0], c.color[1], c.color[2], oi);
          const d = c.range !== void 0 ? c.range : 0;
          switch (c.type) {
            case "directional":
              l = new Oo(h), l.target.position.set(0, 0, -1), l.add(l.target);
              break;
            case "point":
              l = new Wl(h), l.distance = d;
              break;
            case "spot":
              l = new Ep(h), l.distance = d, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, l.angle = c.spot.outerConeAngle, l.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, l.target.position.set(0, 0, -1), l.add(l.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
          }
          return l.position.set(0, 0, 0), bn(l, c), c.intensity !== void 0 && (l.intensity = c.intensity), l.name = t.createUniqueName(c.name || "light_" + e), n = Promise.resolve(l), t.cache.add(i, n), n;
        }
        getDependency(e, t) {
          if (e === "light") return this._loadLight(t);
        }
        createNodeAttachment(e) {
          const t = this, i = this.parser, r = i.json.nodes[e], o = (r.extensions && r.extensions[this.name] || {}).light;
          return o === void 0 ? null : this._loadLight(o).then(function(c) {
            return i._getNodeRef(t.cache, o, c);
          });
        }
      }
      class gD {
        constructor() {
          this.name = Je.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return Zi;
        }
        extendParams(e, t, i) {
          const n = [];
          e.color = new ue(1, 1, 1), e.opacity = 1;
          const r = t.pbrMetallicRoughness;
          if (r) {
            if (Array.isArray(r.baseColorFactor)) {
              const a = r.baseColorFactor;
              e.color.setRGB(a[0], a[1], a[2], oi), e.opacity = a[3];
            }
            r.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", r.baseColorTexture, nt));
          }
          return Promise.all(n);
        }
      }
      class _D {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = n.extensions[this.name].emissiveStrength;
          return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
        }
      }
      class mD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (r.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
            const o = a.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new oe(o, o);
          }
          return Promise.all(r);
        }
      }
      class wD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = n.extensions[this.name];
          return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
        }
      }
      class bD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
            100,
            400
          ]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && r.push(i.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(r);
        }
      }
      class yD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [];
          t.sheenColor = new ue(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
          const a = n.extensions[this.name];
          if (a.sheenColorFactor !== void 0) {
            const o = a.sheenColorFactor;
            t.sheenColor.setRGB(o[0], o[1], o[2], oi);
          }
          return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && r.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, nt)), a.sheenRoughnessTexture !== void 0 && r.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(r);
        }
      }
      class xD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && r.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(r);
        }
      }
      class ED {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && r.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
          const o = a.attenuationColor || [
            1,
            1,
            1
          ];
          return t.attenuationColor = new ue().setRGB(o[0], o[1], o[2], oi), Promise.all(r);
        }
      }
      class vD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_IOR;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = n.extensions[this.name];
          return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
        }
      }
      class SD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && r.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
          const o = a.specularColorFactor || [
            1,
            1,
            1
          ];
          return t.specularColor = new ue().setRGB(o[0], o[1], o[2], oi), a.specularColorTexture !== void 0 && r.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture, nt)), Promise.all(r);
        }
      }
      class CD {
        constructor(e) {
          this.parser = e, this.name = Je.EXT_MATERIALS_BUMP;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && r.push(i.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(r);
        }
      }
      class ID {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(e) {
          const i = this.parser.json.materials[e];
          return !i.extensions || !i.extensions[this.name] ? null : ln;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, n = i.json.materials[e];
          if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
          const r = [], a = n.extensions[this.name];
          return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && r.push(i.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(r);
        }
      }
      class MD {
        constructor(e) {
          this.parser = e, this.name = Je.KHR_TEXTURE_BASISU;
        }
        loadTexture(e) {
          const t = this.parser, i = t.json, n = i.textures[e];
          if (!n.extensions || !n.extensions[this.name]) return null;
          const r = n.extensions[this.name], a = t.options.ktx2Loader;
          if (!a) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null;
          }
          return t.loadTextureImage(e, r.source, a);
        }
      }
      class TD {
        constructor(e) {
          this.parser = e, this.name = Je.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(e) {
          const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const a = r.extensions[t], o = n.images[a.source];
          let c = i.textureLoader;
          if (o.uri) {
            const l = i.options.manager.getHandler(o.uri);
            l !== null && (c = l);
          }
          return this.detectSupport().then(function(l) {
            if (l) return i.loadTextureImage(e, a.source, c);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image();
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
              e(t.height === 1);
            };
          })), this.isSupported;
        }
      }
      class RD {
        constructor(e) {
          this.parser = e, this.name = Je.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(e) {
          const t = this.name, i = this.parser, n = i.json, r = n.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const a = r.extensions[t], o = n.images[a.source];
          let c = i.textureLoader;
          if (o.uri) {
            const l = i.options.manager.getHandler(o.uri);
            l !== null && (c = l);
          }
          return this.detectSupport().then(function(l) {
            if (l) return i.loadTextureImage(e, a.source, c);
            if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return i.loadTexture(e);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image();
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
              e(t.height === 1);
            };
          })), this.isSupported;
        }
      }
      class BD {
        constructor(e) {
          this.name = Je.EXT_MESHOPT_COMPRESSION, this.parser = e;
        }
        loadBufferView(e) {
          const t = this.parser.json, i = t.bufferViews[e];
          if (i.extensions && i.extensions[this.name]) {
            const n = i.extensions[this.name], r = this.parser.getDependency("buffer", n.buffer), a = this.parser.options.meshoptDecoder;
            if (!a || !a.supported) {
              if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              return null;
            }
            return r.then(function(o) {
              const c = n.byteOffset || 0, l = n.byteLength || 0, h = n.count, d = n.byteStride, u = new Uint8Array(o, c, l);
              return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(h, d, u, n.mode, n.filter).then(function(f) {
                return f.buffer;
              }) : a.ready.then(function() {
                const f = new ArrayBuffer(h * d);
                return a.decodeGltfBuffer(new Uint8Array(f), h, d, u, n.mode, n.filter), f;
              });
            });
          } else return null;
        }
      }
      class DD {
        constructor(e) {
          this.name = Je.EXT_MESH_GPU_INSTANCING, this.parser = e;
        }
        createNodeMesh(e) {
          const t = this.parser.json, i = t.nodes[e];
          if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
          const n = t.meshes[i.mesh];
          for (const l of n.primitives) if (l.mode !== Bi.TRIANGLES && l.mode !== Bi.TRIANGLE_STRIP && l.mode !== Bi.TRIANGLE_FAN && l.mode !== void 0) return null;
          const a = i.extensions[this.name].attributes, o = [], c = {};
          for (const l in a) o.push(this.parser.getDependency("accessor", a[l]).then((h) => (c[l] = h, c[l])));
          return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((l) => {
            const h = l.pop(), d = h.isGroup ? h.children : [
              h
            ], u = l[0].count, f = [];
            for (const p of d) {
              const m = new ge(), g = new T(), A = new At(), x = new T(1, 1, 1), b = new Q_(p.geometry, p.material, u);
              for (let y = 0; y < u; y++) c.TRANSLATION && g.fromBufferAttribute(c.TRANSLATION, y), c.ROTATION && A.fromBufferAttribute(c.ROTATION, y), c.SCALE && x.fromBufferAttribute(c.SCALE, y), b.setMatrixAt(y, m.compose(g, A, x));
              for (const y in c) if (y === "_COLOR_0") {
                const I = c[y];
                b.instanceColor = new dr(I.array, I.itemSize, I.normalized);
              } else y !== "TRANSLATION" && y !== "ROTATION" && y !== "SCALE" && p.geometry.setAttribute(y, c[y]);
              ct.prototype.copy.call(b, p), this.parser.assignFinalMaterial(b), f.push(b);
            }
            return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
          }));
        }
      }
      const wA = "glTF", Es = 12, vf = {
        JSON: 1313821514,
        BIN: 5130562
      };
      class PD {
        constructor(e) {
          this.name = Je.KHR_BINARY_GLTF, this.content = null, this.body = null;
          const t = new DataView(e, 0, Es), i = new TextDecoder();
          if (this.header = {
            magic: i.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, true),
            length: t.getUint32(8, true)
          }, this.header.magic !== wA) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const n = this.header.length - Es, r = new DataView(e, Es);
          let a = 0;
          for (; a < n; ) {
            const o = r.getUint32(a, true);
            a += 4;
            const c = r.getUint32(a, true);
            if (a += 4, c === vf.JSON) {
              const l = new Uint8Array(e, Es + a, o);
              this.content = i.decode(l);
            } else if (c === vf.BIN) {
              const l = Es + a;
              this.body = e.slice(l, l + o);
            }
            a += o;
          }
          if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class LD {
        constructor(e, t) {
          if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          this.name = Je.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const i = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, c = {}, l = {};
          for (const h in a) {
            const d = ch[h] || h.toLowerCase();
            o[d] = a[h];
          }
          for (const h in e.attributes) {
            const d = ch[h] || h.toLowerCase();
            if (a[h] !== void 0) {
              const u = i.accessors[e.attributes[h]], f = Jr[u.componentType];
              l[d] = f.name, c[d] = u.normalized === true;
            }
          }
          return t.getDependency("bufferView", r).then(function(h) {
            return new Promise(function(d, u) {
              n.decodeDracoFile(h, function(f) {
                for (const p in f.attributes) {
                  const m = f.attributes[p], g = c[p];
                  g !== void 0 && (m.normalized = g);
                }
                d(f);
              }, o, l, oi, u);
            });
          });
        }
      }
      class FD {
        constructor() {
          this.name = Je.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = true), e;
        }
      }
      class kD {
        constructor() {
          this.name = Je.KHR_MESH_QUANTIZATION;
        }
      }
      class bA extends ca {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n * 3 + n;
          for (let a = 0; a !== n; a++) t[a] = i[r + a];
          return t;
        }
        interpolate_(e, t, i, n) {
          const r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, c = o * 2, l = o * 3, h = n - t, d = (i - t) / h, u = d * d, f = u * d, p = e * l, m = p - l, g = -2 * f + 3 * u, A = f - u, x = 1 - g, b = A - u + d;
          for (let y = 0; y !== o; y++) {
            const I = a[m + y + o], M = a[m + y + c] * h, R = a[p + y + o], D = a[p + y] * h;
            r[y] = x * I + b * M + g * R + A * D;
          }
          return r;
        }
      }
      const UD = new At();
      class ND extends bA {
        interpolate_(e, t, i, n) {
          const r = super.interpolate_(e, t, i, n);
          return UD.fromArray(r).normalize().toArray(r), r;
        }
      }
      const Bi = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
      }, Jr = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      }, Sf = {
        9728: pi,
        9729: Rt,
        9984: zf,
        9985: io,
        9986: Ss,
        9987: Ji
      }, Cf = {
        33071: fi,
        33648: ho,
        10497: mi
      }, Xc = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
      }, ch = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      }, Nn = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      }, QD = {
        CUBICSPLINE: void 0,
        LINEAR: Ws,
        STEP: Vs
      }, Yc = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      function OD(s) {
        return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new Ei({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: false,
          depthTest: true,
          side: Sn
        })), s.DefaultMaterial;
      }
      function ar(s, e, t) {
        for (const i in t.extensions) s[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
      }
      function bn(s, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
      }
      function zD(s, e, t) {
        let i = false, n = false, r = false;
        for (let l = 0, h = e.length; l < h; l++) {
          const d = e[l];
          if (d.POSITION !== void 0 && (i = true), d.NORMAL !== void 0 && (n = true), d.COLOR_0 !== void 0 && (r = true), i && n && r) break;
        }
        if (!i && !n && !r) return Promise.resolve(s);
        const a = [], o = [], c = [];
        for (let l = 0, h = e.length; l < h; l++) {
          const d = e[l];
          if (i) {
            const u = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : s.attributes.position;
            a.push(u);
          }
          if (n) {
            const u = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : s.attributes.normal;
            o.push(u);
          }
          if (r) {
            const u = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : s.attributes.color;
            c.push(u);
          }
        }
        return Promise.all([
          Promise.all(a),
          Promise.all(o),
          Promise.all(c)
        ]).then(function(l) {
          const h = l[0], d = l[1], u = l[2];
          return i && (s.morphAttributes.position = h), n && (s.morphAttributes.normal = d), r && (s.morphAttributes.color = u), s.morphTargetsRelative = true, s;
        });
      }
      function GD(s, e) {
        if (s.updateMorphTargets(), e.weights !== void 0) for (let t = 0, i = e.weights.length; t < i; t++) s.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (s.morphTargetInfluences.length === t.length) {
            s.morphTargetDictionary = {};
            for (let i = 0, n = t.length; i < n; i++) s.morphTargetDictionary[t[i]] = i;
          } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
      }
      function HD(s) {
        let e;
        const t = s.extensions && s.extensions[Je.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Kc(t.attributes) : e = s.indices + ":" + Kc(s.attributes) + ":" + s.mode, s.targets !== void 0) for (let i = 0, n = s.targets.length; i < n; i++) e += ":" + Kc(s.targets[i]);
        return e;
      }
      function Kc(s) {
        let e = "";
        const t = Object.keys(s).sort();
        for (let i = 0, n = t.length; i < n; i++) e += t[i] + ":" + s[t[i]] + ";";
        return e;
      }
      function lh(s) {
        switch (s) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
      }
      function VD(s) {
        return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : s.search(/\.ktx2($|\?)/i) > 0 || s.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
      }
      const WD = new ge();
      class jD {
        constructor(e = {}, t = {}) {
          this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new pD(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
          }, this.cameraCache = {
            refs: {},
            uses: {}
          }, this.lightCache = {
            refs: {},
            uses: {}
          }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
          let i = false, n = -1, r = false, a = -1;
          if (typeof navigator < "u") {
            const o = navigator.userAgent;
            i = /^((?!chrome|android).)*safari/i.test(o) === true;
            const c = o.match(/Version\/(\d+)/);
            n = i && c ? parseInt(c[1], 10) : -1, r = o.indexOf("Firefox") > -1, a = r ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
          }
          typeof createImageBitmap > "u" || i && n < 17 || r && a < 98 ? this.textureLoader = new Si(this.options.manager) : this.textureLoader = new Om(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new fr(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const i = this, n = this.json, r = this.extensions;
          this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
            return a._markDefs && a._markDefs();
          }), Promise.all(this._invokeAll(function(a) {
            return a.beforeRoot && a.beforeRoot();
          })).then(function() {
            return Promise.all([
              i.getDependencies("scene"),
              i.getDependencies("animation"),
              i.getDependencies("camera")
            ]);
          }).then(function(a) {
            const o = {
              scene: a[0][n.scene || 0],
              scenes: a[0],
              animations: a[1],
              cameras: a[2],
              asset: n.asset,
              parser: i,
              userData: {}
            };
            return ar(r, o, n), bn(o, n), Promise.all(i._invokeAll(function(c) {
              return c.afterRoot && c.afterRoot(o);
            })).then(function() {
              for (const c of o.scenes) c.updateMatrixWorld();
              e(o);
            });
          }).catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
          for (let n = 0, r = t.length; n < r; n++) {
            const a = t[n].joints;
            for (let o = 0, c = a.length; o < c; o++) e[a[o]].isBone = true;
          }
          for (let n = 0, r = e.length; n < r; n++) {
            const a = e[n];
            a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = true)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, i) {
          if (e.refs[t] <= 1) return i;
          const n = i.clone(), r = (a, o) => {
            const c = this.associations.get(a);
            c != null && this.associations.set(o, c);
            for (const [l, h] of a.children.entries()) r(h, o.children[l]);
          };
          return r(i, n), n.name += "_instance_" + e.uses[t]++, n;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let i = 0; i < t.length; i++) {
            const n = e(t[i]);
            if (n) return n;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const i = [];
          for (let n = 0; n < t.length; n++) {
            const r = e(t[n]);
            r && i.push(r);
          }
          return i;
        }
        getDependency(e, t) {
          const i = e + ":" + t;
          let n = this.cache.get(i);
          if (!n) {
            switch (e) {
              case "scene":
                n = this.loadScene(t);
                break;
              case "node":
                n = this._invokeOne(function(r) {
                  return r.loadNode && r.loadNode(t);
                });
                break;
              case "mesh":
                n = this._invokeOne(function(r) {
                  return r.loadMesh && r.loadMesh(t);
                });
                break;
              case "accessor":
                n = this.loadAccessor(t);
                break;
              case "bufferView":
                n = this._invokeOne(function(r) {
                  return r.loadBufferView && r.loadBufferView(t);
                });
                break;
              case "buffer":
                n = this.loadBuffer(t);
                break;
              case "material":
                n = this._invokeOne(function(r) {
                  return r.loadMaterial && r.loadMaterial(t);
                });
                break;
              case "texture":
                n = this._invokeOne(function(r) {
                  return r.loadTexture && r.loadTexture(t);
                });
                break;
              case "skin":
                n = this.loadSkin(t);
                break;
              case "animation":
                n = this._invokeOne(function(r) {
                  return r.loadAnimation && r.loadAnimation(t);
                });
                break;
              case "camera":
                n = this.loadCamera(t);
                break;
              default:
                if (n = this._invokeOne(function(r) {
                  return r != this && r.getDependency && r.getDependency(e, t);
                }), !n) throw new Error("Unknown type: " + e);
                break;
            }
            this.cache.add(i, n);
          }
          return n;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const i = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(n.map(function(r, a) {
              return i.getDependency(e, a);
            })), this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e], i = this.fileLoader;
          if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
          if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Je.KHR_BINARY_GLTF].body);
          const n = this.options;
          return new Promise(function(r, a) {
            i.load(Kr.resolveURL(t.uri, n.path), r, void 0, function() {
              a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function(i) {
            const n = t.byteLength || 0, r = t.byteOffset || 0;
            return i.slice(r, r + n);
          });
        }
        loadAccessor(e) {
          const t = this, i = this.json, n = this.json.accessors[e];
          if (n.bufferView === void 0 && n.sparse === void 0) {
            const a = Xc[n.type], o = Jr[n.componentType], c = n.normalized === true, l = new o(n.count * a);
            return Promise.resolve(new ni(l, a, c));
          }
          const r = [];
          return n.bufferView !== void 0 ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), n.sparse !== void 0 && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then(function(a) {
            const o = a[0], c = Xc[n.type], l = Jr[n.componentType], h = l.BYTES_PER_ELEMENT, d = h * c, u = n.byteOffset || 0, f = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, p = n.normalized === true;
            let m, g;
            if (f && f !== d) {
              const A = Math.floor(u / f), x = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + A + ":" + n.count;
              let b = t.cache.get(x);
              b || (m = new l(o, A * f, n.count * f / h), b = new F_(m, f / h), t.cache.add(x, b)), g = new Ih(b, c, u % f / h, p);
            } else o === null ? m = new l(n.count * c) : m = new l(o, u, n.count * c), g = new ni(m, c, p);
            if (n.sparse !== void 0) {
              const A = Xc.SCALAR, x = Jr[n.sparse.indices.componentType], b = n.sparse.indices.byteOffset || 0, y = n.sparse.values.byteOffset || 0, I = new x(a[1], b, n.sparse.count * A), M = new l(a[2], y, n.sparse.count * c);
              o !== null && (g = new ni(g.array.slice(), g.itemSize, g.normalized)), g.normalized = false;
              for (let R = 0, D = I.length; R < D; R++) {
                const S = I[R];
                if (g.setX(S, M[R * c]), c >= 2 && g.setY(S, M[R * c + 1]), c >= 3 && g.setZ(S, M[R * c + 2]), c >= 4 && g.setW(S, M[R * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
              g.normalized = p;
            }
            return g;
          });
        }
        loadTexture(e) {
          const t = this.json, i = this.options, r = t.textures[e].source, a = t.images[r];
          let o = this.textureLoader;
          if (a.uri) {
            const c = i.manager.getHandler(a.uri);
            c !== null && (o = c);
          }
          return this.loadTextureImage(e, r, o);
        }
        loadTextureImage(e, t, i) {
          const n = this, r = this.json, a = r.textures[e], o = r.images[t], c = (o.uri || o.bufferView) + ":" + a.sampler;
          if (this.textureCache[c]) return this.textureCache[c];
          const l = this.loadImageSource(t, i).then(function(h) {
            h.flipY = false, h.name = a.name || o.name || "", h.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === false && (h.name = o.uri);
            const u = (r.samplers || {})[a.sampler] || {};
            return h.magFilter = Sf[u.magFilter] || Rt, h.minFilter = Sf[u.minFilter] || Ji, h.wrapS = Cf[u.wrapS] || mi, h.wrapT = Cf[u.wrapT] || mi, h.generateMipmaps = !h.isCompressedTexture && h.minFilter !== pi && h.minFilter !== Rt, n.associations.set(h, {
              textures: e
            }), h;
          }).catch(function() {
            return null;
          });
          return this.textureCache[c] = l, l;
        }
        loadImageSource(e, t) {
          const i = this, n = this.json, r = this.options;
          if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((d) => d.clone());
          const a = n.images[e], o = self.URL || self.webkitURL;
          let c = a.uri || "", l = false;
          if (a.bufferView !== void 0) c = i.getDependency("bufferView", a.bufferView).then(function(d) {
            l = true;
            const u = new Blob([
              d
            ], {
              type: a.mimeType
            });
            return c = o.createObjectURL(u), c;
          });
          else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
          const h = Promise.resolve(c).then(function(d) {
            return new Promise(function(u, f) {
              let p = u;
              t.isImageBitmapLoader === true && (p = function(m) {
                const g = new Nt(m);
                g.needsUpdate = true, u(g);
              }), t.load(Kr.resolveURL(d, r.path), p, void 0, f);
            });
          }).then(function(d) {
            return l === true && o.revokeObjectURL(c), bn(d, a), d.userData.mimeType = a.mimeType || VD(a.uri), d;
          }).catch(function(d) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", c), d;
          });
          return this.sourceCache[e] = h, h;
        }
        assignTexture(e, t, i, n) {
          const r = this;
          return this.getDependency("texture", i.index).then(function(a) {
            if (!a) return null;
            if (i.texCoord !== void 0 && i.texCoord > 0 && (a = a.clone(), a.channel = i.texCoord), r.extensions[Je.KHR_TEXTURE_TRANSFORM]) {
              const o = i.extensions !== void 0 ? i.extensions[Je.KHR_TEXTURE_TRANSFORM] : void 0;
              if (o) {
                const c = r.associations.get(a);
                a = r.extensions[Je.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), r.associations.set(a, c);
              }
            }
            return n !== void 0 && (a.colorSpace = n), e[t] = a, a;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let i = e.material;
          const n = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
          if (e.isPoints) {
            const o = "PointsMaterial:" + i.uuid;
            let c = this.cache.get(o);
            c || (c = new ap(), Fi.prototype.copy.call(c, i), c.color.copy(i.color), c.map = i.map, c.sizeAttenuation = false, this.cache.add(o, c)), i = c;
          } else if (e.isLine) {
            const o = "LineBasicMaterial:" + i.uuid;
            let c = this.cache.get(o);
            c || (c = new oa(), Fi.prototype.copy.call(c, i), c.color.copy(i.color), c.map = i.map, this.cache.add(o, c)), i = c;
          }
          if (n || r || a) {
            let o = "ClonedMaterial:" + i.uuid + ":";
            n && (o += "derivative-tangents:"), r && (o += "vertex-colors:"), a && (o += "flat-shading:");
            let c = this.cache.get(o);
            c || (c = i.clone(), r && (c.vertexColors = true), a && (c.flatShading = true), n && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(o, c), this.associations.set(c, this.associations.get(i))), i = c;
          }
          e.material = i;
        }
        getMaterialType() {
          return Ei;
        }
        loadMaterial(e) {
          const t = this, i = this.json, n = this.extensions, r = i.materials[e];
          let a;
          const o = {}, c = r.extensions || {}, l = [];
          if (c[Je.KHR_MATERIALS_UNLIT]) {
            const d = n[Je.KHR_MATERIALS_UNLIT];
            a = d.getMaterialType(), l.push(d.extendParams(o, r, t));
          } else {
            const d = r.pbrMetallicRoughness || {};
            if (o.color = new ue(1, 1, 1), o.opacity = 1, Array.isArray(d.baseColorFactor)) {
              const u = d.baseColorFactor;
              o.color.setRGB(u[0], u[1], u[2], oi), o.opacity = u[3];
            }
            d.baseColorTexture !== void 0 && l.push(t.assignTexture(o, "map", d.baseColorTexture, nt)), o.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, o.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (l.push(t.assignTexture(o, "metalnessMap", d.metallicRoughnessTexture)), l.push(t.assignTexture(o, "roughnessMap", d.metallicRoughnessTexture))), a = this._invokeOne(function(u) {
              return u.getMaterialType && u.getMaterialType(e);
            }), l.push(Promise.all(this._invokeAll(function(u) {
              return u.extendMaterialParams && u.extendMaterialParams(e, o);
            })));
          }
          r.doubleSided === true && (o.side = Yi);
          const h = r.alphaMode || Yc.OPAQUE;
          if (h === Yc.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, h === Yc.MASK && (o.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && a !== Zi && (l.push(t.assignTexture(o, "normalMap", r.normalTexture)), o.normalScale = new oe(1, 1), r.normalTexture.scale !== void 0)) {
            const d = r.normalTexture.scale;
            o.normalScale.set(d, d);
          }
          if (r.occlusionTexture !== void 0 && a !== Zi && (l.push(t.assignTexture(o, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && a !== Zi) {
            const d = r.emissiveFactor;
            o.emissive = new ue().setRGB(d[0], d[1], d[2], oi);
          }
          return r.emissiveTexture !== void 0 && a !== Zi && l.push(t.assignTexture(o, "emissiveMap", r.emissiveTexture, nt)), Promise.all(l).then(function() {
            const d = new a(o);
            return r.name && (d.name = r.name), bn(d, r), t.associations.set(d, {
              materials: e
            }), r.extensions && ar(n, d, r), d;
          });
        }
        createUniqueName(e) {
          const t = tt.sanitizeNodeName(e || "");
          return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
        }
        loadGeometries(e) {
          const t = this, i = this.extensions, n = this.primitiveCache;
          function r(o) {
            return i[Je.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(c) {
              return If(c, o, t);
            });
          }
          const a = [];
          for (let o = 0, c = e.length; o < c; o++) {
            const l = e[o], h = HD(l), d = n[h];
            if (d) a.push(d.promise);
            else {
              let u;
              l.extensions && l.extensions[Je.KHR_DRACO_MESH_COMPRESSION] ? u = r(l) : u = If(new Qt(), l, t), n[h] = {
                primitive: l,
                promise: u
              }, a.push(u);
            }
          }
          return Promise.all(a);
        }
        loadMesh(e) {
          const t = this, i = this.json, n = this.extensions, r = i.meshes[e], a = r.primitives, o = [];
          for (let c = 0, l = a.length; c < l; c++) {
            const h = a[c].material === void 0 ? OD(this.cache) : this.getDependency("material", a[c].material);
            o.push(h);
          }
          return o.push(t.loadGeometries(a)), Promise.all(o).then(function(c) {
            const l = c.slice(0, c.length - 1), h = c[c.length - 1], d = [];
            for (let f = 0, p = h.length; f < p; f++) {
              const m = h[f], g = a[f];
              let A;
              const x = l[f];
              if (g.mode === Bi.TRIANGLES || g.mode === Bi.TRIANGLE_STRIP || g.mode === Bi.TRIANGLE_FAN || g.mode === void 0) A = r.isSkinnedMesh === true ? new Mh(m, x) : new yt(m, x), A.isSkinnedMesh === true && A.normalizeSkinWeights(), g.mode === Bi.TRIANGLE_STRIP ? A.geometry = Ku(A.geometry, Kf) : g.mode === Bi.TRIANGLE_FAN && (A.geometry = Ku(A.geometry, Ql));
              else if (g.mode === Bi.LINES) A = new sp(m, x);
              else if (g.mode === Bi.LINE_STRIP) A = new is(m, x);
              else if (g.mode === Bi.LINE_LOOP) A = new G_(m, x);
              else if (g.mode === Bi.POINTS) A = new H_(m, x);
              else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
              Object.keys(A.geometry.morphAttributes).length > 0 && GD(A, r), A.name = t.createUniqueName(r.name || "mesh_" + e), bn(A, r), g.extensions && ar(n, A, g), t.assignFinalMaterial(A), d.push(A);
            }
            for (let f = 0, p = d.length; f < p; f++) t.associations.set(d[f], {
              meshes: e,
              primitives: f
            });
            if (d.length === 1) return r.extensions && ar(n, d[0], r), d[0];
            const u = new Li();
            r.extensions && ar(n, u, r), t.associations.set(u, {
              meshes: e
            });
            for (let f = 0, p = d.length; f < p; f++) u.add(d[f]);
            return u;
          });
        }
        loadCamera(e) {
          let t;
          const i = this.json.cameras[e], n = i[i.type];
          if (!n) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return i.type === "perspective" ? t = new Vt(Ut.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (t = new Uh(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), bn(t, i), Promise.resolve(t);
        }
        loadSkin(e) {
          const t = this.json.skins[e], i = [];
          for (let n = 0, r = t.joints.length; n < r; n++) i.push(this._loadNodeShallow(t.joints[n]));
          return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
            const r = n.pop(), a = n, o = [], c = [];
            for (let l = 0, h = a.length; l < h; l++) {
              const d = a[l];
              if (d) {
                o.push(d);
                const u = new ge();
                r !== null && u.fromArray(r.array, l * 16), c.push(u);
              } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[l]);
            }
            return new aa(o, c);
          });
        }
        loadAnimation(e) {
          const t = this.json, i = this, n = t.animations[e], r = n.name ? n.name : "animation_" + e, a = [], o = [], c = [], l = [], h = [];
          for (let d = 0, u = n.channels.length; d < u; d++) {
            const f = n.channels[d], p = n.samplers[f.sampler], m = f.target, g = m.node, A = n.parameters !== void 0 ? n.parameters[p.input] : p.input, x = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
            m.node !== void 0 && (a.push(this.getDependency("node", g)), o.push(this.getDependency("accessor", A)), c.push(this.getDependency("accessor", x)), l.push(p), h.push(m));
          }
          return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(c),
            Promise.all(l),
            Promise.all(h)
          ]).then(function(d) {
            const u = d[0], f = d[1], p = d[2], m = d[3], g = d[4], A = [];
            for (let x = 0, b = u.length; x < b; x++) {
              const y = u[x], I = f[x], M = p[x], R = m[x], D = g[x];
              if (y === void 0) continue;
              y.updateMatrix && y.updateMatrix();
              const S = i._createAnimationTracks(y, I, M, R, D);
              if (S) for (let E = 0; E < S.length; E++) A.push(S[E]);
            }
            return new vo(r, void 0, A);
          });
        }
        createNodeMesh(e) {
          const t = this.json, i = this, n = t.nodes[e];
          return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(r) {
            const a = i._getNodeRef(i.meshCache, n.mesh, r);
            return n.weights !== void 0 && a.traverse(function(o) {
              if (o.isMesh) for (let c = 0, l = n.weights.length; c < l; c++) o.morphTargetInfluences[c] = n.weights[c];
            }), a;
          });
        }
        loadNode(e) {
          const t = this.json, i = this, n = t.nodes[e], r = i._loadNodeShallow(e), a = [], o = n.children || [];
          for (let l = 0, h = o.length; l < h; l++) a.push(i.getDependency("node", o[l]));
          const c = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
          return Promise.all([
            r,
            Promise.all(a),
            c
          ]).then(function(l) {
            const h = l[0], d = l[1], u = l[2];
            u !== null && h.traverse(function(f) {
              f.isSkinnedMesh && f.bind(u, WD);
            });
            for (let f = 0, p = d.length; f < p; f++) h.add(d[f]);
            return h;
          });
        }
        _loadNodeShallow(e) {
          const t = this.json, i = this.extensions, n = this;
          if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
          const r = t.nodes[e], a = r.name ? n.createUniqueName(r.name) : "", o = [], c = n._invokeOne(function(l) {
            return l.createNodeMesh && l.createNodeMesh(e);
          });
          return c && o.push(c), r.camera !== void 0 && o.push(n.getDependency("camera", r.camera).then(function(l) {
            return n._getNodeRef(n.cameraCache, r.camera, l);
          })), n._invokeAll(function(l) {
            return l.createNodeAttachment && l.createNodeAttachment(e);
          }).forEach(function(l) {
            o.push(l);
          }), this.nodeCache[e] = Promise.all(o).then(function(l) {
            let h;
            if (r.isBone === true ? h = new qs() : l.length > 1 ? h = new Li() : l.length === 1 ? h = l[0] : h = new ct(), h !== l[0]) for (let d = 0, u = l.length; d < u; d++) h.add(l[d]);
            if (r.name && (h.userData.name = r.name, h.name = a), bn(h, r), r.extensions && ar(i, h, r), r.matrix !== void 0) {
              const d = new ge();
              d.fromArray(r.matrix), h.applyMatrix4(d);
            } else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
            return n.associations.has(h) || n.associations.set(h, {}), n.associations.get(h).nodes = e, h;
          }), this.nodeCache[e];
        }
        loadScene(e) {
          const t = this.extensions, i = this.json.scenes[e], n = this, r = new Li();
          i.name && (r.name = n.createUniqueName(i.name)), bn(r, i), i.extensions && ar(t, r, i);
          const a = i.nodes || [], o = [];
          for (let c = 0, l = a.length; c < l; c++) o.push(n.getDependency("node", a[c]));
          return Promise.all(o).then(function(c) {
            for (let h = 0, d = c.length; h < d; h++) r.add(c[h]);
            const l = (h) => {
              const d = /* @__PURE__ */ new Map();
              for (const [u, f] of n.associations) (u instanceof Fi || u instanceof Nt) && d.set(u, f);
              return h.traverse((u) => {
                const f = n.associations.get(u);
                f != null && d.set(u, f);
              }), d;
            };
            return n.associations = l(r), r;
          });
        }
        _createAnimationTracks(e, t, i, n, r) {
          const a = [], o = e.name ? e.name : e.uuid, c = [];
          Nn[r.path] === Nn.weights ? e.traverse(function(u) {
            u.morphTargetInfluences && c.push(u.name ? u.name : u.uuid);
          }) : c.push(o);
          let l;
          switch (Nn[r.path]) {
            case Nn.weights:
              l = _r;
              break;
            case Nn.rotation:
              l = Hn;
              break;
            case Nn.translation:
            case Nn.scale:
              l = mr;
              break;
            default:
              switch (i.itemSize) {
                case 1:
                  l = _r;
                  break;
                case 2:
                case 3:
                default:
                  l = mr;
                  break;
              }
              break;
          }
          const h = n.interpolation !== void 0 ? QD[n.interpolation] : Ws, d = this._getArrayFromAccessor(i);
          for (let u = 0, f = c.length; u < f; u++) {
            const p = new l(c[u] + "." + Nn[r.path], t.array, d, h);
            n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(p), a.push(p);
          }
          return a;
        }
        _getArrayFromAccessor(e) {
          let t = e.array;
          if (e.normalized) {
            const i = lh(t.constructor), n = new Float32Array(t.length);
            for (let r = 0, a = t.length; r < a; r++) n[r] = t[r] * i;
            t = n;
          }
          return t;
        }
        _createCubicSplineTrackInterpolant(e) {
          e.createInterpolant = function(i) {
            const n = this instanceof Hn ? ND : bA;
            return new n(this.times, this.values, this.getValueSize() / 3, i);
          }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
        }
      }
      function qD(s, e, t) {
        const i = e.attributes, n = new on();
        if (i.POSITION !== void 0) {
          const o = t.json.accessors[i.POSITION], c = o.min, l = o.max;
          if (c !== void 0 && l !== void 0) {
            if (n.set(new T(c[0], c[1], c[2]), new T(l[0], l[1], l[2])), o.normalized) {
              const h = lh(Jr[o.componentType]);
              n.min.multiplyScalar(h), n.max.multiplyScalar(h);
            }
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
          }
        } else return;
        const r = e.targets;
        if (r !== void 0) {
          const o = new T(), c = new T();
          for (let l = 0, h = r.length; l < h; l++) {
            const d = r[l];
            if (d.POSITION !== void 0) {
              const u = t.json.accessors[d.POSITION], f = u.min, p = u.max;
              if (f !== void 0 && p !== void 0) {
                if (c.setX(Math.max(Math.abs(f[0]), Math.abs(p[0]))), c.setY(Math.max(Math.abs(f[1]), Math.abs(p[1]))), c.setZ(Math.max(Math.abs(f[2]), Math.abs(p[2]))), u.normalized) {
                  const m = lh(Jr[u.componentType]);
                  c.multiplyScalar(m);
                }
                o.max(c);
              } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            }
          }
          n.expandByVector(o);
        }
        s.boundingBox = n;
        const a = new cn();
        n.getCenter(a.center), a.radius = n.min.distanceTo(n.max) / 2, s.boundingSphere = a;
      }
      function If(s, e, t) {
        const i = e.attributes, n = [];
        function r(a, o) {
          return t.getDependency("accessor", a).then(function(c) {
            s.setAttribute(o, c);
          });
        }
        for (const a in i) {
          const o = ch[a] || a.toLowerCase();
          o in s.attributes || n.push(r(i[a], o));
        }
        if (e.indices !== void 0 && !s.index) {
          const a = t.getDependency("accessor", e.indices).then(function(o) {
            s.setIndex(o);
          });
          n.push(a);
        }
        return ze.workingColorSpace !== oi && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ze.workingColorSpace}" not supported.`), bn(s, e), qD(s, e, t), Promise.all(n).then(function() {
          return e.targets !== void 0 ? zD(s, e.targets, t) : s;
        });
      }
      class XD {
        constructor(e = 16777215, t = 1, i = new T(0, 0, 0)) {
          this.dirLight = new Oo(e, t), this.offset = new T(60, 100, 0), this.targetPosition = i, this.dirLight.target = new ct(), this._initDirLight();
        }
        _initDirLight() {
          const { x: e, y: t, z: i } = new T().addVectors(this.targetPosition, this.offset);
          this.dirLight.position.set(e, t, i), this.dirLight.target.position.copy(this.targetPosition), this.dirLight.castShadow = true, this.dirLight.shadow.bias = -1e-3, this.dirLight.shadow.mapSize.set(1024, 1024), this.dirLight.shadow.camera.near = 0.5, this.dirLight.shadow.camera.far = 500, this.dirLight.shadow.camera.left = -100, this.dirLight.shadow.camera.right = 100, this.dirLight.shadow.camera.top = 100, this.dirLight.shadow.camera.bottom = -100;
        }
        updateDirLightPosition(e) {
          const { x: t, y: i, z: n } = new T().addVectors(e, this.offset);
          this.dirLight.position.set(t, i, n), this.dirLight.target.position.copy(e), this.dirLight.target.updateMatrixWorld();
        }
      }
      class ia extends yt {
        constructor(e, t = {}) {
          super(e), this.isReflector = true, this.type = "Reflector", this.camera = new Vt();
          const i = this, n = t.color !== void 0 ? new ue(t.color) : new ue(8355711), r = t.textureWidth || 512, a = t.textureHeight || 512, o = t.clipBias || 0, c = t.shader || ia.ReflectorShader, l = t.multisample !== void 0 ? t.multisample : 4, h = new Xi(), d = new T(), u = new T(), f = new T(), p = new ge(), m = new T(0, 0, -1), g = new je(), A = new T(), x = new T(), b = new je(), y = new ge(), I = this.camera, M = new Cn(r, a, {
            samples: l,
            type: vi
          }), R = new ki({
            name: c.name !== void 0 ? c.name : "unspecified",
            uniforms: Uo.clone(c.uniforms),
            fragmentShader: c.fragmentShader,
            vertexShader: c.vertexShader
          });
          R.uniforms.tDiffuse.value = M.texture, R.uniforms.color.value = n, R.uniforms.textureMatrix.value = y, this.material = R, this.onBeforeRender = function(D, S, E) {
            if (u.setFromMatrixPosition(i.matrixWorld), f.setFromMatrixPosition(E.matrixWorld), p.extractRotation(i.matrixWorld), d.set(0, 0, 1), d.applyMatrix4(p), A.subVectors(u, f), A.dot(d) > 0) return;
            A.reflect(d).negate(), A.add(u), p.extractRotation(E.matrixWorld), m.set(0, 0, -1), m.applyMatrix4(p), m.add(f), x.subVectors(u, m), x.reflect(d).negate(), x.add(u), I.position.copy(A), I.up.set(0, 1, 0), I.up.applyMatrix4(p), I.up.reflect(d), I.lookAt(x), I.far = E.far, I.updateMatrixWorld(), I.projectionMatrix.copy(E.projectionMatrix), y.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), y.multiply(I.projectionMatrix), y.multiply(I.matrixWorldInverse), y.multiply(i.matrixWorld), h.setFromNormalAndCoplanarPoint(d, u), h.applyMatrix4(I.matrixWorldInverse), g.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
            const P = I.projectionMatrix;
            b.x = (Math.sign(g.x) + P.elements[8]) / P.elements[0], b.y = (Math.sign(g.y) + P.elements[9]) / P.elements[5], b.z = -1, b.w = (1 + P.elements[10]) / P.elements[14], g.multiplyScalar(2 / g.dot(b)), P.elements[2] = g.x, P.elements[6] = g.y, P.elements[10] = g.z + 1 - o, P.elements[14] = g.w, i.visible = false;
            const j = D.getRenderTarget(), H = D.xr.enabled, Y = D.shadowMap.autoUpdate;
            D.xr.enabled = false, D.shadowMap.autoUpdate = false, D.setRenderTarget(M), D.state.buffers.depth.setMask(true), D.autoClear === false && D.clear(), D.render(S, I), D.xr.enabled = H, D.shadowMap.autoUpdate = Y, D.setRenderTarget(j);
            const te = E.viewport;
            te !== void 0 && D.state.viewport(te), i.visible = true;
          }, this.getRenderTarget = function() {
            return M;
          }, this.dispose = function() {
            M.dispose(), i.material.dispose();
          };
        }
      }
      ia.ReflectorShader = {
        name: "ReflectorShader",
        uniforms: {
          color: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          textureMatrix: {
            value: null
          }
        },
        vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
        fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
      };
      class na extends yt {
        constructor(e, t = {}) {
          super(e), this.isRefractor = true, this.type = "Refractor", this.camera = new Vt();
          const i = this, n = t.color !== void 0 ? new ue(t.color) : new ue(8355711), r = t.textureWidth || 512, a = t.textureHeight || 512, o = t.clipBias || 0, c = t.shader || na.RefractorShader, l = t.multisample !== void 0 ? t.multisample : 4, h = this.camera;
          h.matrixAutoUpdate = false, h.userData.refractor = true;
          const d = new Xi(), u = new ge(), f = new Cn(r, a, {
            samples: l,
            type: vi
          });
          this.material = new ki({
            name: c.name !== void 0 ? c.name : "unspecified",
            uniforms: Uo.clone(c.uniforms),
            vertexShader: c.vertexShader,
            fragmentShader: c.fragmentShader,
            transparent: true
          }), this.material.uniforms.color.value = n, this.material.uniforms.tDiffuse.value = f.texture, this.material.uniforms.textureMatrix.value = u;
          const p = function() {
            const b = new T(), y = new T(), I = new ge(), M = new T(), R = new T();
            return function(S) {
              return b.setFromMatrixPosition(i.matrixWorld), y.setFromMatrixPosition(S.matrixWorld), M.subVectors(b, y), I.extractRotation(i.matrixWorld), R.set(0, 0, 1), R.applyMatrix4(I), M.dot(R) < 0;
            };
          }(), m = function() {
            const b = new T(), y = new T(), I = new At(), M = new T();
            return function() {
              i.matrixWorld.decompose(y, I, M), b.set(0, 0, 1).applyQuaternion(I).normalize(), b.negate(), d.setFromNormalAndCoplanarPoint(b, y);
            };
          }(), g = function() {
            const b = new Xi(), y = new je(), I = new je();
            return function(R) {
              h.matrixWorld.copy(R.matrixWorld), h.matrixWorldInverse.copy(h.matrixWorld).invert(), h.projectionMatrix.copy(R.projectionMatrix), h.far = R.far, b.copy(d), b.applyMatrix4(h.matrixWorldInverse), y.set(b.normal.x, b.normal.y, b.normal.z, b.constant);
              const D = h.projectionMatrix;
              I.x = (Math.sign(y.x) + D.elements[8]) / D.elements[0], I.y = (Math.sign(y.y) + D.elements[9]) / D.elements[5], I.z = -1, I.w = (1 + D.elements[10]) / D.elements[14], y.multiplyScalar(2 / y.dot(I)), D.elements[2] = y.x, D.elements[6] = y.y, D.elements[10] = y.z + 1 - o, D.elements[14] = y.w;
            };
          }();
          function A(b) {
            u.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), u.multiply(b.projectionMatrix), u.multiply(b.matrixWorldInverse), u.multiply(i.matrixWorld);
          }
          function x(b, y, I) {
            i.visible = false;
            const M = b.getRenderTarget(), R = b.xr.enabled, D = b.shadowMap.autoUpdate;
            b.xr.enabled = false, b.shadowMap.autoUpdate = false, b.setRenderTarget(f), b.autoClear === false && b.clear(), b.render(y, h), b.xr.enabled = R, b.shadowMap.autoUpdate = D, b.setRenderTarget(M);
            const S = I.viewport;
            S !== void 0 && b.state.viewport(S), i.visible = true;
          }
          this.onBeforeRender = function(b, y, I) {
            I.userData.refractor !== true && p(I) && (m(), A(I), g(I), x(b, y, I));
          }, this.getRenderTarget = function() {
            return f;
          }, this.dispose = function() {
            f.dispose(), i.material.dispose();
          };
        }
      }
      na.RefractorShader = {
        name: "RefractorShader",
        uniforms: {
          color: {
            value: null
          },
          tDiffuse: {
            value: null
          },
          textureMatrix: {
            value: null
          }
        },
        vertexShader: `

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: `

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
      };
      class Jo extends yt {
        constructor(e, t = {}) {
          super(e), this.isWater = true, this.type = "Water";
          const i = this, n = t.color !== void 0 ? new ue(t.color) : new ue(16777215), r = t.textureWidth !== void 0 ? t.textureWidth : 512, a = t.textureHeight !== void 0 ? t.textureHeight : 512, o = t.clipBias !== void 0 ? t.clipBias : 0, c = t.flowDirection !== void 0 ? t.flowDirection : new oe(1, 0), l = t.flowSpeed !== void 0 ? t.flowSpeed : 0.03, h = t.reflectivity !== void 0 ? t.reflectivity : 0.02, d = t.scale !== void 0 ? t.scale : 1, u = t.shader !== void 0 ? t.shader : Jo.WaterShader, f = new Si(), p = t.flowMap || void 0, m = t.normalMap0 || f.load("./water/Water_1_M_Normal.jpg"), g = t.normalMap1 || f.load("./water/Water_2_M_Normal.jpg"), A = 0.15, x = A * 0.5, b = new ge(), y = new Sp();
          if (ia === void 0) {
            console.error("THREE.Water: Required component Reflector not found.");
            return;
          }
          if (na === void 0) {
            console.error("THREE.Water: Required component Refractor not found.");
            return;
          }
          const I = new ia(e, {
            textureWidth: r,
            textureHeight: a,
            clipBias: o
          }), M = new na(e, {
            textureWidth: r,
            textureHeight: a,
            clipBias: o
          });
          I.matrixAutoUpdate = false, M.matrixAutoUpdate = false, this.material = new ki({
            name: u.name,
            uniforms: Uo.merge([
              ce.fog,
              u.uniforms
            ]),
            vertexShader: u.vertexShader,
            fragmentShader: u.fragmentShader,
            transparent: true,
            fog: true
          }), p !== void 0 ? (this.material.defines.USE_FLOWMAP = "", this.material.uniforms.tFlowMap = {
            type: "t",
            value: p
          }) : this.material.uniforms.flowDirection = {
            type: "v2",
            value: c
          }, m.wrapS = m.wrapT = mi, g.wrapS = g.wrapT = mi, this.material.uniforms.tReflectionMap.value = I.getRenderTarget().texture, this.material.uniforms.tRefractionMap.value = M.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = m, this.material.uniforms.tNormalMap1.value = g, this.material.uniforms.color.value = n, this.material.uniforms.reflectivity.value = h, this.material.uniforms.textureMatrix.value = b, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = x, this.material.uniforms.config.value.z = x, this.material.uniforms.config.value.w = d;
          function R(S) {
            b.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), b.multiply(S.projectionMatrix), b.multiply(S.matrixWorldInverse), b.multiply(i.matrixWorld);
          }
          function D() {
            const S = y.getDelta(), E = i.material.uniforms.config;
            E.value.x += l * S, E.value.y = E.value.x + x, E.value.x >= A ? (E.value.x = 0, E.value.y = x) : E.value.y >= A && (E.value.y = E.value.y - A);
          }
          this.onBeforeRender = function(S, E, P) {
            R(P), D(), i.visible = false, I.matrixWorld.copy(i.matrixWorld), M.matrixWorld.copy(i.matrixWorld), I.onBeforeRender(S, E, P), M.onBeforeRender(S, E, P), i.visible = true;
          };
        }
      }
      Jo.WaterShader = {
        name: "WaterShader",
        uniforms: {
          color: {
            type: "c",
            value: null
          },
          reflectivity: {
            type: "f",
            value: 0
          },
          tReflectionMap: {
            type: "t",
            value: null
          },
          tRefractionMap: {
            type: "t",
            value: null
          },
          tNormalMap0: {
            type: "t",
            value: null
          },
          tNormalMap1: {
            type: "t",
            value: null
          },
          textureMatrix: {
            type: "m4",
            value: null
          },
          config: {
            type: "v4",
            value: new je()
          }
        },
        vertexShader: `

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			// gl_Position = projectionMatrix * mvPosition;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`,
        fragmentShader: `

		#include <common>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>

uniform sampler2D tReflectionMap;
uniform sampler2D tRefractionMap;
uniform sampler2D tNormalMap0;
uniform sampler2D tNormalMap1;
uniform sampler2D heightMap;  // \u{1F539} Add height map uniform

#ifdef USE_FLOWMAP
    uniform sampler2D tFlowMap;
#else
    uniform vec2 flowDirection;
#endif

uniform vec3 color;
uniform float reflectivity;
uniform vec4 config;

varying vec4 vCoord;
varying vec2 vUv;
varying vec3 vToEye;

void main() {
    #include <logdepthbuf_fragment>

    float flowMapOffset0 = config.x;
    float flowMapOffset1 = config.y;
    float halfCycle = config.z;
    float scale = config.w;

    vec3 toEye = normalize( vToEye );

    // \u{1F539} Sample height map and discard high areas
    float height = texture2D(heightMap, vUv).r;  
    if (height > 0.5) {  // Adjust threshold
		discard;  // Remove water above this height
    }  

    // Determine flow direction
    vec2 flow;
    #ifdef USE_FLOWMAP
        flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
    #else
        flow = flowDirection;
    #endif
    flow.x *= - 1.0;

    // Sample normal maps (distort UVs with flow data)
    vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
    vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

    // Linear interpolate to get the final normal color
    float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
    vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

    // Calculate normal vector
    vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

    // Calculate the fresnel term to blend reflection and refraction maps
    float theta = max( dot( toEye, normal ), 0.0 );
    float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

    // Calculate final UV coords
    vec3 coord = vCoord.xyz / vCoord.w;
    vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

    vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
    vec4 refractColor = texture2D( tRefractionMap, uv );

    // Multiply water color with the mix of both textures
    gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

	#include <tonemapping_fragment>
    #include <colorspace_fragment>
    #include <fog_fragment>
}
`
      };
      class YD {
        constructor(e) {
          this._scene = e, this._waterMeshWidth = 1220, this._waterMeshHeight = 1220, this._s = 1, this.tLoader = new Si(), this._initialize();
        }
        _initialize() {
          const e = this.tLoader.load("./map/heights_map.jpg", () => {
            e.needsUpdate = true, this.initializeWater(e);
          });
          e.wrapS = e.wrapT = mi, e.repeat.set(this._s, this._s), this.waterFlowDirMap = this.tLoader.load("./map/water_flow_map.jpeg"), this.waterFlowDirMap.wrapS = this.waterFlowDirMap.wrapT = mi, this.waterFlowDirMap.repeat.set(this._s, this._s);
        }
        initializeWater(e) {
          this.waterGeometry = new yr(this._waterMeshWidth, this._waterMeshHeight, 512, 512), this.water = new Jo(this.waterGeometry, {
            scale: 1,
            flowSpeed: 0.04,
            reflectivity: 0.35,
            flowMap: this.waterFlowDirMap
          }), this.water.material && this.water.material.uniforms ? (this.water.material.uniforms.heightMap = {
            value: e
          }, this.water.material.uniforms.heightMap.needsUpdate = true) : console.warn("Water material or uniforms are undefined."), this.water.position.y = -9, this.water.rotation.x = -Math.PI / 2, this._scene.add(this.water);
        }
      }
      class KD {
        constructor(e, t) {
          this.terrain = e, this.totalTime = 0, this.shaders = t;
        }
        fogHuck() {
          Qe.fog_fragment = `
#ifdef USE_FOG
  vec3 fogOrigin = cameraPosition;
  vec3 fogDirection = normalize(vWorldPosition - fogOrigin);
  float fogDepth = distance(vWorldPosition, fogOrigin);

  // Sample Perlin noise texture using world position
  // vec2 uv_m = vWorldPosition.xz * 0.0001; // Scale for large terrain
  vec2 uv_m = vWorldPosition.xz * 0.00005 + vec2(fogTime * 0.000000001, 0.0);
  float noiseSample = texture2D(perlinNoise, uv_m).r; // Grayscale sample

  // Modulate fog depth with noise
  fogDepth *= mix(noiseSample, 1.0, saturate((fogDepth - 5000.0) / 5000.0));
  fogDepth *= fogDepth;

  float heightFactor = 0.05;
  float fogFactor = heightFactor * exp(-fogOrigin.y * fogDensity) * (
      1.0 - exp(-fogDepth * fogDirection.y * fogDensity)) / fogDirection.y;
  fogFactor = saturate(fogFactor);

  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif
`, Qe.fog_pars_fragment = `
#ifdef USE_FOG
  uniform float fogTime;
  uniform vec3 fogColor;
  uniform sampler2D perlinNoise;
  varying vec3 vWorldPosition;
  #ifdef FOG_EXP2
    uniform float fogDensity;
  #else
    uniform float fogNear;
    uniform float fogFar;
  #endif
#endif`, Qe.fog_vertex = `
#ifdef USE_FOG
  vWorldPosition = worldPosition.xyz;
#endif`, Qe.fog_pars_vertex = `
#ifdef USE_FOG
  varying vec3 vWorldPosition;
#endif`;
        }
        fogStep(e) {
          this.totalTime += e;
          for (let t of this.shaders) t.uniforms.fogTime.value = this.totalTime, t.needsUpdate = true;
        }
      }
      class JD {
        constructor(e) {
          this.worldPhysics = e;
        }
        createVegetationCollider(e = {
          x: 0,
          y: 0,
          z: 0
        }, t = 1, i = {
          w: 1,
          x: 0,
          y: 0,
          z: 0
        }, n) {
          return this._setCollider(e, t, i, n);
        }
        _setCollider(e, t, i, n) {
          let r;
          return n.startsWith("stump") ? r = en.ColliderDesc.ball(t * 0.6) : n.startsWith("stone") ? r = en.ColliderDesc.ball(t * 3) : r = en.ColliderDesc.cylinder(t, t * 0.2), r.setTranslation(e.x, e.y, e.z), this.worldPhysics.createCollider(r);
        }
      }
      class ZD {
        constructor(e, t) {
          this.vegetationGroup = e, this.shaders = t, this.perlinTexture = this.createPerlinTexture();
        }
        createPerlinTexture() {
          const t = new Si().load("./noise/perlin_noise.png");
          return t.wrapS = t.wrapT = mi, t;
        }
        modify() {
          this.vegetationGroup.traverse((e) => {
            e.isMesh && (Array.isArray(e.material) ? e.material : [
              e.material
            ]).forEach((i) => {
              i.isMeshStandardMaterial && (i.onBeforeCompile = (n) => {
                n.uniforms.fogTime = {
                  value: 0
                }, n.uniforms.perlinNoise = {
                  value: this.perlinTexture
                }, this.shaders.push(n);
              });
            });
          });
        }
      }
      const $D = Math.PI / 180;
      function as(s) {
        return s * $D;
      }
      const vn = {
        x: 2,
        y: 2,
        z: 2
      }, Jc = {
        maxX: 400,
        minX: -400,
        maxZ: 400,
        minZ: -400
      }, Zc = {
        x: 0,
        y: -100,
        z: 0
      }, $a = {
        x: -40,
        y: 50,
        z: -40
      };
      class eP {
        constructor(e = 4) {
          this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0, this.workerCreator = null;
        }
        _initWorker(e) {
          if (!this.workers[e]) {
            const t = this.workerCreator();
            t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t;
          }
        }
        _getIdleWorker() {
          for (let e = 0; e < this.pool; e++) if (!(this.workerStatus & 1 << e)) return e;
          return -1;
        }
        _onMessage(e, t) {
          const i = this.workersResolve[e];
          if (i && i(t), this.queue.length) {
            const { resolve: n, msg: r, transfer: a } = this.queue.shift();
            this.workersResolve[e] = n, this.workers[e].postMessage(r, a);
          } else this.workerStatus ^= 1 << e;
        }
        setWorkerCreator(e) {
          this.workerCreator = e;
        }
        setWorkerLimit(e) {
          this.pool = e;
        }
        postMessage(e, t) {
          return new Promise((i) => {
            const n = this._getIdleWorker();
            n !== -1 ? (this._initWorker(n), this.workerStatus |= 1 << n, this.workersResolve[n] = i, this.workers[n].postMessage(e, t)) : this.queue.push({
              resolve: i,
              msg: e,
              transfer: t
            });
          });
        }
        dispose() {
          this.workers.forEach((e) => e.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0;
        }
      }
      const tP = 0, Mf = 2, iP = 1, Tf = 2, nP = 0, rP = 1, sP = 10, aP = 0, yA = 9, xA = 15, EA = 16, vA = 22, SA = 37, CA = 43, IA = 76, MA = 83, TA = 97, RA = 100, BA = 103, DA = 109, PA = 165, LA = 166, ud = 1000066e3;
      class oP {
        constructor() {
          this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [
            {
              vendorId: 0,
              descriptorType: 0,
              descriptorBlockSize: 0,
              versionNumber: 2,
              colorModel: 0,
              colorPrimaries: 1,
              transferFunction: 2,
              flags: 0,
              texelBlockDimension: [
                0,
                0,
                0,
                0
              ],
              bytesPlane: [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0
              ],
              samples: []
            }
          ], this.keyValue = {}, this.globalData = null;
        }
      }
      class vs {
        constructor(e, t, i, n) {
          this._dataView = void 0, this._littleEndian = void 0, this._offset = void 0, this._dataView = new DataView(e.buffer, e.byteOffset + t, i), this._littleEndian = n, this._offset = 0;
        }
        _nextUint8() {
          const e = this._dataView.getUint8(this._offset);
          return this._offset += 1, e;
        }
        _nextUint16() {
          const e = this._dataView.getUint16(this._offset, this._littleEndian);
          return this._offset += 2, e;
        }
        _nextUint32() {
          const e = this._dataView.getUint32(this._offset, this._littleEndian);
          return this._offset += 4, e;
        }
        _nextUint64() {
          const e = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
          return this._offset += 8, e;
        }
        _nextInt32() {
          const e = this._dataView.getInt32(this._offset, this._littleEndian);
          return this._offset += 4, e;
        }
        _nextUint8Array(e) {
          const t = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, e);
          return this._offset += e, t;
        }
        _skip(e) {
          return this._offset += e, this;
        }
        _scan(e, t) {
          t === void 0 && (t = 0);
          const i = this._offset;
          let n = 0;
          for (; this._dataView.getUint8(this._offset) !== t && n < e; ) n++, this._offset++;
          return n < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n);
        }
      }
      const hi = [
        171,
        75,
        84,
        88,
        32,
        50,
        48,
        187,
        13,
        10,
        26,
        10
      ];
      function Rf(s) {
        return new TextDecoder().decode(s);
      }
      function cP(s) {
        const e = new Uint8Array(s.buffer, s.byteOffset, hi.length);
        if (e[0] !== hi[0] || e[1] !== hi[1] || e[2] !== hi[2] || e[3] !== hi[3] || e[4] !== hi[4] || e[5] !== hi[5] || e[6] !== hi[6] || e[7] !== hi[7] || e[8] !== hi[8] || e[9] !== hi[9] || e[10] !== hi[10] || e[11] !== hi[11]) throw new Error("Missing KTX 2.0 identifier.");
        const t = new oP(), i = 17 * Uint32Array.BYTES_PER_ELEMENT, n = new vs(s, hi.length, i, true);
        t.vkFormat = n._nextUint32(), t.typeSize = n._nextUint32(), t.pixelWidth = n._nextUint32(), t.pixelHeight = n._nextUint32(), t.pixelDepth = n._nextUint32(), t.layerCount = n._nextUint32(), t.faceCount = n._nextUint32();
        const r = n._nextUint32();
        t.supercompressionScheme = n._nextUint32();
        const a = n._nextUint32(), o = n._nextUint32(), c = n._nextUint32(), l = n._nextUint32(), h = n._nextUint64(), d = n._nextUint64(), u = new vs(s, hi.length + i, 3 * r * 8, true);
        for (let Z = 0; Z < r; Z++) t.levels.push({
          levelData: new Uint8Array(s.buffer, s.byteOffset + u._nextUint64(), u._nextUint64()),
          uncompressedByteLength: u._nextUint64()
        });
        const f = new vs(s, a, o, true), p = {
          vendorId: f._skip(4)._nextUint16(),
          descriptorType: f._nextUint16(),
          versionNumber: f._nextUint16(),
          descriptorBlockSize: f._nextUint16(),
          colorModel: f._nextUint8(),
          colorPrimaries: f._nextUint8(),
          transferFunction: f._nextUint8(),
          flags: f._nextUint8(),
          texelBlockDimension: [
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8()
          ],
          bytesPlane: [
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8(),
            f._nextUint8()
          ],
          samples: []
        }, m = (p.descriptorBlockSize / 4 - 6) / 4;
        for (let Z = 0; Z < m; Z++) {
          const V = {
            bitOffset: f._nextUint16(),
            bitLength: f._nextUint8(),
            channelType: f._nextUint8(),
            samplePosition: [
              f._nextUint8(),
              f._nextUint8(),
              f._nextUint8(),
              f._nextUint8()
            ],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
          };
          64 & V.channelType ? (V.sampleLower = f._nextInt32(), V.sampleUpper = f._nextInt32()) : (V.sampleLower = f._nextUint32(), V.sampleUpper = f._nextUint32()), p.samples[Z] = V;
        }
        t.dataFormatDescriptor.length = 0, t.dataFormatDescriptor.push(p);
        const g = new vs(s, c, l, true);
        for (; g._offset < l; ) {
          const Z = g._nextUint32(), V = g._scan(Z), re = Rf(V);
          if (t.keyValue[re] = g._nextUint8Array(Z - V.byteLength - 1), re.match(/^ktx/i)) {
            const he = Rf(t.keyValue[re]);
            t.keyValue[re] = he.substring(0, he.lastIndexOf("\0"));
          }
          g._skip(Z % 4 ? 4 - Z % 4 : 0);
        }
        if (d <= 0) return t;
        const A = new vs(s, h, d, true), x = A._nextUint16(), b = A._nextUint16(), y = A._nextUint32(), I = A._nextUint32(), M = A._nextUint32(), R = A._nextUint32(), D = [];
        for (let Z = 0; Z < r; Z++) D.push({
          imageFlags: A._nextUint32(),
          rgbSliceByteOffset: A._nextUint32(),
          rgbSliceByteLength: A._nextUint32(),
          alphaSliceByteOffset: A._nextUint32(),
          alphaSliceByteLength: A._nextUint32()
        });
        const S = h + A._offset, E = S + y, P = E + I, j = P + M, H = new Uint8Array(s.buffer, s.byteOffset + S, y), Y = new Uint8Array(s.buffer, s.byteOffset + E, I), te = new Uint8Array(s.buffer, s.byteOffset + P, M), q = new Uint8Array(s.buffer, s.byteOffset + j, R);
        return t.globalData = {
          endpointCount: x,
          selectorCount: b,
          imageDescs: D,
          endpointsData: H,
          selectorsData: Y,
          tablesData: te,
          extendedData: q
        }, t;
      }
      let $c, mn, hh;
      const el = {
        env: {
          emscripten_notify_memory_growth: function(s) {
            hh = new Uint8Array(mn.exports.memory.buffer);
          }
        }
      };
      class lP {
        init() {
          return $c || ($c = typeof fetch < "u" ? fetch("data:application/wasm;base64," + Bf).then((e) => e.arrayBuffer()).then((e) => WebAssembly.instantiate(e, el)).then(this._init) : WebAssembly.instantiate(Buffer.from(Bf, "base64"), el).then(this._init), $c);
        }
        _init(e) {
          mn = e.instance, el.env.emscripten_notify_memory_growth(0);
        }
        decode(e, t = 0) {
          if (!mn) throw new Error("ZSTDDecoder: Await .init() before decoding.");
          const i = e.byteLength, n = mn.exports.malloc(i);
          hh.set(e, n), t = t || Number(mn.exports.ZSTD_findDecompressedSize(n, i));
          const r = mn.exports.malloc(t), a = mn.exports.ZSTD_decompress(r, t, n, i), o = hh.slice(r, r + a);
          return mn.exports.free(n), mn.exports.free(r), o;
        }
      }
      const Bf = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ", hP = "display-p3", dP = "display-p3-linear", tl = /* @__PURE__ */ new WeakMap();
      let il = 0, nl;
      class Di extends Ui {
        constructor(e) {
          super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new eP(), this.workerSourceURL = "", this.workerConfig = null, typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.');
        }
        setTranscoderPath(e) {
          return this.transcoderPath = e, this;
        }
        setWorkerLimit(e) {
          return this.workerPool.setWorkerLimit(e), this;
        }
        async detectSupportAsync(e) {
          return this.workerConfig = {
            astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
            astcHDRSupported: false,
            etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
            etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
            dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
            bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
            pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
          }, this;
        }
        detectSupport(e) {
          return e.isWebGPURenderer === true ? this.workerConfig = {
            astcSupported: e.hasFeature("texture-compression-astc"),
            astcHDRSupported: false,
            etc1Supported: e.hasFeature("texture-compression-etc1"),
            etc2Supported: e.hasFeature("texture-compression-etc2"),
            dxtSupported: e.hasFeature("texture-compression-bc"),
            bptcSupported: e.hasFeature("texture-compression-bptc"),
            pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
          } : this.workerConfig = {
            astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
            astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
            etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
          }, this;
        }
        init() {
          if (!this.transcoderPending) {
            const e = new fr(this.manager);
            e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
            const t = e.loadAsync("basis_transcoder.js"), i = new fr(this.manager);
            i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
            const n = i.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([
              t,
              n
            ]).then(([r, a]) => {
              const o = Di.BasisWorker.toString(), c = [
                "/* constants */",
                "let _EngineFormat = " + JSON.stringify(Di.EngineFormat),
                "let _EngineType = " + JSON.stringify(Di.EngineType),
                "let _TranscoderFormat = " + JSON.stringify(Di.TranscoderFormat),
                "let _BasisFormat = " + JSON.stringify(Di.BasisFormat),
                "/* basis_transcoder.js */",
                r,
                "/* worker */",
                o.substring(o.indexOf("{") + 1, o.lastIndexOf("}"))
              ].join(`
`);
              this.workerSourceURL = URL.createObjectURL(new Blob([
                c
              ])), this.transcoderBinary = a, this.workerPool.setWorkerCreator(() => {
                const l = new Worker(this.workerSourceURL), h = this.transcoderBinary.slice(0);
                return l.postMessage({
                  type: "init",
                  config: this.workerConfig,
                  transcoderBinary: h
                }, [
                  h
                ]), l;
              });
            }), il > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), il++;
          }
          return this.transcoderPending;
        }
        load(e, t, i, n) {
          if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
          const r = new fr(this.manager);
          r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (a) => {
            this.parse(a, t, n);
          }, i, n);
        }
        parse(e, t, i) {
          if (this.workerConfig === null) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
          if (tl.has(e)) return tl.get(e).promise.then(t).catch(i);
          this._createTexture(e).then((n) => t ? t(n) : null).catch(i);
        }
        _createTextureFrom(e, t) {
          const { type: i, error: n, data: { faces: r, width: a, height: o, format: c, type: l, dfdFlags: h } } = e;
          if (i === "error") return Promise.reject(n);
          let d;
          if (t.faceCount === 6) d = new W_(r, c, l);
          else {
            const u = r[0].mipmaps;
            d = t.layerCount > 1 ? new V_(u, a, o, t.layerCount, c, l) : new No(u, a, o, c, l);
          }
          return d.minFilter = r[0].mipmaps.length === 1 ? Rt : Ji, d.magFilter = Rt, d.generateMipmaps = false, d.needsUpdate = true, d.colorSpace = FA(t), d.premultiplyAlpha = !!(h & iP), d;
        }
        async _createTexture(e, t = {}) {
          const i = cP(new Uint8Array(e)), n = i.vkFormat === ud && i.dataFormatDescriptor[0].colorModel === 167;
          if (!(i.vkFormat === aP || n && !this.workerConfig.astcHDRSupported)) return fP(i);
          const a = t, o = this.init().then(() => this.workerPool.postMessage({
            type: "transcode",
            buffer: e,
            taskConfig: a
          }, [
            e
          ])).then((c) => this._createTextureFrom(c.data, i));
          return tl.set(e, {
            promise: o
          }), o;
        }
        dispose() {
          this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), il--;
        }
      }
      Di.BasisFormat = {
        ETC1S: 0,
        UASTC: 1,
        UASTC_HDR: 2
      };
      Di.TranscoderFormat = {
        ETC1: 0,
        ETC2: 1,
        BC1: 2,
        BC3: 3,
        BC4: 4,
        BC5: 5,
        BC7_M6_OPAQUE_ONLY: 6,
        BC7_M5: 7,
        PVRTC1_4_RGB: 8,
        PVRTC1_4_RGBA: 9,
        ASTC_4x4: 10,
        ATC_RGB: 11,
        ATC_RGBA_INTERPOLATED_ALPHA: 12,
        RGBA32: 13,
        RGB565: 14,
        BGR565: 15,
        RGBA4444: 16,
        BC6H: 22,
        RGB_HALF: 24,
        RGBA_HALF: 25
      };
      Di.EngineFormat = {
        RGBAFormat: Wt,
        RGBA_ASTC_4x4_Format: Gs,
        RGB_BPTC_UNSIGNED_Format: _o,
        RGBA_BPTC_Format: Bs,
        RGBA_ETC2_EAC_Format: go,
        RGBA_PVRTC_4BPPV1_Format: fo,
        RGBA_S3TC_DXT5_Format: Rs,
        RGB_ETC1_Format: po,
        RGB_ETC2_Format: Ao,
        RGB_PVRTC_4BPPV1_Format: uo,
        RGBA_S3TC_DXT1_Format: Ts
      };
      Di.EngineType = {
        UnsignedByteType: Jt,
        HalfFloatType: vi,
        FloatType: ii
      };
      Di.BasisWorker = function() {
        let s, e, t;
        const i = _EngineFormat, n = _EngineType, r = _TranscoderFormat, a = _BasisFormat;
        self.addEventListener("message", function(p) {
          const m = p.data;
          switch (m.type) {
            case "init":
              s = m.config, o(m.transcoderBinary);
              break;
            case "transcode":
              e.then(() => {
                try {
                  const { faces: g, buffers: A, width: x, height: b, hasAlpha: y, format: I, type: M, dfdFlags: R } = c(m.buffer);
                  self.postMessage({
                    type: "transcode",
                    id: m.id,
                    data: {
                      faces: g,
                      width: x,
                      height: b,
                      hasAlpha: y,
                      format: I,
                      type: M,
                      dfdFlags: R
                    }
                  }, A);
                } catch (g) {
                  console.error(g), self.postMessage({
                    type: "error",
                    id: m.id,
                    error: g.message
                  });
                }
              });
              break;
          }
        });
        function o(p) {
          e = new Promise((m) => {
            t = {
              wasmBinary: p,
              onRuntimeInitialized: m
            }, BASIS(t);
          }).then(() => {
            t.initializeBasis(), t.KTX2File === void 0 && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.");
          });
        }
        function c(p) {
          const m = new t.KTX2File(new Uint8Array(p));
          function g() {
            m.close(), m.delete();
          }
          if (!m.isValid()) throw g(), new Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
          let A;
          if (m.isUASTC()) A = a.UASTC;
          else if (m.isETC1S()) A = a.ETC1S;
          else if (m.isHDR()) A = a.UASTC_HDR;
          else throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
          const x = m.getWidth(), b = m.getHeight(), y = m.getLayers() || 1, I = m.getLevels(), M = m.getFaces(), R = m.getHasAlpha(), D = m.getDFDFlags(), { transcoderFormat: S, engineFormat: E, engineType: P } = d(A, x, b, R);
          if (!x || !b || !I) throw g(), new Error("THREE.KTX2Loader:	Invalid texture");
          if (!m.startTranscoding()) throw g(), new Error("THREE.KTX2Loader: .startTranscoding failed");
          const j = [], H = [];
          for (let Y = 0; Y < M; Y++) {
            const te = [];
            for (let q = 0; q < I; q++) {
              const Z = [];
              let V, re;
              for (let ve = 0; ve < y; ve++) {
                const Pe = m.getImageLevelInfo(q, ve, Y);
                Y === 0 && q === 0 && ve === 0 && (Pe.origWidth % 4 !== 0 || Pe.origHeight % 4 !== 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), I > 1 ? (V = Pe.origWidth, re = Pe.origHeight) : (V = Pe.width, re = Pe.height);
                let Ve = new Uint8Array(m.getImageTranscodedSizeInBytes(q, ve, 0, S));
                const K = m.transcodeImage(Ve, q, ve, Y, S, 0, -1, -1);
                if (P === n.HalfFloatType && (Ve = new Uint16Array(Ve.buffer, Ve.byteOffset, Ve.byteLength / Uint16Array.BYTES_PER_ELEMENT)), !K) throw g(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                Z.push(Ve);
              }
              const he = f(Z);
              te.push({
                data: he,
                width: V,
                height: re
              }), H.push(he.buffer);
            }
            j.push({
              mipmaps: te,
              width: x,
              height: b,
              format: E,
              type: P
            });
          }
          return g(), {
            faces: j,
            buffers: H,
            width: x,
            height: b,
            hasAlpha: R,
            dfdFlags: D,
            format: E,
            type: P
          };
        }
        const l = [
          {
            if: "astcSupported",
            basisFormat: [
              a.UASTC
            ],
            transcoderFormat: [
              r.ASTC_4x4,
              r.ASTC_4x4
            ],
            engineFormat: [
              i.RGBA_ASTC_4x4_Format,
              i.RGBA_ASTC_4x4_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 1 / 0,
            priorityUASTC: 1,
            needsPowerOfTwo: false
          },
          {
            if: "bptcSupported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.BC7_M5,
              r.BC7_M5
            ],
            engineFormat: [
              i.RGBA_BPTC_Format,
              i.RGBA_BPTC_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 3,
            priorityUASTC: 2,
            needsPowerOfTwo: false
          },
          {
            if: "dxtSupported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.BC1,
              r.BC3
            ],
            engineFormat: [
              i.RGBA_S3TC_DXT1_Format,
              i.RGBA_S3TC_DXT5_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 4,
            priorityUASTC: 5,
            needsPowerOfTwo: false
          },
          {
            if: "etc2Supported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.ETC1,
              r.ETC2
            ],
            engineFormat: [
              i.RGB_ETC2_Format,
              i.RGBA_ETC2_EAC_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 1,
            priorityUASTC: 3,
            needsPowerOfTwo: false
          },
          {
            if: "etc1Supported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.ETC1
            ],
            engineFormat: [
              i.RGB_ETC1_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 2,
            priorityUASTC: 4,
            needsPowerOfTwo: false
          },
          {
            if: "pvrtcSupported",
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.PVRTC1_4_RGB,
              r.PVRTC1_4_RGBA
            ],
            engineFormat: [
              i.RGB_PVRTC_4BPPV1_Format,
              i.RGBA_PVRTC_4BPPV1_Format
            ],
            engineType: [
              n.UnsignedByteType
            ],
            priorityETC1S: 5,
            priorityUASTC: 6,
            needsPowerOfTwo: true
          },
          {
            if: "bptcSupported",
            basisFormat: [
              a.UASTC_HDR
            ],
            transcoderFormat: [
              r.BC6H
            ],
            engineFormat: [
              i.RGB_BPTC_UNSIGNED_Format
            ],
            engineType: [
              n.HalfFloatType
            ],
            priorityHDR: 1,
            needsPowerOfTwo: false
          },
          {
            basisFormat: [
              a.ETC1S,
              a.UASTC
            ],
            transcoderFormat: [
              r.RGBA32,
              r.RGBA32
            ],
            engineFormat: [
              i.RGBAFormat,
              i.RGBAFormat
            ],
            engineType: [
              n.UnsignedByteType,
              n.UnsignedByteType
            ],
            priorityETC1S: 100,
            priorityUASTC: 100,
            needsPowerOfTwo: false
          },
          {
            basisFormat: [
              a.UASTC_HDR
            ],
            transcoderFormat: [
              r.RGBA_HALF
            ],
            engineFormat: [
              i.RGBAFormat
            ],
            engineType: [
              n.HalfFloatType
            ],
            priorityHDR: 100,
            needsPowerOfTwo: false
          }
        ], h = {
          [a.ETC1S]: l.filter((p) => p.basisFormat.includes(a.ETC1S)).sort((p, m) => p.priorityUASTC - m.priorityUASTC),
          [a.UASTC]: l.filter((p) => p.basisFormat.includes(a.UASTC)).sort((p, m) => p.priorityUASTC - m.priorityUASTC),
          [a.UASTC_HDR]: l.filter((p) => p.basisFormat.includes(a.UASTC_HDR)).sort((p, m) => p.priorityHDR - m.priorityHDR)
        };
        function d(p, m, g, A) {
          const x = h[p];
          for (let b = 0; b < x.length; b++) {
            const y = x[b];
            if (y.if && !s[y.if] || !y.basisFormat.includes(p) || A && y.transcoderFormat.length < 2 || y.needsPowerOfTwo && !(u(m) && u(g))) continue;
            const I = y.transcoderFormat[A ? 1 : 0], M = y.engineFormat[A ? 1 : 0], R = y.engineType[0];
            return {
              transcoderFormat: I,
              engineFormat: M,
              engineType: R
            };
          }
          throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.");
        }
        function u(p) {
          return p <= 2 ? true : (p & p - 1) === 0 && p !== 0;
        }
        function f(p) {
          if (p.length === 1) return p[0];
          let m = 0;
          for (let x = 0; x < p.length; x++) {
            const b = p[x];
            m += b.byteLength;
          }
          const g = new Uint8Array(m);
          let A = 0;
          for (let x = 0; x < p.length; x++) {
            const b = p[x];
            g.set(b, A), A += b.byteLength;
          }
          return g;
        }
      };
      const uP = /* @__PURE__ */ new Set([
        Wt,
        hr,
        yn
      ]), rl = {
        [DA]: Wt,
        [TA]: Wt,
        [SA]: Wt,
        [CA]: Wt,
        [BA]: hr,
        [MA]: hr,
        [EA]: hr,
        [vA]: hr,
        [RA]: yn,
        [IA]: yn,
        [xA]: yn,
        [yA]: yn,
        [ud]: Gs,
        [LA]: Hs,
        [PA]: Hs
      }, sl = {
        [DA]: ii,
        [TA]: vi,
        [SA]: Jt,
        [CA]: Jt,
        [BA]: ii,
        [MA]: vi,
        [EA]: Jt,
        [vA]: Jt,
        [RA]: ii,
        [IA]: vi,
        [xA]: Jt,
        [yA]: Jt,
        [ud]: vi,
        [LA]: Jt,
        [PA]: Jt
      };
      async function fP(s) {
        const { vkFormat: e } = s;
        if (rl[e] === void 0) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        let t;
        s.supercompressionScheme === Mf && (nl || (nl = new Promise(async (r) => {
          const a = new lP();
          await a.init(), r(a);
        })), t = await nl);
        const i = [];
        for (let r = 0; r < s.levels.length; r++) {
          const a = Math.max(1, s.pixelWidth >> r), o = Math.max(1, s.pixelHeight >> r), c = s.pixelDepth ? Math.max(1, s.pixelDepth >> r) : 0, l = s.levels[r];
          let h;
          if (s.supercompressionScheme === tP) h = l.levelData;
          else if (s.supercompressionScheme === Mf) h = t.decode(l.levelData, l.uncompressedByteLength);
          else throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
          let d;
          sl[e] === ii ? d = new Float32Array(h.buffer, h.byteOffset, h.byteLength / Float32Array.BYTES_PER_ELEMENT) : sl[e] === vi ? d = new Uint16Array(h.buffer, h.byteOffset, h.byteLength / Uint16Array.BYTES_PER_ELEMENT) : d = h, i.push({
            data: d,
            width: a,
            height: o,
            depth: c
          });
        }
        let n;
        if (uP.has(rl[e])) n = s.pixelDepth === 0 ? new sa(i[0].data, s.pixelWidth, s.pixelHeight) : new ep(i[0].data, s.pixelWidth, s.pixelHeight, s.pixelDepth);
        else {
          if (s.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
          n = new No(i, s.pixelWidth, s.pixelHeight), n.minFilter = i.length === 1 ? Rt : Ji, n.magFilter = Rt;
        }
        return n.mipmaps = i, n.type = sl[e], n.format = rl[e], n.colorSpace = FA(s), n.needsUpdate = true, Promise.resolve(n);
      }
      function FA(s) {
        const e = s.dataFormatDescriptor[0];
        return e.colorPrimaries === rP ? e.transferFunction === Tf ? nt : oi : e.colorPrimaries === sP ? e.transferFunction === Tf ? hP : dP : (e.colorPrimaries === nP || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${e.colorPrimaries}"`), an);
      }
      var pP = function() {
        var s = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", e = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb", t = new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          4,
          1,
          96,
          0,
          0,
          3,
          3,
          2,
          0,
          0,
          5,
          3,
          1,
          0,
          1,
          12,
          1,
          0,
          10,
          22,
          2,
          12,
          0,
          65,
          0,
          65,
          0,
          65,
          0,
          252,
          10,
          0,
          0,
          11,
          7,
          0,
          65,
          0,
          253,
          15,
          26,
          11
        ]), i = new Uint8Array([
          32,
          0,
          65,
          2,
          1,
          106,
          34,
          33,
          3,
          128,
          11,
          4,
          13,
          64,
          6,
          253,
          10,
          7,
          15,
          116,
          127,
          5,
          8,
          12,
          40,
          16,
          19,
          54,
          20,
          9,
          27,
          255,
          113,
          17,
          42,
          67,
          24,
          23,
          146,
          148,
          18,
          14,
          22,
          45,
          70,
          69,
          56,
          114,
          101,
          21,
          25,
          63,
          75,
          136,
          108,
          28,
          118,
          29,
          73,
          115
        ]);
        if (typeof WebAssembly != "object") return {
          supported: false
        };
        var n = WebAssembly.validate(t) ? e : s, r, a = WebAssembly.instantiate(o(n), {}).then(function(A) {
          r = A.instance, r.exports.__wasm_call_ctors();
        });
        function o(A) {
          for (var x = new Uint8Array(A.length), b = 0; b < A.length; ++b) {
            var y = A.charCodeAt(b);
            x[b] = y > 96 ? y - 97 : y > 64 ? y - 39 : y + 4;
          }
          for (var I = 0, b = 0; b < A.length; ++b) x[I++] = x[b] < 60 ? i[x[b]] : (x[b] - 60) * 64 + x[++b];
          return x.buffer.slice(0, I);
        }
        function c(A, x, b, y, I, M) {
          var R = r.exports.sbrk, D = b + 3 & -4, S = R(D * y), E = R(I.length), P = new Uint8Array(r.exports.memory.buffer);
          P.set(I, E);
          var j = A(S, b, y, E, I.length);
          if (j == 0 && M && M(S, D, y), x.set(P.subarray(S, S + b * y)), R(S - R(0)), j != 0) throw new Error("Malformed buffer data: " + j);
        }
        var l = {
          NONE: "",
          OCTAHEDRAL: "meshopt_decodeFilterOct",
          QUATERNION: "meshopt_decodeFilterQuat",
          EXPONENTIAL: "meshopt_decodeFilterExp"
        }, h = {
          ATTRIBUTES: "meshopt_decodeVertexBuffer",
          TRIANGLES: "meshopt_decodeIndexBuffer",
          INDICES: "meshopt_decodeIndexSequence"
        }, d = [], u = 0;
        function f(A) {
          var x = {
            object: new Worker(A),
            pending: 0,
            requests: {}
          };
          return x.object.onmessage = function(b) {
            var y = b.data;
            x.pending -= y.count, x.requests[y.id][y.action](y.value), delete x.requests[y.id];
          }, x;
        }
        function p(A) {
          for (var x = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(n)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + c.toString() + g.toString(), b = new Blob([
            x
          ], {
            type: "text/javascript"
          }), y = URL.createObjectURL(b), I = 0; I < A; ++I) d[I] = f(y);
          URL.revokeObjectURL(y);
        }
        function m(A, x, b, y, I) {
          for (var M = d[0], R = 1; R < d.length; ++R) d[R].pending < M.pending && (M = d[R]);
          return new Promise(function(D, S) {
            var E = new Uint8Array(b), P = u++;
            M.pending += A, M.requests[P] = {
              resolve: D,
              reject: S
            }, M.object.postMessage({
              id: P,
              count: A,
              size: x,
              source: E,
              mode: y,
              filter: I
            }, [
              E.buffer
            ]);
          });
        }
        function g(A) {
          a.then(function() {
            var x = A.data;
            try {
              var b = new Uint8Array(x.count * x.size);
              c(r.exports[x.mode], b, x.count, x.size, x.source, r.exports[x.filter]), self.postMessage({
                id: x.id,
                count: x.count,
                action: "resolve",
                value: b
              }, [
                b.buffer
              ]);
            } catch (y) {
              self.postMessage({
                id: x.id,
                count: x.count,
                action: "reject",
                value: y
              });
            }
          });
        }
        return {
          ready: a,
          supported: true,
          useWorkers: function(A) {
            p(A);
          },
          decodeVertexBuffer: function(A, x, b, y, I) {
            c(r.exports.meshopt_decodeVertexBuffer, A, x, b, y, r.exports[l[I]]);
          },
          decodeIndexBuffer: function(A, x, b, y) {
            c(r.exports.meshopt_decodeIndexBuffer, A, x, b, y);
          },
          decodeIndexSequence: function(A, x, b, y) {
            c(r.exports.meshopt_decodeIndexSequence, A, x, b, y);
          },
          decodeGltfBuffer: function(A, x, b, y, I, M) {
            c(r.exports[h[I]], A, x, b, y, r.exports[l[M]]);
          },
          decodeGltfBufferAsync: function(A, x, b, y, I) {
            return d.length > 0 ? m(A, x, b, h[y], l[I]) : a.then(function() {
              var M = new Uint8Array(A * x);
              return c(r.exports[h[y]], M, A, x, b, r.exports[l[I]]), M;
            });
          }
        };
      }();
      const AP = async (s, e, t) => new Promise((i, n) => {
        s.load("./map/map.glb", (r) => {
          const a = r.scene;
          a.scale.set(vn.x, vn.y, vn.z), a.translateY(0), a._forShadersModifiable = true, a.traverse((o) => {
            o.isMesh && (o.receiveShadow = true, o.castShadow = true);
          }), t && e.add(a), i(a);
        }, void 0, (r) => {
          console.error("Error loading terrain:", r), n(r);
        });
      }), Ms = /* @__PURE__ */ (() => {
        let s = null, e = null;
        return async (t, i, n, r, a, o = {
          x: 0,
          y: 0,
          z: 0
        }, c = {
          x: vn.x,
          y: vn.y,
          z: vn.z
        }, l = {
          x: 0,
          y: 0,
          z: 0
        }, h = "") => new Promise((d, u) => {
          s || (s = new mA(t), e = new Di(), e.setTranscoderPath("https://unpkg.com/three@0.150.1/examples/jsm/libs/basis/"), e.detectSupport(i), s.setKTX2Loader(e), s.setMeshoptDecoder(pP)), s.load(r, (f) => {
            const p = f.scene;
            p.position.set(o.x, o.y, o.z), p.scale.set(c.x, c.y, c.z), p.rotateX(l.x), p.rotateY(l.y), p.rotateZ(l.z), p._forShadersModifiable = true, h && (p.name = h), p.traverse((m) => {
              m.isMesh && (m.receiveShadow = true, m.castShadow = true);
            }), n && a.add(p), d(p);
          }, void 0, (f) => {
            console.error("Error loading terrain:", f), u(f);
          });
        });
      })();
      class gP {
        constructor(e, t, i, n, r, a) {
          this.shaders = a, this.worldPhysics = r, this.mapScaleFactor = {
            x: 1,
            y: 1,
            z: 1
          }, this.renderer = t, this.loadingManager = i, this.scene = e, this.toRadian = as, this.terrain = n, this.objectsTypesSrc = [
            {
              type: "tree1",
              src: "./models/trees/scene_c1.glb"
            },
            {
              type: "tree2",
              src: "./models/trees/scene_c2.glb"
            },
            {
              type: "tree3",
              src: "./models/trees/scene_c3.glb"
            },
            {
              type: "tree4",
              src: "./models/trees/scene_c4.glb"
            },
            {
              type: "tree5",
              src: "./models/trees/scene_c5.glb"
            },
            {
              type: "tree6",
              src: "./models/trees/scene_c6.glb"
            },
            {
              type: "tree7",
              src: "./models/trees/scene_c7.glb"
            },
            {
              type: "tree8",
              src: "./models/trees/scene_c8.glb"
            },
            {
              type: "tree9",
              src: "./models/trees/scene_c9.glb"
            },
            {
              type: "tree10",
              src: "./models/trees/scene_c10.glb"
            },
            {
              type: "rottenTree1",
              src: "./models/trees/scene_c11.glb"
            },
            {
              type: "stump1",
              src: "./models/trees/scene_c12.glb"
            },
            {
              type: "stone1",
              src: "./models/trees/scene_c13.glb"
            }
          ], this.vegetationGroup = new Li(), this.vegetationGroup.name = "vegetation", this.loadedModels = {}, this.heightData = null, this.sizeX = 0, this.sizeZ = 0, this.minX = 0, this.minZ = 0, this.maxX = 0, this.maxZ = 0, this.maskData = null, this.scene.add(this.vegetationGroup), this.colliderBuilder = new JD(this.worldPhysics), this.vegetationShaderModifiers = new ZD(this.vegetationGroup, this.shaders);
        }
        async preloadModels(e) {
          const t = this.objectsTypesSrc.map(({ type: i, src: n }) => Ms(this.loadingManager, this.renderer, false, n, this.scene).then((r) => {
            this.loadedModels[i] = r;
          }).catch((r) => (console.error(`Error loading model ${i}:`, r), null)));
          await Promise.allSettled(t), e();
        }
        addObject(e = {
          x: 0,
          y: 0,
          z: 0
        }, t = 1, i = {
          x: 0,
          y: 0,
          z: 0
        }, n) {
          const r = this.loadedModels[n];
          if (!r) {
            console.warn(`Model ${n} not loaded yet!`);
            return;
          }
          const a = r.clone();
          a.position.set(e.x, e.y, e.z), a.scale.set(t, t, t), a.rotation.set(i.x, i.y, i.z), a.layers.enable(Object.keys(this.loadedModels).indexOf(n) % 32), a.traverse((o) => {
            o.isMesh && (o.receiveShadow = true, o.castShadow = true);
          }), this.vegetationGroup.add(a);
        }
        async setVegetation() {
          let e = 200;
          const t = 640, i = 30, n = 1, r = 0, a = 0.5;
          await this.setVegetationAreas(), await this.createHeightsTexture();
          for (let o = 0; o < e; o++) {
            const c = this.objectsTypesSrc[Math.floor(Math.random() * this.objectsTypesSrc.length)].type, l = Ut.randFloatSpread(t * 2), h = Ut.randFloatSpread(t * 2) / n + r;
            if (this._sampleVegetationMask(l, h) < a) {
              o--;
              continue;
            }
            const u = this.getHeightAt(l, h), f = this.toRadian(Math.random() * 360);
            let p = (Math.random() + 0.5) * i;
            c === "stone1" && (p /= 5), this.colliderBuilder.createVegetationCollider({
              x: l,
              y: u,
              z: h
            }, p * 0.5, {
              w: 1,
              x: 0,
              y: f,
              z: 0
            }, c), this.addObject({
              x: l,
              y: u,
              z: h
            }, p, {
              x: 0,
              y: f,
              z: 0
            }, c);
          }
          this.vegetationShaderModifiers.modify();
        }
        getTerrainMesh() {
          if (!this.terrain) throw new Error("No mesh found");
          if (this.terrainMesh = this.terrain.getObjectByName("Plane"), !this.terrainMesh) throw new Error("\u274C Terrain 'Plane' not found!");
          let e = [];
          if (this.terrainMesh.type === "Mesh" ? e.push(this.terrainMesh) : e = this.terrainMesh.children.filter((r) => r.isMesh), e.length === 0) throw new Error("\u274C No meshes found inside 'Plane'!");
          const t = e.map((r) => {
            const a = r.geometry.clone().applyMatrix4(r.matrixWorld);
            return a.scale(this.mapScaleFactor.x, this.mapScaleFactor.y, this.mapScaleFactor.z), a;
          }), i = Gh(t, false);
          if (!i) throw new Error("\u274C Terrain mesh not found!");
          return new yt(i, new Ei({
            color: 65280
          }));
        }
        async _extractHeightData() {
          let e;
          try {
            e = this.getTerrainMesh();
          } catch (p) {
            return console.error(p.message), null;
          }
          const i = e.geometry.attributes.position.array, n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set();
          for (let p = 0; p < i.length; p += 3) n.add(i[p]), r.add(i[p + 2]);
          const a = 100, o = 100, c = Math.min(...n), l = Math.max(...n), h = Math.min(...r), d = Math.max(...r), u = new Float32Array(a * o), f = new Float32Array(a * o).fill(0);
          for (let p = 0; p < i.length; p += 3) {
            const m = i[p], g = i[p + 2], A = i[p + 1], x = (m - c) / (l - c) || 1, b = (g - h) / (d - h) || 1, y = Math.floor(x * (a - 1)), M = Math.floor(b * (o - 1)) * a + y;
            u[M] += A, f[M] += 1;
          }
          for (let p = 0; p < u.length; p++) f[p] > 0 && (u[p] /= f[p]);
          return {
            heightData: u,
            sizeX: a,
            sizeZ: o,
            minX: c,
            minZ: h,
            maxX: l,
            maxZ: d
          };
        }
        async createHeightsTexture() {
          const e = await this._extractHeightData();
          if (!e) return console.error("Failed to extract height data!"), null;
          const { heightData: t, sizeX: i, sizeZ: n, minX: r, minZ: a, maxX: o, maxZ: c } = e;
          return this.heightData = t, this.sizeX = i, this.sizeZ = n, this.minX = r, this.minZ = a, this.maxX = o, this.maxZ = c, e;
        }
        getHeightAt(e, t) {
          const i = Math.floor((e - this.minX) / (this.maxX - this.minX) * (this.sizeX - 1)), n = Math.floor((t - this.minZ) / (this.maxZ - this.minZ) * (this.sizeZ - 1)), r = Math.max(0, Math.min(this.sizeX - 1, i)), o = Math.max(0, Math.min(this.sizeZ - 1, n)) * this.sizeX + r;
          return this.heightData[o] || 0;
        }
        _precomputeVegetationMask() {
          if (!this.vegMask) {
            console.warn("Vegetation mask not loaded!");
            return;
          }
          const e = document.createElement("canvas"), t = e.getContext("2d");
          e.width = this.vegMask.image.width, e.height = this.vegMask.image.height, t.drawImage(this.vegMask.image, 0, 0), this.maskData = new Uint8Array(e.width * e.height);
          const i = t.getImageData(0, 0, e.width, e.height).data;
          for (let n = 0; n < i.length; n += 4) {
            const r = n / 4;
            this.maskData[r] = i[n];
          }
        }
        _sampleVegetationMask(e, t) {
          if (this.maskData === null && this._precomputeVegetationMask(), !this.maskData) return console.warn("Vegetation mask not loaded!"), 1;
          let i = (e - this.minX) / (this.maxX - this.minX), n = (t - this.minZ) / (this.maxZ - this.minZ);
          i = Math.min(Math.max(i, 0), 1), n = Math.min(Math.max(n, 0), 1);
          const r = Math.floor(i * this.vegMask.image.width), o = Math.floor(n * this.vegMask.image.height) * this.vegMask.image.width + r;
          return this.maskData[o] / 255;
        }
        async setVegetationAreas() {
          return new Promise((e, t) => {
            this.vegMask = new Si().load("./map/vegetation_map.jpeg", (i) => {
              console.log("Vegetation mask loaded successfully!"), this.vegMask = i, this.vegMask.wrapS = this.vegMask.wrapT = fi, this.vegMask.minFilter = Rt, this.vegMask.magFilter = Rt, e(this.vegMask);
            }, void 0, (i) => {
              console.error("Failed to load vegetation mask:", i);
            });
          });
        }
      }
      function _P(s) {
        return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
      }
      var co = {
        exports: {}
      }, mP = co.exports, Df;
      function wP() {
        return Df || (Df = 1, function(s, e) {
          (function(t, i) {
            s.exports = i();
          })(mP, function() {
            var t = function() {
              function i(f) {
                return a.appendChild(f.dom), f;
              }
              function n(f) {
                for (var p = 0; p < a.children.length; p++) a.children[p].style.display = p === f ? "block" : "none";
                r = f;
              }
              var r = 0, a = document.createElement("div");
              a.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", a.addEventListener("click", function(f) {
                f.preventDefault(), n(++r % a.children.length);
              }, false);
              var o = (performance || Date).now(), c = o, l = 0, h = i(new t.Panel("FPS", "#0ff", "#002")), d = i(new t.Panel("MS", "#0f0", "#020"));
              if (self.performance && self.performance.memory) var u = i(new t.Panel("MB", "#f08", "#201"));
              return n(0), {
                REVISION: 16,
                dom: a,
                addPanel: i,
                showPanel: n,
                begin: function() {
                  o = (performance || Date).now();
                },
                end: function() {
                  l++;
                  var f = (performance || Date).now();
                  if (d.update(f - o, 200), f > c + 1e3 && (h.update(1e3 * l / (f - c), 100), c = f, l = 0, u)) {
                    var p = performance.memory;
                    u.update(p.usedJSHeapSize / 1048576, p.jsHeapSizeLimit / 1048576);
                  }
                  return f;
                },
                update: function() {
                  o = this.end();
                },
                domElement: a,
                setMode: n
              };
            };
            return t.Panel = function(i, n, r) {
              var a = 1 / 0, o = 0, c = Math.round, l = c(window.devicePixelRatio || 1), h = 80 * l, d = 48 * l, u = 3 * l, f = 2 * l, p = 3 * l, m = 15 * l, g = 74 * l, A = 30 * l, x = document.createElement("canvas");
              x.width = h, x.height = d, x.style.cssText = "width:80px;height:48px";
              var b = x.getContext("2d");
              return b.font = "bold " + 9 * l + "px Helvetica,Arial,sans-serif", b.textBaseline = "top", b.fillStyle = r, b.fillRect(0, 0, h, d), b.fillStyle = n, b.fillText(i, u, f), b.fillRect(p, m, g, A), b.fillStyle = r, b.globalAlpha = 0.9, b.fillRect(p, m, g, A), {
                dom: x,
                update: function(y, I) {
                  a = Math.min(a, y), o = Math.max(o, y), b.fillStyle = r, b.globalAlpha = 1, b.fillRect(0, 0, h, m), b.fillStyle = n, b.fillText(c(y) + " " + i + " (" + c(a) + "-" + c(o) + ")", u, f), b.drawImage(x, p + l, m, g - l, A, p, m, g - l, A), b.fillRect(p + g - l, m, l, A), b.fillStyle = r, b.globalAlpha = 0.9, b.fillRect(p + g - l, m, l, c((1 - y / I) * A));
                }
              };
            }, t;
          });
        }(co)), co.exports;
      }
      var bP = wP();
      const yP = _P(bP);
      class xP {
        constructor() {
          this.stats = new yP(), this.stats.showPanel(0), document.body.appendChild(this.stats.dom);
        }
      }
      function EP({ x: s = 0, y: e = 0, z: t = 0 } = {}) {
        const i = (h) => h * Math.PI / 180, n = Math.cos(i(s) / 2), r = Math.sin(i(s) / 2), a = Math.cos(i(e) / 2), o = Math.sin(i(e) / 2), c = Math.cos(i(t) / 2), l = Math.sin(i(t) / 2);
        return {
          w: n * a * c + r * o * l,
          x: r * a * c - n * o * l,
          y: n * o * c + r * a * l,
          z: n * a * l - r * o * c
        };
      }
      class vP {
        constructor(e) {
          this.worldPhysics = e;
        }
        toRadian(e) {
          return THREE.MathUtils.degToRad(e);
        }
        createColliders(e = []) {
          if (!Array.isArray(e)) throw Error("Colliders data must be an array.");
          return this._setColliders(e);
        }
        _setColliders(e) {
          return e.forEach(({ name: t, positions: i, dimensions: n, rotations: r, figure: a, group: o }) => {
            const c = EP(r);
            this._initCollider(i, c, n, a, t, o);
          }), true;
        }
        _initCollider(e = {
          x: 0,
          y: 0,
          z: 0
        }, t = {
          w: 1,
          x: 0,
          y: 0,
          z: 0
        }, i = {
          x: 0,
          y: 0,
          z: 0
        }, n = "cylinder", r = "unknown", a = "") {
          let o;
          switch (n) {
            case "ball":
              o = en.ColliderDesc.ball(i.x * 0.6);
              break;
            case "cylinder":
              o = en.ColliderDesc.cylinder(i.y, i.x);
              break;
            case "cuboid":
              o = en.ColliderDesc.cuboid(i.x, i.y, i.z);
              break;
            default:
              throw new Error(`Unsupported collider type: ${n}`);
          }
          o.setTranslation(e.x, e.y, e.z), o.setRotation(t);
          const c = this.worldPhysics.createCollider(o);
          return c.userData = {
            name: r,
            group: a
          }, c;
        }
      }
      const kA = [
        {
          name: "profile",
          positions: {
            x: -185,
            y: 20,
            z: 94
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "credits",
          positions: {
            x: -54,
            y: 20,
            z: 335
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "hobbies",
          positions: {
            x: 284,
            y: 6,
            z: 176
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "history",
          positions: {
            x: 148,
            y: 28,
            z: 37
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "skills",
          positions: {
            x: 198,
            y: 13,
            z: -64
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "contacts",
          positions: {
            x: -165,
            y: 26,
            z: -260
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "portfolio",
          positions: {
            x: -45,
            y: 18,
            z: -83
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "markers"
        },
        {
          name: "magic bridge",
          positions: {
            x: -59,
            y: 15,
            z: 20
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "wind mill",
          positions: {
            x: 40,
            y: 10,
            z: 249
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "book stand",
          positions: {
            x: 128,
            y: 16,
            z: 64
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "dead end",
          positions: {
            x: 168,
            y: 30,
            z: -251
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "tavern",
          positions: {
            x: -31,
            y: 16,
            z: -195
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 1,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "pointers"
        },
        {
          name: "book stand",
          positions: {
            x: 156,
            y: 30,
            z: 45
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "book stand"
        },
        {
          name: "house box",
          positions: {
            x: 298,
            y: 36,
            z: -20
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 44,
            y: 30,
            z: 26
          },
          figure: "cuboid",
          group: "blacksmith"
        },
        {
          name: "tent",
          positions: {
            x: 284,
            y: 22,
            z: -155
          },
          rotations: {
            x: 0,
            y: 25,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 10,
            z: 17
          },
          figure: "cuboid",
          group: "blacksmith"
        },
        {
          name: "tent",
          positions: {
            x: 250,
            y: 13,
            z: -175
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 2,
            z: 3
          },
          figure: "cuboid",
          group: "blacksmith"
        },
        {
          name: "anvils",
          positions: {
            x: 253,
            y: 10,
            z: -160
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "anvils",
          positions: {
            x: 278,
            y: 10,
            z: -65
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 298,
            y: 10,
            z: -65
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 2,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 321,
            y: 12,
            z: -60
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 320,
            y: 12,
            z: 0
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "bits",
          positions: {
            x: 251,
            y: 10,
            z: -20
          },
          rotations: {
            x: 0,
            y: 43,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "blacksmith"
        },
        {
          name: "house box",
          positions: {
            x: 346,
            y: 14,
            z: 248
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 14,
            z: 26
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 346,
            y: 3,
            z: 215
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 1,
            z: 8
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 325,
            y: 10,
            z: 207
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 17,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 358,
            y: 10,
            z: 207
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch front",
          positions: {
            x: 365,
            y: 10,
            z: 214
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 316,
            y: 3,
            z: 241
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 1,
            z: 35
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 290,
            y: -3,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 296,
            y: -1,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 301,
            y: 1,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 305,
            y: 2.5,
            z: 244
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 309,
            y: 10,
            z: 222
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 15
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 309,
            y: 10,
            z: 263
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 11
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 317,
            y: 10,
            z: 274
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 298,
            y: 6,
            z: 235
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 11,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 298,
            y: 6,
            z: 251
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 11,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 275,
            y: 0,
            z: 234
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 9,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 235,
            y: 0,
            z: 234
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 9,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 255,
            y: 0,
            z: 264
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 30,
            y: 5,
            z: 0.5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 285,
            y: 0,
            z: 257
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 5
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 265,
            y: 0,
            z: 220
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 13
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "porch sea side",
          positions: {
            x: 244,
            y: 0,
            z: 220
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 13
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "pier",
          positions: {
            x: 258,
            y: -6,
            z: 248
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 35,
            y: 1,
            z: 17
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "pier",
          positions: {
            x: 255,
            y: -6,
            z: 217
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 12,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "boat",
          positions: {
            x: 255,
            y: -10,
            z: 192
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 21,
            y: 1,
            z: 7
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "water tower",
          positions: {
            x: 305,
            y: 35,
            z: 140
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 20,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "well",
          positions: {
            x: 400,
            y: 15,
            z: 219
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 4,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "palms",
          positions: {
            x: 346,
            y: 15,
            z: 174
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 8,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "palms",
          positions: {
            x: 339,
            y: 15,
            z: 315
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 4,
            y: 8,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "barrels",
          positions: {
            x: 237.5,
            y: -1,
            z: 258
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "barrels",
          positions: {
            x: 271,
            y: -3,
            z: 258
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "barrels",
          positions: {
            x: 277,
            y: -2,
            z: 259.5
          },
          rotations: {
            x: 0,
            y: 0,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 3,
            z: 1
          },
          figure: "cylinder",
          group: "seaHouse"
        },
        {
          name: "rug",
          positions: {
            x: 315,
            y: 10,
            z: 309
          },
          rotations: {
            x: 0,
            y: 170,
            z: 0
          },
          dimensions: {
            x: 0.5,
            y: 5,
            z: 8
          },
          figure: "cuboid",
          group: "seaHouse"
        },
        {
          name: "tavern",
          positions: {
            x: -231,
            y: 40,
            z: -355
          },
          rotations: {
            x: 0,
            y: 80,
            z: 0
          },
          dimensions: {
            x: 36,
            y: 30,
            z: 24
          },
          figure: "cuboid",
          group: "tavern"
        },
        {
          name: "tavern",
          positions: {
            x: -264,
            y: 20,
            z: -350
          },
          rotations: {
            x: 0,
            y: 80,
            z: 0
          },
          dimensions: {
            x: 18,
            y: 8,
            z: 6
          },
          figure: "cuboid",
          group: "tavern"
        },
        {
          name: "wind mill",
          positions: {
            x: -160,
            y: 32,
            z: 377
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 20,
            z: 1
          },
          figure: "cylinder",
          group: "wind mill"
        },
        {
          name: "house",
          positions: {
            x: -258,
            y: 30,
            z: 5
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 42,
            y: 15,
            z: 20
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "porch",
          positions: {
            x: -258,
            y: 30,
            z: 55
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 15,
            z: 5
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "stumps",
          positions: {
            x: -284,
            y: 16,
            z: 52
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 4,
            z: 6
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "side house cylinder",
          positions: {
            x: -227,
            y: 30,
            z: 5
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 12,
            y: 20,
            z: 1
          },
          figure: "cylinder",
          group: "main house"
        },
        {
          name: "side house small cylinder",
          positions: {
            x: -196,
            y: 20,
            z: -22
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 7,
            y: 10,
            z: 1
          },
          figure: "cylinder",
          group: "main house"
        },
        {
          name: "side house small cylinder",
          positions: {
            x: -186,
            y: 17,
            z: 7
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 5,
            y: 4,
            z: 1
          },
          figure: "cylinder",
          group: "main house"
        },
        {
          name: "side house chair",
          positions: {
            x: -190,
            y: 14,
            z: 24
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 2,
            z: 2
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "side house chair",
          positions: {
            x: -216,
            y: 14,
            z: 24
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 2,
            z: 2
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "side house chair",
          positions: {
            x: -230,
            y: 20,
            z: 24
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 10,
            y: 10,
            z: 10
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "table set",
          positions: {
            x: -210,
            y: 15,
            z: 68
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 3,
            y: 2,
            z: 7
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "table set",
          positions: {
            x: -195,
            y: 13,
            z: 67
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 1,
            z: 5
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "table set",
          positions: {
            x: -215,
            y: 14,
            z: 77
          },
          rotations: {
            x: 0,
            y: 90,
            z: 0
          },
          dimensions: {
            x: 2,
            y: 2,
            z: 2
          },
          figure: "cuboid",
          group: "main house"
        },
        {
          name: "board",
          positions: {
            x: -75,
            y: 28,
            z: -66
          },
          rotations: {
            x: 0,
            y: 85,
            z: 0
          },
          dimensions: {
            x: 15,
            y: 15,
            z: 1
          },
          figure: "cuboid",
          group: "board"
        },
        {
          name: "layer",
          positions: {
            x: 41,
            y: 0,
            z: 60
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 22,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: -19,
            y: 0,
            z: 40
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 24,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: -15,
            y: 2,
            z: 41
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 41,
            y: 2,
            z: 60
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 17,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 4,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 44,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 6,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 41,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 8,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 38,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 12,
            y: 10,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 34,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 12,
            y: 12,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 29,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 12,
            y: 14,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 25,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "layer",
          positions: {
            x: 11,
            y: 16,
            z: 50
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 16,
            y: 1,
            z: 10
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 15,
            y: 24,
            z: 42
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 42,
            y: 16,
            z: 51
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: -12,
            y: 16,
            z: 33
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 12,
            y: 24,
            z: 61
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 8,
            y: 5,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: 39,
            y: 16,
            z: 71
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "wall",
          positions: {
            x: -15,
            y: 16,
            z: 52
          },
          rotations: {
            x: 0,
            y: 341,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 10,
            z: 1
          },
          figure: "cuboid",
          group: "magic bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: 3,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 15,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: 1,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 25,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: -1,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 35,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "bottom bridge",
          positions: {
            x: 187,
            y: -4,
            z: 170
          },
          rotations: {
            x: 0,
            y: 59,
            z: 354
          },
          dimensions: {
            x: 50,
            y: 1,
            z: 14
          },
          figure: "cuboid",
          group: "bottom bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 11,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 7,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 9,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 15,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 7,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 20,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 77,
            y: 5,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 28,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 76,
            y: 3,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 33,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 78,
            y: 1,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 36,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "layer",
          positions: {
            x: 80,
            y: -3,
            z: -248
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 40,
            y: 1,
            z: 23
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "wall",
          positions: {
            x: 75,
            y: 0,
            z: -270
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 42,
            y: 20,
            z: 1
          },
          figure: "cuboid",
          group: "top bridge"
        },
        {
          name: "wall",
          positions: {
            x: 83,
            y: 0,
            z: -227
          },
          rotations: {
            x: 0,
            y: 10,
            z: 0
          },
          dimensions: {
            x: 42,
            y: 20,
            z: 1
          },
          figure: "cuboid",
          group: "top bridge"
        }
      ];
      class SP {
        constructor(e) {
          if (this.markerModalContainer = document.getElementById("modal-marker-cont"), !this.markerModalContainer) {
            console.error("Modal container #modal-marker-cont not found!");
            return;
          }
          this._initModalMarker(), this.markersDistanceHandler = e, this.markersDistanceHandler.modalMarker = this, this.activeMarker = null;
        }
        _initModalMarker() {
          this.modal = document.createElement("div"), this.modal.className = "modal-marker", this.markerModalContainer.append(this.modal);
        }
        updateMarkerModalStatus() {
          this.markersDistanceHandler.activeMarker && this.markersDistanceHandler.activeMarker !== this.activeMarker && (this.activeMarker = this.markersDistanceHandler.activeMarker, this.modal.innerHTML = `
                press <kbd>space</kbd> to read <strong> ${this.activeMarker.name}</strong>
            `, this.modal.classList.add("show-marker-modal")), !this.markersDistanceHandler.activeMarker && this.activeMarker && (this.activeMarker = null, this.modal.classList.remove("show-marker-modal"));
        }
      }
      class CP {
        constructor(e) {
          this.markers = (kA || []).filter((t) => t.group === "markers").map((t) => {
            var _a2, _b2, _c2;
            return {
              vec: new T(((_a2 = t.positions) == null ? void 0 : _a2.x) ?? 0, ((_b2 = t.positions) == null ? void 0 : _b2.y) ?? 0, ((_c2 = t.positions) == null ? void 0 : _c2.z) ?? 0),
              ...t
            };
          }), this.activeMarker = null, this.character = e, this.interactDistance = 30;
        }
        updateCharPositionDistance() {
          const e = this.character.mesh.position;
          this.activeMarker = this.markers.find((t) => e.distanceTo(t.vec) < this.interactDistance) || null;
        }
      }
      class IP {
        constructor(e, t, i) {
          if (this.audioPlayer = i, this.chapterModalContainer = document.getElementById("modal-chapter-cont"), !this.chapterModalContainer) {
            console.error("Modal container #modal-chapter-cont not found!");
            return;
          }
          this.chapterViewer = t, this.markersDistanceHandler = e, this.activeModalChapter = null, this._initModalChapter(), document.addEventListener("keydown", (n) => this.handleKeyPress(n));
        }
        _initModalChapter() {
          this.modal = this.chapterViewer.modal.firstElementChild, this.chapterViewer.closeButton.addEventListener("click", () => this.hideChapterModal());
        }
        updateChapterModalStatus() {
          const e = this.markersDistanceHandler.character.basicController._input._keys;
          this.markersDistanceHandler.activeMarker && !this.activeModalChapter && e.space && (this.showChapterModal(), e.space = false), this.activeModalChapter && (e.esc || e.space) && (this.hideChapterModal(), e.esc = false, e.space = false);
        }
        handleKeyPress(e) {
          this.markersDistanceHandler.activeMarker && !this.activeModalChapter && e.code === "Space" ? this.showChapterModal() : this.activeModalChapter && (e.code === "Escape" || e.code === "Space") && this.hideChapterModal();
        }
        showChapterModal() {
          const e = this.markersDistanceHandler.character.basicController._input;
          this.modal.classList.add("show-chapter-modal"), this.activeModalChapter = this.markersDistanceHandler.activeMarker, this.markersDistanceHandler.modalMarker.modal.classList.remove("show-marker-modal"), e.actionsAllowed = false, this.playOpenInventorySound(), this.chapterViewer.open();
        }
        hideChapterModal() {
          const e = this.markersDistanceHandler.character.basicController._input;
          this.modal.classList.remove("show-chapter-modal"), this.markersDistanceHandler.modalMarker.modal.classList.add("show-marker-modal"), this.activeModalChapter = null, e.actionsAllowed = true, this.playOpenInventorySound(), this.chapterViewer.close();
        }
        playOpenInventorySound() {
          this.audioPlayer && this.audioPlayer.playSound("./sounds/leather_inventory.wav");
        }
      }
      const Pf = {
        type: "change"
      }, fd = {
        type: "start"
      }, UA = {
        type: "end"
      }, eo = new os(), Lf = new Xi(), MP = Math.cos(70 * Ut.DEG2RAD), Gt = new T(), gi = 2 * Math.PI, gt = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      }, al = 1e-6;
      class NA extends cw {
        constructor(e, t = null) {
          super(e, t), this.state = gt.NONE, this.target = new T(), this.cursor = new T(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = false, this.dampingFactor = 0.05, this.enableZoom = true, this.zoomSpeed = 1, this.enableRotate = true, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = true, this.panSpeed = 1, this.screenSpacePanning = true, this.keyPanSpeed = 7, this.zoomToCursor = false, this.autoRotate = false, this.autoRotateSpeed = 2, this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
          }, this.mouseButtons = {
            LEFT: qr.ROTATE,
            MIDDLE: qr.DOLLY,
            RIGHT: qr.PAN
          }, this.touches = {
            ONE: Gr.ROTATE,
            TWO: Gr.DOLLY_PAN
          }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new T(), this._lastQuaternion = new At(), this._lastTargetPosition = new T(), this._quat = new At().setFromUnitVectors(e.up, new T(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new bu(), this._sphericalDelta = new bu(), this._scale = 1, this._panOffset = new T(), this._rotateStart = new oe(), this._rotateEnd = new oe(), this._rotateDelta = new oe(), this._panStart = new oe(), this._panEnd = new oe(), this._panDelta = new oe(), this._dollyStart = new oe(), this._dollyEnd = new oe(), this._dollyDelta = new oe(), this._dollyDirection = new T(), this._mouse = new oe(), this._performCursorZoom = false, this._pointers = [], this._pointerPositions = {}, this._controlActive = false, this._onPointerMove = RP.bind(this), this._onPointerDown = TP.bind(this), this._onPointerUp = BP.bind(this), this._onContextMenu = NP.bind(this), this._onMouseWheel = LP.bind(this), this._onKeyDown = FP.bind(this), this._onTouchStart = kP.bind(this), this._onTouchMove = UP.bind(this), this._onMouseDown = DP.bind(this), this._onMouseMove = PP.bind(this), this._interceptControlDown = QP.bind(this), this._interceptControlUp = OP.bind(this), this.domElement !== null && this.connect(this.domElement), this.update();
        }
        connect(e) {
          super.connect(e), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: false
          }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: true,
            capture: true
          }), this.domElement.style.touchAction = "none";
        }
        disconnect() {
          this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: true
          }), this.domElement.style.touchAction = "auto";
        }
        dispose() {
          this.disconnect();
        }
        getPolarAngle() {
          return this._spherical.phi;
        }
        getAzimuthalAngle() {
          return this._spherical.theta;
        }
        getDistance() {
          return this.object.position.distanceTo(this.target);
        }
        listenToKeyEvents(e) {
          e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
        }
        stopListenToKeyEvents() {
          this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
        }
        saveState() {
          this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
        }
        reset() {
          this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(Pf), this.update(), this.state = gt.NONE;
        }
        update(e = null) {
          const t = this.object.position;
          Gt.copy(t).sub(this.target), Gt.applyQuaternion(this._quat), this._spherical.setFromVector3(Gt), this.autoRotate && this.state === gt.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
          let i = this.minAzimuthAngle, n = this.maxAzimuthAngle;
          isFinite(i) && isFinite(n) && (i < -Math.PI ? i += gi : i > Math.PI && (i -= gi), n < -Math.PI ? n += gi : n > Math.PI && (n -= gi), i <= n ? this._spherical.theta = Math.max(i, Math.min(n, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (i + n) / 2 ? Math.max(i, this._spherical.theta) : Math.min(n, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === true ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
          let r = false;
          if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera) this._spherical.radius = this._clampDistance(this._spherical.radius);
          else {
            const a = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), r = a != this._spherical.radius;
          }
          if (Gt.setFromSpherical(this._spherical), Gt.applyQuaternion(this._quatInverse), t.copy(this.target).add(Gt), this.object.lookAt(this.target), this.enableDamping === true ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
            let a = null;
            if (this.object.isPerspectiveCamera) {
              const o = Gt.length();
              a = this._clampDistance(o * this._scale);
              const c = o - a;
              this.object.position.addScaledVector(this._dollyDirection, c), this.object.updateMatrixWorld(), r = !!c;
            } else if (this.object.isOrthographicCamera) {
              const o = new T(this._mouse.x, this._mouse.y, 0);
              o.unproject(this.object);
              const c = this.object.zoom;
              this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), r = c !== this.object.zoom;
              const l = new T(this._mouse.x, this._mouse.y, 0);
              l.unproject(this.object), this.object.position.sub(l).add(o), this.object.updateMatrixWorld(), a = Gt.length();
            } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = false;
            a !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(a).add(this.object.position) : (eo.origin.copy(this.object.position), eo.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(eo.direction)) < MP ? this.object.lookAt(this.target) : (Lf.setFromNormalAndCoplanarPoint(this.object.up, this.target), eo.intersectPlane(Lf, this.target))));
          } else if (this.object.isOrthographicCamera) {
            const a = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), a !== this.object.zoom && (this.object.updateProjectionMatrix(), r = true);
          }
          return this._scale = 1, this._performCursorZoom = false, r || this._lastPosition.distanceToSquared(this.object.position) > al || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > al || this._lastTargetPosition.distanceToSquared(this.target) > al ? (this.dispatchEvent(Pf), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), true) : false;
        }
        _getAutoRotationAngle(e) {
          return e !== null ? gi / 60 * this.autoRotateSpeed * e : gi / 60 / 60 * this.autoRotateSpeed;
        }
        _getZoomScale(e) {
          const t = Math.abs(e * 0.01);
          return Math.pow(0.95, this.zoomSpeed * t);
        }
        _rotateLeft(e) {
          this._sphericalDelta.theta -= e;
        }
        _rotateUp(e) {
          this._sphericalDelta.phi -= e;
        }
        _panLeft(e, t) {
          Gt.setFromMatrixColumn(t, 0), Gt.multiplyScalar(-e), this._panOffset.add(Gt);
        }
        _panUp(e, t) {
          this.screenSpacePanning === true ? Gt.setFromMatrixColumn(t, 1) : (Gt.setFromMatrixColumn(t, 0), Gt.crossVectors(this.object.up, Gt)), Gt.multiplyScalar(e), this._panOffset.add(Gt);
        }
        _pan(e, t) {
          const i = this.domElement;
          if (this.object.isPerspectiveCamera) {
            const n = this.object.position;
            Gt.copy(n).sub(this.target);
            let r = Gt.length();
            r *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * r / i.clientHeight, this.object.matrix), this._panUp(2 * t * r / i.clientHeight, this.object.matrix);
          } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / i.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / i.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = false);
        }
        _dollyOut(e) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _dollyIn(e) {
          this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = false);
        }
        _updateZoomParameters(e, t) {
          if (!this.zoomToCursor) return;
          this._performCursorZoom = true;
          const i = this.domElement.getBoundingClientRect(), n = e - i.left, r = t - i.top, a = i.width, o = i.height;
          this._mouse.x = n / a * 2 - 1, this._mouse.y = -(r / o) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
        }
        _clampDistance(e) {
          return Math.max(this.minDistance, Math.min(this.maxDistance, e));
        }
        _handleMouseDownRotate(e) {
          this._rotateStart.set(e.clientX, e.clientY);
        }
        _handleMouseDownDolly(e) {
          this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
        }
        _handleMouseDownPan(e) {
          this._panStart.set(e.clientX, e.clientY);
        }
        _handleMouseMoveRotate(e) {
          this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const t = this.domElement;
          this._rotateLeft(gi * this._rotateDelta.x / t.clientHeight), this._rotateUp(gi * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
        }
        _handleMouseMoveDolly(e) {
          this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
        }
        _handleMouseMovePan(e) {
          this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
        }
        _handleMouseWheel(e) {
          this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
        }
        _handleKeyDown(e) {
          let t = false;
          switch (e.code) {
            case this.keys.UP:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(gi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), t = true;
              break;
            case this.keys.BOTTOM:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-gi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), t = true;
              break;
            case this.keys.LEFT:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(gi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), t = true;
              break;
            case this.keys.RIGHT:
              e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-gi * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), t = true;
              break;
          }
          t && (e.preventDefault(), this.update());
        }
        _handleTouchStartRotate(e) {
          if (this._pointers.length === 1) this._rotateStart.set(e.pageX, e.pageY);
          else {
            const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
            this._rotateStart.set(i, n);
          }
        }
        _handleTouchStartPan(e) {
          if (this._pointers.length === 1) this._panStart.set(e.pageX, e.pageY);
          else {
            const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
            this._panStart.set(i, n);
          }
        }
        _handleTouchStartDolly(e) {
          const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
          this._dollyStart.set(0, r);
        }
        _handleTouchStartDollyPan(e) {
          this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
        }
        _handleTouchStartDollyRotate(e) {
          this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
        }
        _handleTouchMoveRotate(e) {
          if (this._pointers.length == 1) this._rotateEnd.set(e.pageX, e.pageY);
          else {
            const i = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + i.x), r = 0.5 * (e.pageY + i.y);
            this._rotateEnd.set(n, r);
          }
          this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
          const t = this.domElement;
          this._rotateLeft(gi * this._rotateDelta.x / t.clientHeight), this._rotateUp(gi * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
        }
        _handleTouchMovePan(e) {
          if (this._pointers.length === 1) this._panEnd.set(e.pageX, e.pageY);
          else {
            const t = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + t.x), n = 0.5 * (e.pageY + t.y);
            this._panEnd.set(i, n);
          }
          this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
        }
        _handleTouchMoveDolly(e) {
          const t = this._getSecondPointerPosition(e), i = e.pageX - t.x, n = e.pageY - t.y, r = Math.sqrt(i * i + n * n);
          this._dollyEnd.set(0, r), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
          const a = (e.pageX + t.x) * 0.5, o = (e.pageY + t.y) * 0.5;
          this._updateZoomParameters(a, o);
        }
        _handleTouchMoveDollyPan(e) {
          this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
        }
        _handleTouchMoveDollyRotate(e) {
          this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
        }
        _addPointer(e) {
          this._pointers.push(e.pointerId);
        }
        _removePointer(e) {
          delete this._pointerPositions[e.pointerId];
          for (let t = 0; t < this._pointers.length; t++) if (this._pointers[t] == e.pointerId) {
            this._pointers.splice(t, 1);
            return;
          }
        }
        _isTrackingPointer(e) {
          for (let t = 0; t < this._pointers.length; t++) if (this._pointers[t] == e.pointerId) return true;
          return false;
        }
        _trackPointer(e) {
          let t = this._pointerPositions[e.pointerId];
          t === void 0 && (t = new oe(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
        }
        _getSecondPointerPosition(e) {
          const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
          return this._pointerPositions[t];
        }
        _customWheelEvent(e) {
          const t = e.deltaMode, i = {
            clientX: e.clientX,
            clientY: e.clientY,
            deltaY: e.deltaY
          };
          switch (t) {
            case 1:
              i.deltaY *= 16;
              break;
            case 2:
              i.deltaY *= 100;
              break;
          }
          return e.ctrlKey && !this._controlActive && (i.deltaY *= 10), i;
        }
      }
      function TP(s) {
        this.enabled !== false && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(s) && (this._addPointer(s), s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s)));
      }
      function RP(s) {
        this.enabled !== false && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s));
      }
      function BP(s) {
        switch (this._removePointer(s), this._pointers.length) {
          case 0:
            this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(UA), this.state = gt.NONE;
            break;
          case 1:
            const e = this._pointers[0], t = this._pointerPositions[e];
            this._onTouchStart({
              pointerId: e,
              pageX: t.x,
              pageY: t.y
            });
            break;
        }
      }
      function DP(s) {
        let e;
        switch (s.button) {
          case 0:
            e = this.mouseButtons.LEFT;
            break;
          case 1:
            e = this.mouseButtons.MIDDLE;
            break;
          case 2:
            e = this.mouseButtons.RIGHT;
            break;
          default:
            e = -1;
        }
        switch (e) {
          case qr.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseDownDolly(s), this.state = gt.DOLLY;
            break;
          case qr.ROTATE:
            if (s.ctrlKey || s.metaKey || s.shiftKey) {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(s), this.state = gt.PAN;
            } else {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(s), this.state = gt.ROTATE;
            }
            break;
          case qr.PAN:
            if (s.ctrlKey || s.metaKey || s.shiftKey) {
              if (this.enableRotate === false) return;
              this._handleMouseDownRotate(s), this.state = gt.ROTATE;
            } else {
              if (this.enablePan === false) return;
              this._handleMouseDownPan(s), this.state = gt.PAN;
            }
            break;
          default:
            this.state = gt.NONE;
        }
        this.state !== gt.NONE && this.dispatchEvent(fd);
      }
      function PP(s) {
        switch (this.state) {
          case gt.ROTATE:
            if (this.enableRotate === false) return;
            this._handleMouseMoveRotate(s);
            break;
          case gt.DOLLY:
            if (this.enableZoom === false) return;
            this._handleMouseMoveDolly(s);
            break;
          case gt.PAN:
            if (this.enablePan === false) return;
            this._handleMouseMovePan(s);
            break;
        }
      }
      function LP(s) {
        this.enabled === false || this.enableZoom === false || this.state !== gt.NONE || (s.preventDefault(), this.dispatchEvent(fd), this._handleMouseWheel(this._customWheelEvent(s)), this.dispatchEvent(UA));
      }
      function FP(s) {
        this.enabled !== false && this._handleKeyDown(s);
      }
      function kP(s) {
        switch (this._trackPointer(s), this._pointers.length) {
          case 1:
            switch (this.touches.ONE) {
              case Gr.ROTATE:
                if (this.enableRotate === false) return;
                this._handleTouchStartRotate(s), this.state = gt.TOUCH_ROTATE;
                break;
              case Gr.PAN:
                if (this.enablePan === false) return;
                this._handleTouchStartPan(s), this.state = gt.TOUCH_PAN;
                break;
              default:
                this.state = gt.NONE;
            }
            break;
          case 2:
            switch (this.touches.TWO) {
              case Gr.DOLLY_PAN:
                if (this.enableZoom === false && this.enablePan === false) return;
                this._handleTouchStartDollyPan(s), this.state = gt.TOUCH_DOLLY_PAN;
                break;
              case Gr.DOLLY_ROTATE:
                if (this.enableZoom === false && this.enableRotate === false) return;
                this._handleTouchStartDollyRotate(s), this.state = gt.TOUCH_DOLLY_ROTATE;
                break;
              default:
                this.state = gt.NONE;
            }
            break;
          default:
            this.state = gt.NONE;
        }
        this.state !== gt.NONE && this.dispatchEvent(fd);
      }
      function UP(s) {
        switch (this._trackPointer(s), this.state) {
          case gt.TOUCH_ROTATE:
            if (this.enableRotate === false) return;
            this._handleTouchMoveRotate(s), this.update();
            break;
          case gt.TOUCH_PAN:
            if (this.enablePan === false) return;
            this._handleTouchMovePan(s), this.update();
            break;
          case gt.TOUCH_DOLLY_PAN:
            if (this.enableZoom === false && this.enablePan === false) return;
            this._handleTouchMoveDollyPan(s), this.update();
            break;
          case gt.TOUCH_DOLLY_ROTATE:
            if (this.enableZoom === false && this.enableRotate === false) return;
            this._handleTouchMoveDollyRotate(s), this.update();
            break;
          default:
            this.state = gt.NONE;
        }
      }
      function NP(s) {
        this.enabled !== false && s.preventDefault();
      }
      function QP(s) {
        s.key === "Control" && (this._controlActive = true, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      function OP(s) {
        s.key === "Control" && (this._controlActive = false, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
          passive: true,
          capture: true
        }));
      }
      class zP {
        constructor(e, t, i, n) {
          this.pages = e, this.marker = t, this.currentSpread = 0, this.onPageChange = n, this.audioPlayer = i, this.frontBtn = document.getElementById("btn-front"), this.backBtn = document.getElementById("btn-back"), this.pageContainer = document.getElementById("page-buttons"), this.asideLinkContainer = document.querySelector(".chapter-aside"), this.setFirstButtonHandler = this.setFirstButtonHandler.bind(this), this.setLastButtonHandler = this.setLastButtonHandler.bind(this), this.frontBtn.addEventListener("click", this.setFirstButtonHandler), this.backBtn.addEventListener("click", this.setLastButtonHandler), this.generateSideButtons(), this.generatePageButtons(), this.updateUI();
        }
        generateSideButtons() {
          const e = this.asideLinkContainer.children;
          e.length > 1 && Array.from(e).forEach((i, n, r) => n !== r.length - 1 && i.remove());
          const t = (i) => {
            for (let n = 0; n < i; n++) {
              const r = document.createElement("a");
              this.asideLinkContainer.prepend(r);
            }
          };
          switch (this.marker) {
            case "portfolio":
              t(1);
              break;
            case "credits":
              t(2);
              break;
            case "contacts":
              t(3);
              break;
            default:
              t(0);
          }
        }
        generatePageButtons() {
          this.pageContainer.innerHTML = "";
          for (let e = 1; e < this.pages.length; e++) {
            const t = document.createElement("button");
            t.classList.add("page-btn"), t.textContent = `Pages ${e * 2 - 1}-${e * 2}`, t.addEventListener("click", () => this.setPage(e)), this.pageContainer.appendChild(t);
          }
        }
        setFirstButtonHandler() {
          this.setPage(0);
        }
        setLastButtonHandler() {
          this.setPage(this.pages.length);
        }
        destroy() {
          this.frontBtn.removeEventListener("click", this.setFirstButtonHandler), this.backBtn.removeEventListener("click", this.setLastButtonHandler), this.pageContainer.innerHTML = "";
        }
        updateUI() {
          this.frontBtn.disabled = this.currentSpread === 0, this.backBtn.disabled = this.currentSpread >= this.pages.length, [
            ...this.pageContainer.children
          ].forEach((e, t) => {
            e.classList.toggle("active", t === this.currentSpread - 1);
          });
        }
        setPage(e) {
          this.currentSpread = e, this.onPageChange(e), this.updateUI(), this.playFlipSound();
        }
        playFlipSound() {
          this.audioPlayer && this.audioPlayer.playSound("./sounds/page-flip.mp3");
        }
      }
      const Qr = {
        portfolio: [
          {
            front: "portfolio-cover",
            back: "portfolio_devices_first",
            links: []
          },
          {
            front: "portfolio_devices_second",
            back: "portfolio_burger_first",
            links: [
              {
                text: "Visit 01",
                link: "https://github.com/zaxel/react_simple_shop"
              }
            ]
          },
          {
            front: "portfolio_burger_second",
            back: "portfolio_resume_first",
            links: [
              {
                text: "Visit 02",
                link: "https://zaxel.github.io/react_burger_shop"
              }
            ]
          },
          {
            front: "portfolio_resume_second",
            back: "portfolio_mixed_first",
            links: [
              {
                text: "Visit 03",
                link: "https://zaxel.github.io/3d_resume"
              }
            ]
          },
          {
            front: "portfolio_mixed_second",
            back: "portfolio_sorter_first",
            links: [
              {
                text: "Visit 04",
                link: "https://zaxel.github.io/mixed_features_react_app"
              }
            ]
          },
          {
            front: "portfolio_sorter_second",
            back: "portfolio_maze_first",
            links: [
              {
                text: "Visit 05",
                link: "https://zaxel.github.io/mail_sorter"
              }
            ]
          },
          {
            front: "portfolio_maze_second",
            back: "portfolio_tetris_first",
            links: [
              {
                text: "Visit 06",
                link: "https://zaxel.github.io/maze-builder/"
              }
            ]
          },
          {
            front: "portfolio_tetris_second",
            back: "portfolio_converter_first",
            links: [
              {
                text: "Visit 07",
                link: "https://zaxel.github.io/tetris/"
              }
            ]
          },
          {
            front: "portfolio_converter_second",
            back: "portfolio_weather_first",
            links: [
              {
                text: "Visit 08",
                link: "https://zaxel.github.io/currency-converter"
              }
            ]
          },
          {
            front: "portfolio_weather_second",
            back: "portfolio_italian-food_first",
            links: [
              {
                text: "Visit 09",
                link: "https://zaxel.github.io/weatherApp"
              }
            ]
          },
          {
            front: "portfolio_italian-food_second",
            back: "portfolio_bigmack_first",
            links: [
              {
                text: "Visit 10",
                link: "https://zaxel.github.io/italian_food"
              }
            ]
          },
          {
            front: "portfolio_bigmack_second",
            back: "portfolio_italian-cuisine_first",
            links: [
              {
                text: "Visit 11",
                link: "https://zaxel.github.io/bigmack/"
              }
            ]
          },
          {
            front: "portfolio_italian-cuisine_second",
            back: "portfolio_mobiler_first",
            links: [
              {
                text: "Visit 12",
                link: "https://zaxel.github.io/foody"
              }
            ]
          },
          {
            front: "portfolio_mobiler_second",
            back: "portfolio_carcharger_first",
            links: [
              {
                text: "Visit 13",
                link: "https://zaxel.github.io/mobiler.com"
              }
            ]
          },
          {
            front: "portfolio_carcharger_second",
            back: "portfolio_bikeshop_first",
            links: [
              {
                text: "Visit 14",
                link: "https://zaxel.github.io/car_charger/dist"
              }
            ]
          },
          {
            front: "portfolio_bikeshop_second",
            back: "cover",
            links: [
              {
                text: "Visit 15",
                link: "https://zaxel.github.io/bike-shop"
              }
            ]
          }
        ],
        profile: [
          {
            front: "profile-cover",
            back: "profile_first"
          },
          {
            front: "profile_second",
            back: "cover"
          }
        ],
        skills: [
          {
            front: "skills-cover",
            back: "skills_first"
          },
          {
            front: "skills_second",
            back: "cover"
          }
        ],
        history: [
          {
            front: "history-cover",
            back: "history_first"
          },
          {
            front: "history_second",
            back: "cover"
          }
        ],
        contacts: [
          {
            front: "contacts-cover",
            back: "contacts_first"
          },
          {
            front: "contacts_second",
            back: "cover",
            links: [
              {
                text: "Call",
                link: "tel:380676780478"
              },
              {
                text: "Mail",
                link: "mailto:sae11.z.alex@gmail.com"
              },
              {
                text: "GitHub",
                link: "https://github.com/zaxel"
              }
            ]
          }
        ],
        hobbies: [
          {
            front: "hobbies-cover",
            back: "hobbies_cycling_first"
          },
          {
            front: "hobbies_cycling_second",
            back: "hobbies_prehistoric_first"
          },
          {
            front: "hobbies_prehistoric_second",
            back: "hobbies_cosmos_first"
          },
          {
            front: "hobbies_cosmos_second",
            back: "cover"
          }
        ],
        credits: [
          {
            front: "credits-cover",
            back: "credits_1_first"
          },
          {
            front: "credits_1_second",
            back: "credits_2_first",
            links: [
              {
                text: "Visit 01",
                link: "https://sketchfab.com/3d-models/af05-basic-modeling-dao-pt-6eab61b7a8e3405a9259eebd65cc7ffd"
              },
              {
                text: "Visit 02",
                link: "https://sketchfab.com/3d-models/medieval-blacksmith-2e4f2725963644c685419dea1e4430df"
              }
            ]
          },
          {
            front: "credits_2_second",
            back: "credits_3_first",
            links: [
              {
                text: "Visit 03",
                link: "https://sketchfab.com/3d-models/the-wandering-smith-b64167041c9543f1bfb58a871da5ce1c"
              },
              {
                text: "Visit 04",
                link: "https://sketchfab.com/3d-models/tavern-medieval-house-eda03fe47db1450a93a4e2102e4caf65"
              }
            ]
          },
          {
            front: "credits_3_second",
            back: "credits_4_first",
            links: [
              {
                text: "Visit 05",
                link: "https://sketchfab.com/3d-models/mill-wind-d53ed9dc8f624db9be4c7f3ec22a8e8b"
              },
              {
                text: "Visit 06",
                link: "https://sketchfab.com/3d-models/fishermans-house-7df29905b3704e61874d5906db9f0a75"
              }
            ]
          },
          {
            front: "credits_4_second",
            back: "credits_5_first",
            links: [
              {
                text: "Visit 07",
                link: "https://sketchfab.com/3d-models/dreamy-bridge-50c3313a16c740a4b02d0ff2e2441889"
              },
              {
                text: "Visit 08",
                link: "https://sketchfab.com/3d-models/old-bridge-6441316f4195400f80d5bdcbfe835d30"
              }
            ]
          },
          {
            front: "credits_5_second",
            back: "credits_6_first",
            links: [
              {
                text: "Visit 09",
                link: "https://sketchfab.com/3d-models/bridge-9328bbfc04a84202a6a97bd59408473a"
              },
              {
                text: "Visit 10",
                link: "https://sketchfab.com/3d-models/medieval-notice-board-6b81d6df32724396bd56e79f6774b25f"
              }
            ]
          },
          {
            front: "credits_6_second",
            back: "cover",
            links: [
              {
                text: "Visit 11",
                link: "https://sketchfab.com/3d-models/the-medieval-book-stand-3e736d23b3f44f0d859b40a4fc13af0d"
              },
              {
                text: "Visit 12",
                link: "https://sketchfab.com/3d-models/stylized-wood-signs-d529ec8478304d45a5048e15cf9cc9db"
              }
            ]
          }
        ]
      };
      class GP {
        constructor(e, t, i) {
          this.markersDistanceHandler = e, this.marker = null, this.lastMarker = null, this.modal = document.getElementById("modal-chapter-cont"), this.closeButton = this.modal.querySelector(".chapter-close"), this.audio = t, this.loadManager = i, this.books = {}, this.currentBook = null, this.raycasterPointerMoveHandler = null, this.initScene(), this.preloadTextures().then(() => this.forceTextureUpload()).then(() => this.preloadBooks()).then(() => this.preprocessGeometries()).then(() => this.precompileShaders()).then(() => this.animate());
        }
        async initScene() {
          this._previousFrame = null, this.canvas = document.querySelector(".chapter-canvas"), this.scene = new ao(), this.scene.rotateX(as(-25)), this.camera = new Vt(45, window.innerWidth / window.innerHeight, 0.1, 100), this.camera.position.set(0, 0, 3), this.renderer = new Dp({
            canvas: this.canvas,
            alpha: true,
            antialias: true
          }), this.renderer.setSize(window.innerWidth, window.innerHeight), this.controls = new NA(this.camera, this.renderer.domElement), this.controls.enableDamping = true, this.addLighting(), this.paginationNumber = 0, this.firstLoad = true, this.close();
        }
        async preloadBooks() {
          const e = Object.keys(Qr);
          for (const t of e) {
            const i = Qr[t], n = await this.createBook(i);
            n.visible = true, this.scene.add(n), this.books[t] = n;
          }
        }
        async preloadTextures() {
          const e = new Si(this.loadManager);
          this.textureCache = /* @__PURE__ */ new Map();
          const t = [];
          Object.values(Qr).forEach((i) => {
            i.forEach((n) => {
              if (n.front) {
                const r = new Promise((a) => {
                  e.load(`./book/${n.front}.jpg`, (o) => {
                    this.textureCache.set(n.front, o), a();
                  });
                });
                t.push(r);
              }
              if (n.back) {
                const r = new Promise((a) => {
                  e.load(`./book/${n.back}.jpg`, (o) => {
                    this.textureCache.set(n.back, o), a();
                  });
                });
                t.push(r);
              }
            });
          }), await Promise.all(t);
        }
        precompileShaders() {
          const e = new ao(), t = new yo(), i = new Zi(), n = [];
          Object.values(this.books).forEach((r) => {
            r.traverse((a) => {
              a.isMesh && n.push(a.geometry);
            });
          }), n.forEach((r) => {
            const a = new yt(r, i);
            e.add(a);
          }), this.renderer.render(e, t);
        }
        forceTextureUpload() {
          const e = new ao(), t = new yo(), i = new Zi({
            map: this.textureCache.values().next().value
          }), n = new yr(), r = new yt(n, i);
          e.add(r), this.renderer.render(e, t);
        }
        preprocessGeometries() {
          Object.values(this.books).forEach((e) => {
            e.traverse((t) => {
              t.isMesh && t.geometry && (t.geometry.computeVertexNormals(), t.geometry.computeBoundingBox(), t.geometry.computeBoundingSphere());
            });
          });
        }
        async createBook(e) {
          const t = new Li(), i = 1.28, n = 1.71, r = 3e-3, a = 30, o = i / a, c = new cs(i, n, r, a, 2);
          this.pageParams = {
            pageWidth: i,
            pageHeight: n,
            pageDepth: r,
            pageSegments: a,
            segmentWidth: o
          }, new Si();
          const l = () => {
            const u = c.attributes.position, f = new T(), p = [], m = [];
            for (let g = 0; g < u.count; g++) {
              f.fromBufferAttribute(u, g);
              const A = f.x + i / 2, x = Math.max(0, Math.floor(A / o)), b = A % o / o;
              p.push(x, x + 1, 0, 0), m.push(1 - b, b, 0, 0);
            }
            c.setAttribute("skinIndex", new ko(p, 4)), c.setAttribute("skinWeight", new _t(m, 4)), c.translate(i / 2, 0, 0);
          }, h = ({ front: u, back: f }, p) => {
            const m = [];
            for (let D = 0; D <= a; D++) {
              let S = new qs();
              m.push(S), D === 0 ? S.position.x = 0 : S.position.x = o, D > 0 && m[D - 1].add(S);
            }
            new ue("white");
            const g = new ue("orange");
            new ue("black");
            const A = new ue(14869218), x = new ue(14277081), b = [
              new Ei({
                color: x
              }),
              new Ei({
                color: A
              }),
              new Ei({
                color: x
              }),
              new Ei({
                color: x
              }),
              new Ei({
                color: A,
                emissive: g,
                emissiveIntensity: 0
              }),
              new Ei({
                color: A,
                emissive: g,
                emissiveIntensity: 0
              })
            ];
            if (u) {
              const D = this.textureCache.get(u);
              D ? (b[4].map = D, b[4].needsUpdate = true, D.colorSpace = nt) : console.error(`Texture not found in cache: ${u}`);
            }
            if (f) {
              const D = this.textureCache.get(f);
              D ? (b[5].map = D, b[5].needsUpdate = true, D.colorSpace = nt) : console.error(`Texture not found in cache: ${f}`);
            }
            const y = new aa(m), I = new Mh(c, b);
            I.castShadow = true, I.receiveShadow = true, I.frustumCulled = false;
            const M = -p * r;
            I.position.set(0, 0, M), I.add(y.bones[0]), I.bind(y), I.index = p;
            const R = new aw(I);
            return R.visible = false, this.scene.add(R), I;
          }, d = (u = []) => {
            (u || []).forEach((f, p, m) => {
              const g = h(f, p);
              g.isOpen = false, g.isLastOpen = false, g.turnedAt = Date.now(), g.isHighlighted = false, g.onClick = (A) => {
                g.isOpen ? this.pagination.setPage(this.paginationNumber - 1) : this.pagination.setPage(this.paginationNumber + 1);
              }, g.onPointerenter = (A) => {
                g.isHighlighted = true;
              }, g.onPointerleave = (A) => {
                g.isHighlighted = false;
              }, t.add(g);
            }), t.position.z = 0.28;
          };
          return l(), d(e), t;
        }
        addSceneContent() {
          this.currentBook && (this.currentBook.visible = false);
          const e = this.books[this.marker];
          if (e) {
            this.firstLoad && (Object.values(this.books).forEach((i) => {
              i.visible = false;
            }), this.firstLoad = false), e.visible = true, this.currentBook = e, this.resetPageStates(e), this.resetPageTransforms(e);
            const t = Qr[this.marker];
            this.addPagination(t, this.marker);
          }
          this.setRaycaster();
        }
        resetPageStates(e) {
          e.children.forEach((t) => {
            t.isOpen = false, t.isLastOpen = false, t.turnedAt = Date.now(), t.isHighlighted = false;
          });
        }
        resetPageTransforms(e) {
          const { pageWidth: t, pageHeight: i, pageDepth: n, pageSegments: r, segmentWidth: a } = this.pageParams;
          e.children.forEach((o) => {
            o.rotation.set(0, 0, 0), o.position.set(0, 0, -o.index * n), o.skeleton && o.skeleton.bones.forEach((c, l) => {
              c.rotation.set(0, 0, 0), l === 0 || l % (r + 1) === 0 ? c.position.set(0, 0, 0) : c.position.set(a, 0, 0);
            });
          });
        }
        addLighting() {
          const e = new Nh(16777215, 0.5), t = new Oo(16777215, 1);
          t.position.set(1, 1, 1), this.scene.add(e, t);
        }
        setRaycaster() {
          this.raycasterClickHandler && this.renderer.domElement.removeEventListener("click", this.raycasterClickHandler), this.raycasterPointerMoveHandler && this.renderer.domElement.removeEventListener("pointermove", this.raycasterPointerMoveHandler);
          const e = new sw(), t = new oe();
          let i = null;
          this.raycasterClickHandler = (n) => {
            t.x = n.clientX / window.innerWidth * 2 - 1, t.y = -(n.clientY / window.innerHeight) * 2 + 1, e.setFromCamera(t, this.camera);
            const r = e.intersectObjects(this.currentBook.children, true);
            if (r.length > 0) {
              const a = r[0].object;
              a.onClick && a.onClick(n);
            }
          }, this.raycasterPointerMoveHandler = (n) => {
            t.x = n.clientX / window.innerWidth * 2 - 1, t.y = -(n.clientY / window.innerHeight) * 2 + 1, e.setFromCamera(t, this.camera);
            const r = e.intersectObjects(this.currentBook.children, true);
            if (r.length > 0) {
              const a = r[0].object;
              a !== i && (i && i.onPointerleave && i.onPointerleave(n), a.onPointerenter && a.onPointerenter(n), i = a, this.renderer.domElement.style.cursor = "pointer");
            } else i && i.onPointerleave && i.onPointerleave(n), i = null, this.renderer.domElement.style.cursor = "default";
          }, this.renderer.domElement.addEventListener("click", this.raycasterClickHandler), this.renderer.domElement.addEventListener("pointermove", this.raycasterPointerMoveHandler);
        }
        updatePageRotation(e) {
          const t = this.currentBook;
          if (!t) {
            console.error("Book group not found in the scene.");
            return;
          }
          const i = this.paginationNumber !== 0 && this.paginationNumber !== t.children.length;
          t.children.forEach((n) => {
            if (n.index === void 0) {
              console.error("Page index is undefined:", n);
              return;
            }
            const r = n.isHighlighted ? 0.2 : 0;
            n.material[4].emissiveIntensity = n.material[5].emissiveIntensity = this.lerp(n.material[4].emissiveIntensity, r, e, 3), n.isOpen = n.index < this.paginationNumber, n.isLastOpen !== n.isOpen && (n.turnedAt = /* @__PURE__ */ new Date(), n.isLastOpen = n.isOpen);
            let a = Math.min(400, /* @__PURE__ */ new Date() - n.turnedAt) / 400;
            a = Math.sin(a * Math.PI);
            let o = n.isOpen ? -Math.PI / 2 : Math.PI / 2;
            i && (o += (n.index - this.paginationNumber) * 0.015);
            const c = n.skeleton;
            if (!c || !c.bones || c.bones.length === 0) {
              console.error("Page skeleton is missing bones:", n);
              return;
            }
            const l = c.bones;
            l.forEach((h, d) => {
              const u = d === 0 ? t : h, f = d < 9 ? Math.sin(d * 0.2 + 0.23) : 0, p = 0.17, m = d >= 9 ? Math.cos(d * 0.3 + 0.1) : 0, g = 0.028, A = Math.sin(d * Math.PI * (1 / l.length)) * a;
              let b = f * p * o - m * g * o + A * 0.08 * o;
              const y = d >= 9 ? Math.sin(d * Math.PI * (1 / l.length) - 0.5) * a : 0;
              let I = as(Math.sin(o) * 2);
              i || (b = d == 0 ? o * 0.9999 : 0, I = 0);
              const M = 3;
              let R = 1.5;
              if (u === t) {
                const D = t.children.length;
                D < 2 ? R = 0.7 : D < 4 ? R = 0.5 : D < 6 ? R = 0.3 : D < 10 ? R = 0.2 : R = 0.1, b -= Math.PI / 2;
              }
              u.rotation.y = this.lerp(u.rotation.y, b, e, R), u.rotation.x = this.lerp(u.rotation.x, I * y, e, M);
            });
          });
        }
        lerp(e, t, i, n) {
          const r = 1 - Math.exp(-i * n);
          return e * (1 - r) + t * r;
        }
        updatePaginationLinks(e) {
          if (this.marker !== "contacts" && this.marker !== "portfolio" && this.marker !== "credits") return;
          const t = this.pagination.asideLinkContainer.children, i = this.pagination.currentSpread;
          if (this.pagination.currentSpread === 0 || this.pagination.currentSpread === this.pagination.pages.length) {
            for (let n = 0; n < t.length - 1; n++) t[n].classList.remove("chapter-link-show");
            return;
          }
          for (let n = 0; n < t.length - 1; n++) t[n].textContent = e[i].links[n].text, t[n].href = e[i].links[n].link, t[n].target = "blank", t[n].classList.add("chapter-link-show");
        }
        addPagination(e, t) {
          e && (this.pagination && this.pagination.destroy(), this.paginationNumber = 0, this.pagination = new zP(e, t, this.audio, (i) => {
            let n = null;
            const r = () => {
              if (this.paginationNumber === i) {
                clearTimeout(n);
                return;
              }
              n = setTimeout(r, Math.abs(i - this.paginationNumber) > 2 ? 50 : 150), i < this.paginationNumber ? this.paginationNumber-- : i > this.paginationNumber && this.paginationNumber++, this.updatePaginationLinks(e);
            };
            r();
          }));
        }
        getChapterContent(e) {
          return Qr[e] ?? Qr.portfolio;
        }
        updateMarkerStatus() {
          var _a2, _b2;
          const e = (_b2 = (_a2 = this.markersDistanceHandler) == null ? void 0 : _a2.activeMarker) == null ? void 0 : _b2.name;
          e === this.lastMarker || e === null || e === void 0 || (this.lastMarker = this.marker, this.marker = e);
        }
        updateChapterContent() {
          this.marker === this.lastMarker || this.marker === null || this.marker === void 0 || this.addSceneContent();
        }
        animate(e = 0) {
          requestAnimationFrame(this.animate.bind(this)), this._previousFrame === null && (this._previousFrame = e);
          const t = (e - this._previousFrame) * 1e-3;
          this._previousFrame = e, this.controls.update(), this.renderer.render(this.scene, this.camera), this.currentBook && this.currentBook.visible && this.updatePageRotation(t), this.updateMarkerStatus(), this.updateChapterContent();
        }
        open() {
          this.renderer.setAnimationLoop(() => this.renderer.render(this.scene, this.camera));
        }
        close() {
          this.renderer.setAnimationLoop(null);
        }
      }
      class HP {
        constructor(e, t, i, n, r, a, o, c, l, h) {
          this.scene = o, this.camera = i, this.audioLoader = new zm(), this.btnsController = h, this.audioFiles = a, this.riverCurve = t.riverCatmullCurve, this.musicStatus = c, this.soundsStatus = l, this.listener = new Vm(), this.camera.add(this.listener), this.keys = n, this.charStateMachine = r, this.prevState = null, this.prevExternLoadedSoundLink = null, this.externLoadedSound = null, this.walkFwdSound = new Ri(this.listener), this.runFwdSound = new Ri(this.listener), this.walkBwdSound = new Ri(this.listener), this.runBwdSound = new Ri(this.listener), this.jumpStandSound = new Ri(this.listener), this.jumpBwdSound = new Ri(this.listener), this.movementSounds = [
            this.walkFwdSound,
            this.runFwdSound,
            this.walkBwdSound,
            this.runBwdSound,
            this.jumpStandSound,
            this.jumpBwdSound
          ], this.idleTheme = new Ri(this.listener), this.walkTheme = new Ri(this.listener), this.runTheme = new Ri(this.listener), this.themeSounds = [
            this.idleTheme,
            this.walkTheme,
            this.runTheme
          ], this.parkSounds = new Ri(this.listener), this.riverSounds = new _u(this.listener), this.scene.add(this.riverSounds), this.ambienceSounds = [
            this.parkSounds,
            this.riverSounds
          ], e.blades && (this.windmillSounds = new _u(this.listener), this.ambienceSounds.push(this.windmillSounds), this.scene.children.find((f) => f.name === "blade").children[0].children[0].add(this.windmillSounds)), this.initAudioFiles(), this.soundsManager(), this.updateRiverSound(), this.initHelpBtnsHandler();
        }
        updateRiverSound() {
          const e = this.getClosestPointToRiver(this.camera.position);
          this.riverSounds.position.copy(e);
        }
        getClosestPointToRiver(e) {
          let t = null, i = 1 / 0;
          const n = 100;
          for (let r = 0; r <= 1; r += 1 / n) {
            const a = this.riverCurve.getPoint(r), o = e.distanceTo(a);
            o < i && (i = o, t = a);
          }
          return t;
        }
        playSound(e, t = 0.5) {
          if (this.soundsStatus) {
            if (this.prevExternLoadedSoundLink === e && this.externLoadedSound) {
              this.externLoadedSound.setVolume(t), this.externLoadedSound.play();
              return;
            }
            this.externLoadedSound && (this.externLoadedSound.stop(), this.externLoadedSound.disconnect()), this.prevExternLoadedSoundLink = e, this.externLoadedSound = new Ri(this.listener), this.audioLoader.load(e, (i) => {
              this.externLoadedSound.setBuffer(i), this.externLoadedSound.setVolume(t), this.externLoadedSound.play();
            }, void 0, (i) => console.error("Failed to load sound:", i));
          }
        }
        initAudioFiles() {
          this.audioLoader.load(this.audioFiles.park, (e) => {
            this.parkSounds.setBuffer(e), this.parkSounds.setLoop(true), this.parkSounds.setVolume(0.3), this.soundsStatus && this.parkSounds.play();
          }), this.audioLoader.load(this.audioFiles.walkFwdSound, (e) => {
            this.walkFwdSound.setBuffer(e), this.walkFwdSound.setLoop(true), this.walkFwdSound.setVolume(0.6);
          }), this.audioLoader.load(this.audioFiles.runFwdSound, (e) => {
            this.runFwdSound.setBuffer(e), this.runFwdSound.setLoop(true), this.runFwdSound.setVolume(0.6), this.runFwdSound.setPlaybackRate(1.6);
          }), this.audioLoader.load(this.audioFiles.walkBwdSound, (e) => {
            this.walkBwdSound.setBuffer(e), this.walkBwdSound.setLoop(true), this.walkBwdSound.setVolume(0.6), this.walkBwdSound.setPlaybackRate(0.8);
          }), this.audioLoader.load(this.audioFiles.runBwdSound, (e) => {
            this.runBwdSound.setBuffer(e), this.runBwdSound.setLoop(true), this.runBwdSound.setVolume(0.6), this.runBwdSound.setPlaybackRate(1.6);
          }), this.audioLoader.load(this.audioFiles.jumpStandSound, (e) => {
            this.jumpStandSound.setBuffer(e), this.jumpStandSound.setVolume(0.6);
          }), this.audioLoader.load(this.audioFiles.jumpBwdSound, (e) => {
            this.jumpBwdSound.setBuffer(e), this.jumpBwdSound.setVolume(0.6);
          }), this.audioLoader.load(this.audioFiles.idleTheme, (e) => {
            this.idleTheme.setBuffer(e), this.idleTheme.setLoop(true), this.idleTheme.setVolume(0.3);
          }), this.audioLoader.load(this.audioFiles.walkTheme, (e) => {
            this.walkTheme.setBuffer(e), this.walkTheme.setLoop(true), this.walkTheme.setVolume(0.3);
          }), this.audioLoader.load(this.audioFiles.runTheme, (e) => {
            this.runTheme.setBuffer(e), this.runTheme.setLoop(true), this.runTheme.setVolume(0.3);
          }), this.audioLoader.load(this.audioFiles.river, (e) => {
            this.riverSounds.setBuffer(e), this.riverSounds.setLoop(true), this.riverSounds.setVolume(1), this.riverSounds.setRefDistance(10), this.riverSounds.setRolloffFactor(2), this.soundsStatus && this.riverSounds.play();
          }), this.windmillSounds && this.audioLoader.load(this.audioFiles.windmill, (e) => {
            this.windmillSounds.setBuffer(e), this.windmillSounds.setLoop(true), this.windmillSounds.setVolume(1), this.windmillSounds.setRefDistance(8), this.windmillSounds.setRolloffFactor(2), this.soundsStatus && this.windmillSounds.play();
          });
        }
        initHelpBtnsHandler() {
          this.btnsController.onSoundOn = this.btnsController.onSoundOn.bind(null, this.soundOn.bind(this)), this.btnsController.onSoundOff = this.btnsController.onSoundOff.bind(null, this.soundOff.bind(this)), this.btnsController.onMusicOn = this.btnsController.onMusicOn.bind(null, this.musicOn.bind(this)), this.btnsController.onMusicOff = this.btnsController.onMusicOff.bind(null, this.musicOff.bind(this));
        }
        clearMovementSounds() {
          this.movementSounds.forEach((e) => {
            e.isPlaying && e.stop();
          });
        }
        clearThemeSounds() {
          this.themeSounds.forEach((e) => {
            e.isPlaying && e.pause();
          });
        }
        clearAmbienceSounds() {
          this.ambienceSounds.forEach((e) => {
            e.isPlaying && e.pause();
          });
        }
        fadeIn(e, t = 1, i = 1e3, n = 0) {
          e.setVolume(0), e.play(n / 1e3);
          const r = 30, a = i / r;
          let o = 0;
          function c() {
            const l = o / r * t;
            e.setVolume(l), o++, o <= r && setTimeout(c, a);
          }
          c();
        }
        fadeOut(e, t = 1e3, i = "stop") {
          const n = e.getVolume(), r = 30, a = t / r;
          let o = 0;
          function c() {
            const l = n * (1 - o / r);
            e.setVolume(Math.max(l, 0)), o++, o <= r ? setTimeout(c, a) : (e.setVolume(0), i === "stop" ? e.stop() : e.pause());
          }
          c();
        }
        soundsManager() {
          window.addEventListener("keydown", (e) => {
            switch (e.keyCode) {
              case 77:
                this.musicStatus ? this.musicOff() : this.musicOn();
                break;
              case 78:
                this.soundsStatus ? this.soundOff() : this.soundOn();
                break;
            }
          });
        }
        musicOn() {
          this.musicStatus = true, this.idleTheme.play(), this.btnsController.musicOn(false);
        }
        musicOff() {
          this.musicStatus = false, this.clearThemeSounds(), this.btnsController.musicOff(false);
        }
        soundOn() {
          this.soundsStatus = true, this.ambienceSounds.forEach((e) => {
            e.play();
          }), this.btnsController.soundOn(false);
        }
        soundOff() {
          this.soundsStatus = false, this.clearMovementSounds(), this.clearAmbienceSounds(), this.btnsController.soundOff(false);
        }
        updateSoundsState() {
          if (!this.charStateMachine._currentState) return;
          const e = this.charStateMachine._currentState.Name;
          if (this.camera.position.distanceTo(this.riverSounds.position) > 2 && this.updateRiverSound(), e === this.prevState) return;
          if (!this.soundsStatus && !this.musicStatus) {
            this.clearMovementSounds(), this.clearThemeSounds();
            return;
          }
          this.clearMovementSounds();
          const t = 800;
          switch (e) {
            case "walk_fwd":
              this.clearThemeSounds(), this.musicStatus && this.fadeIn(this.walkTheme, 0.3, t), this.soundsStatus && this.walkFwdSound.play();
              break;
            case "run_fwd":
              this.clearThemeSounds(), this.soundsStatus && this.runFwdSound.play(), this.musicStatus && this.fadeIn(this.runTheme, 0.3, t);
              break;
            case "walk_bwd":
              this.clearThemeSounds(), this.musicStatus && this.fadeIn(this.walkTheme, 0.3, t), this.soundsStatus && this.walkBwdSound.play();
              break;
            case "run_bwd":
              this.clearThemeSounds(), this.soundsStatus && this.runBwdSound.play(), this.musicStatus && this.fadeIn(this.runTheme, 0.3, t);
              break;
            case "jumpStand":
            case "jumpFwd":
              this.soundsStatus && this.jumpStandSound.play(0.3);
              break;
            case "jumpBwd":
              this.soundsStatus && this.jumpBwdSound.play();
              break;
            case "idle":
              this.clearThemeSounds(), this.musicStatus && this.fadeIn(this.idleTheme, 0.3, t);
              break;
          }
          this.prevState = e;
        }
      }
      const VP = {
        walkFwdSound: "sounds/step.wav",
        walkBwdSound: "sounds/step.wav",
        runFwdSound: "sounds/step.wav",
        runBwdSound: "sounds/step.wav",
        jumpStandSound: "sounds/long_jump.flac",
        jumpBwdSound: "sounds/jump.flac",
        idleTheme: "sounds/Bamboo_Forest.mp3",
        walkTheme: "sounds/walk_3.mp3",
        runTheme: "sounds/run_3.mp3",
        park: "sounds/park_2.wav",
        river: "sounds/amb_river.flac",
        windmill: "sounds/windmill.mp3"
      };
      class WP {
        constructor(e, t = false) {
          this.scene = e, this.visible = t, this.riverCurve = new Ni(), this.initRiverCurve();
        }
        initRiverCurve() {
          const e = [
            new T(140, -13, -690),
            new T(140, -13, -500),
            new T(70, -13, -400),
            new T(70, -13, 0),
            new T(0, -13, 90),
            new T(50, -13, 140),
            new T(230, -13, 190),
            new T(230, -13, 290),
            new T(130, -13, 390),
            new T(-175, -13, 690)
          ], t = new cp(e), i = new Fh(t, 100, 0.5, 8, false), n = new Zi({
            color: 255,
            transparent: true,
            opacity: 0.5
          });
          this.riverCurveMesh = new yt(i, n), this.riverCurveMesh.visible = this.visible, this.scene.add(this.riverCurveMesh), this.riverCatmullCurve = t;
        }
      }
      const jP = [
        "./skybox/blizzard_ft.jpg",
        "./skybox/blizzard_bk.jpg",
        "./skybox/blizzard_up.jpg",
        "./skybox/blizzard_dn.jpg",
        "./skybox/blizzard_rt.jpg",
        "./skybox/blizzard_lf.jpg"
      ], qP = [
        "./skybox/yonder_ft.jpg",
        "./skybox/yonder_bk.jpg",
        "./skybox/yonder_up.jpg",
        "./skybox/yonder_dn.jpg",
        "./skybox/yonder_rt.jpg",
        "./skybox/yonder_lf.jpg"
      ], Ff = {
        blizzard: jP,
        yonder: qP
      };
      class XP {
        constructor(e, t) {
          this.isFoggy = e, this.scene = t, this.cubeTextureLoader = new Fm();
        }
        addSkyBox() {
          let e = null;
          this.isFoggy ? e = this.cubeTextureLoader.load(Ff.blizzard) : e = this.cubeTextureLoader.load(Ff.yonder), e && (e.encoding = void 0, this.scene.background = e);
        }
      }
      class YP {
        constructor(e) {
          this.loadPage = document.getElementById("loading"), this.progressBar = document.getElementById("ld-progress"), this.manager = new yp(), this.helpMenu = e, this._setupEventHandlers();
        }
        getManager() {
          return this.manager;
        }
        _setupEventHandlers() {
          this.manager.onStart = this._onStart.bind(this), this.manager.onProgress = this._onProgress.bind(this), this.manager.onLoad = this._onLoad.bind(this), this.manager.onError = this._onError.bind(this);
        }
        _onStart(e, t, i) {
          this.loadPage && this.loadPage.classList.add("loading-show"), this.helpMenu.hide();
        }
        _onProgress(e, t, i) {
          this.progressBar && (this.progressBar.value = t / i * 100);
        }
        _onLoad() {
          this.loadPage && this.loadPage.classList.remove("loading-show"), this.helpMenu.show();
        }
        _onError(e) {
          console.error(`Error loading: ${e}`);
        }
      }
      class KP {
        constructor(e, t) {
          this.helpModule = document.getElementById("help-menu"), this.btns = this.helpModule.querySelector(".help-menu__wrapper"), this.body = document.body, this.lastSuitableBodyCont = document.getElementById("modal-chapter-cont"), this.soundsBtn = null, this.musicBtn = null, this.soundsStatus = e, this.musicStatus = t, this.initBtns(), this.helpModal = this.makeAndAddModal();
        }
        makeAndAddModal() {
          const e = document.createElement("div");
          e.classList.add("help__modal");
          const t = document.createElement("div");
          return t.classList.add("help__container"), t.innerHTML = `<fieldset class="c-main__right">
            <legend class="c-main__title">Controls</legend>
            <div class="c-main__controls-kbd">
              <dl class="c-main__kbd wasd">
                <dt class="wasd__buttons">
                  <div class="wasd__btns">
                    <div class="wasd__top-line">
                      <kbd>w</kbd>
                    </div>
                    <div class="wast__bottom-line">
                      <kbd>a</kbd>
                      <kbd>s</kbd>
                      <kbd>d</kbd>
                    </div>
                  </div>
                  <span> or </span>
                  <div class="wasd__arrs">
                    <div class="wasd__top-line">
                      <kbd>\u2191</kbd>
                    </div>
                    <div class="wasd__bottom-line">
                      <kbd>\u2190</kbd>
                      <kbd>\u2193</kbd>
                      <kbd>\u2192</kbd>
                    </div>
                  </div>
                </dt>
                <dd>- movement</dd>
              </dl>
              <dl class="c-main__kbd rand-action-kbd">
                <dt>
                  <kbd>r</kbd>
                </dt>
                <dd>- random action</dd>
              </dl>
              <dl class="c-main__kbd jump-kbd">
                <dt>
                  <kbd>ctrl</kbd>
                </dt>
                <dd>- jump</dd>
              </dl>
              <dl class="c-main__kbd run-kbd">
                <dt>hold <kbd>shift</kbd></dt>
                <dd>- run</dd>
              </dl>
              <dl class="c-main__kbd help-kbd">
                <dt>
                  <kbd>h</kbd>
                </dt>
                <dd>- help</dd>
              </dl>
              <dl class="c-main__kbd sounds-kbd">
                <dt>
                  <kbd>n</kbd>
                </dt>
                <dd>- sounds</dd>
              </dl>
              <dl class="c-main__kbd music-kbd">
                <dt>
                  <kbd>m</kbd>
                </dt>
                <dd>- music</dd>
              </dl>
              <dl class="c-main__kbd chapter-kbd">
                <dt>
                  <kbd>space</kbd>
                </dt>
                <dd>- open/close chapter</dd>
              </dl>
            </div>
          </fieldset>`, e.append(t), this.close = document.createElement("button"), this.close.textContent = "close", this.close.classList.add("help__close"), this.close.addEventListener("click", (i) => {
            this.hideModal(), this.show();
          }), e.append(this.close), this.body.append(e), this.setBtnListener(), e;
        }
        setBtnListener() {
          window.addEventListener("keydown", (e) => {
            e.keyCode === 72 && (this.helpModal.classList.contains("helpModal-show") ? (this.hideModal(), this.show()) : (this.showModal(), this.hide()));
          });
        }
        initBtns() {
          Array.from(this.btns.children).forEach((e) => {
            const t = e.firstElementChild, i = t.baseURI, n = t.dataset.group;
            n === "sound" ? (this.soundsBtn = e, t.src = i + `icons/${n}-${this.soundsStatus ? "on" : "off"}.svg`, this.soundsStatus || this.soundsBtn.classList.add("active")) : n === "music" && (this.musicBtn = e, t.src = i + `icons/${n}-${this.musicStatus ? "on" : "off"}.svg`, this.musicStatus || this.musicBtn.classList.add("active")), e.addEventListener("click", (r) => {
              e.classList.contains("help-menu__help") ? (this.showModal(), this.hide()) : r.currentTarget.classList.contains("active") ? this[`${n}On`](true) : this[`${n}Off`](true);
            });
          });
        }
        showModal() {
          this.helpModal.classList.add("helpModal-show");
        }
        hideModal() {
          this.helpModal.classList.remove("helpModal-show");
        }
        show() {
          this.helpModule.classList.add("help-menu-show");
        }
        hide() {
          this.helpModule.classList.remove("help-menu-show");
        }
        toggleAudio(e, t, i) {
          const n = e === "sound" ? this.soundsBtn : this.musicBtn, r = n.firstElementChild, a = r.baseURI;
          r.src = `${a}icons/${e}-${t ? "on" : "off"}.svg`, n.classList.toggle("active", !t), this[`${e}Status`] = t, i && this[`on${e.charAt(0).toUpperCase() + e.slice(1)}${t ? "On" : "Off"}`]();
        }
        soundOn(e) {
          this.toggleAudio("sound", true, e);
        }
        soundOff(e) {
          this.toggleAudio("sound", false, e);
        }
        musicOn(e) {
          this.toggleAudio("music", true, e);
        }
        musicOff(e) {
          this.toggleAudio("music", false, e);
        }
        onSoundOn(e) {
          e && e();
        }
        onSoundOff(e) {
          e && e();
        }
        onMusicOn(e) {
          e && e();
        }
        onMusicOff(e) {
          e && e();
        }
      }
      class JP {
        constructor(e, t) {
          this.limits = e, this.character = t, this.limitAnimationPlaying = false, this.keys = this.character.basicController._input.keys, this.btnPressedController = this.character.basicController._input, this.updated = 0;
        }
        setLimitAreaReachedAct() {
          this.keys.limitAreaReachedAct || (this.btnPressedController.limitAreaReachedAct = true);
        }
        update(e) {
          if (this.updated++, this.updated % 30 || this.limitAnimationPlaying) return;
          const t = this.character.rigidBody.translation();
          t.x < this.limits.maxX && t.x > this.limits.minX && t.z < this.limits.maxZ && t.z > this.limits.minZ || this.setLimitAreaReachedAct();
        }
      }
      const ZP = (s, e) => {
        const t = s.geometry.attributes.position.array, i = s.geometry.index.array, n = en.ColliderDesc.trimesh(t, i).setActiveEvents(en.ActiveEvents.COLLISION_EVENTS).setRestitution(0.1).setFriction(0.8).setCollisionGroups(65537);
        e.createCollider(n), console.log("\u2705 Physics Collider Set for Terrain");
      }, $P = (s) => {
        if (!s) throw new Error("No mesh found");
        const e = s.getObjectByName("Plane");
        if (!e) return new Error("Terrain 'Plane' not found!");
        let t = [];
        if (e.type === "Mesh" ? t.push(e) : t = e.children.filter((a) => a.isMesh), t.length === 0) return new Error("No meshes found inside 'Plane'!");
        const i = t.map((a) => {
          const o = a.geometry.clone().applyMatrix4(a.matrixWorld);
          return o.scale(vn.x, vn.y, vn.z), o;
        }), n = Gh(i, false), r = new yt(n, new Ei({
          color: 65280
        }));
        return r || new Error("Terrain mesh not found");
      }, eL = (s, e) => {
        try {
          const t = $P(e);
          console.log("\u2705 Terrain Mesh Loaded."), ZP(t, s);
        } catch (t) {
          console.error(t);
        }
      };
      class tL {
        constructor(e, t) {
          this._freeCamera, this._initCamera(e, t);
        }
        _initCamera(e, t) {
          this._freeCamera = new NA(e, t), this._freeCamera.target.set(0, 20, 0), this._freeCamera.update();
        }
      }
      class iL {
        constructor(e) {
          this._params = e, this._camera = e.camera, this._position = new T(), this._lookAt = new T(), this._keys = e.target._input._keys, this._thirdPersonOffset = new T(-20, 20, -30), this._selfieOffset = new T(-15, 15, -20), this._lookAtHeight = 10;
        }
        _calcTransformedPosition(e) {
          const t = e.clone();
          return t.applyQuaternion(this._params.target.rotation), t.add(this._params.target.position), t;
        }
        _calcTransformedSelfiePosition(e) {
          const t = new At().setFromAxisAngle(new T(0, 1, 0), Math.PI), i = e.clone().applyQuaternion(t).applyQuaternion(this._params.target.rotation);
          return this._params.target.position.clone().add(i);
        }
        _calcIdealOffset() {
          return this._keys.selfieMode ? this._calcTransformedSelfiePosition(this._selfieOffset) : this._calcTransformedPosition(this._thirdPersonOffset);
        }
        _calcIdealLookAt() {
          const e = this._params.target.position;
          return this._keys.selfieMode ? new T(e.x, e.y + this._lookAtHeight, e.z) : this._calcTransformedPosition(new T(0, this._lookAtHeight, 40));
        }
        _update(e) {
          const t = this._calcIdealOffset(), i = this._calcIdealLookAt(), n = 1 - Math.pow(1e-3, e);
          this._position.lerp(t, n), this._lookAt.lerp(i, n), this._camera.position.copy(this._position), this._camera.lookAt(this._lookAt);
        }
      }
      const dh = [
        "dance",
        "dance2",
        "dance3",
        "capoeira",
        "hip_hop_dancing"
      ], uh = [
        "arguing",
        "looking_behind",
        "pray",
        "no",
        "pointing",
        "shaking_it_off"
      ];
      class Rn {
        constructor(e) {
          this._parent = e;
        }
        enter() {
        }
        exit() {
        }
        update(e, t) {
        }
      }
      class Zo extends Rn {
        constructor(e, t) {
          super(e), this._jumpType = t, this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return this._jumpType;
        }
        enter(e) {
          const t = this._parent._proxy._animations[this._jumpType].action;
          if (t.getMixer().addEventListener("finished", this._finishedCallback), e) {
            const n = this._parent._proxy._animations[e.Name].action;
            t.reset(), t.setLoop(Lo, 1), t.clampWhenFinished = true, t.crossFadeFrom(n, 0.1, true), t.play();
          } else t.play();
        }
        _finished() {
          this._cleanup(), this._parent.setState("idle");
        }
        _cleanup() {
          this._parent._proxy._animations[this._jumpType].action.getMixer().removeEventListener("finished", this._finishedCallback);
        }
        exit() {
          this._cleanup();
        }
        update() {
        }
      }
      __publicField(Zo, "_jumpStates", [
        "jumpStand",
        "jumpBwd",
        "jumpFwd"
      ]);
      class nL extends Zo {
        constructor(e) {
          super(e, "jumpStand");
        }
      }
      class rL extends Zo {
        constructor(e) {
          super(e, "jumpFwd");
        }
      }
      class sL extends Zo {
        constructor(e) {
          super(e, "jumpBwd");
        }
      }
      class aL extends Rn {
        constructor(e) {
          super(e);
        }
        get Name() {
          return "run_fwd";
        }
        enter(e) {
          const t = this._parent._proxy._animations.run_fwd.action;
          if (e) {
            const i = this._parent._proxy._animations[e.Name].action;
            if (t.enabled = true, e.Name == "walk_fwd") {
              const n = t.getClip().duration / i.getClip().duration;
              t.time = i.time * n;
            } else t.time = 0, t.setEffectiveTimeScale(1), t.setEffectiveWeight(1);
            t.crossFadeFrom(i, 0.2, true), t.play();
          } else t.play();
        }
        exit() {
        }
        update(e, t) {
          if (t._keys.limitAreaReachedAct) {
            this._parent.setState("end_area");
            return;
          }
          if (t._keys.ctrl) {
            this._parent.setState("jumpFwd");
            return;
          }
          if (!(t._keys.forward && t._keys.shift)) {
            if (t._keys.forward && !t._keys.shift) {
              this._parent.setState("walk_fwd");
              return;
            }
            if (t._keys.backward) {
              this._parent.setState("walk_bwd");
              return;
            }
            this._parent.setState("idle");
          }
        }
      }
      class oL extends Rn {
        constructor(e) {
          super(e);
        }
        get Name() {
          return "run_bwd";
        }
        enter(e) {
          const t = this._parent._proxy._animations.run_bwd.action;
          if (e) {
            const i = this._parent._proxy._animations[e.Name].action;
            if (t.enabled = true, e.Name == "walk_bwd") {
              const n = t.getClip().duration / i.getClip().duration;
              t.time = i.time * n;
            } else t.time = 0, t.setEffectiveTimeScale(1), t.setEffectiveWeight(1);
            t.crossFadeFrom(i, 0.2, true), t.play();
          } else t.play();
        }
        exit() {
        }
        update(e, t) {
          if (t._keys.limitAreaReachedAct) {
            this._parent.setState("end_area");
            return;
          }
          if (t._keys.ctrl) {
            this._parent.setState("jumpBwd");
            return;
          }
          if (!(t._keys.backward && t._keys.shift)) {
            if (t._keys.backward && !t._keys.shift) {
              this._parent.setState("walk_bwd");
              return;
            }
            if (t._keys.forward) {
              this._parent.setState("walk_fwd");
              return;
            }
            this._parent.setState("idle");
          }
        }
      }
      class cL extends Rn {
        constructor(e) {
          super(e);
        }
        get Name() {
          return "walk_fwd";
        }
        enter(e) {
          const t = this._parent._proxy._animations.walk_fwd.action;
          if (e) {
            const i = this._parent._proxy._animations[e.Name].action;
            if (t.enabled = true, e.Name == "run_fwd") {
              const n = t.getClip().duration / i.getClip().duration;
              t.time = i.time * n;
            } else t.time = 0, t.setEffectiveTimeScale(1), t.setEffectiveWeight(1);
            t.crossFadeFrom(i, 0.5, true), t.play();
          } else t.play();
        }
        exit() {
        }
        update(e, t) {
          if (t._keys.forward) {
            if (t._keys.limitAreaReachedAct) {
              this._parent.setState("end_area");
              return;
            }
            t._keys.shift && this._parent.setState("run_fwd"), t._keys.ctrl && this._parent.setState("jumpFwd");
            return;
          }
          if (t._keys.backward) {
            this._parent.setState("walk_bwd");
            return;
          }
          this._parent.setState("idle");
        }
      }
      class lL extends Rn {
        constructor(e) {
          super(e);
        }
        get Name() {
          return "walk_bwd";
        }
        enter(e) {
          const t = this._parent._proxy._animations.walk_bwd.action;
          if (e) {
            const i = this._parent._proxy._animations[e.Name].action;
            if (t.enabled = true, e.Name == "run_bwd") {
              const n = t.getClip().duration / i.getClip().duration;
              t.time = i.time * n;
            } else t.time = 0, t.setEffectiveTimeScale(1), t.setEffectiveWeight(1);
            t.crossFadeFrom(i, 0.5, true), t.play();
          } else t.play();
        }
        exit() {
        }
        update(e, t) {
          if (t._keys.backward) {
            if (t._keys.limitAreaReachedAct) {
              this._parent.setState("end_area");
              return;
            }
            t._keys.shift && this._parent.setState("run_bwd"), t._keys.ctrl && this._parent.setState("jumpBwd");
            return;
          }
          if (t._keys.forward) {
            this._parent.setState("walk_fwd");
            return;
          }
          this._parent.setState("idle");
        }
      }
      class QA {
        constructor() {
          this._index;
        }
        getRandomIndex(e) {
          if (e.length) return this._index = Math.floor(Math.random() * e.length), this._index;
        }
      }
      class hL extends Rn {
        constructor(e) {
          super(e), this._actionIndexRandomizer = new QA().getRandomIndex, this._updateActionIndex(), this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return this._curActionName;
        }
        _updateActionIndex() {
          this._actionIndex = this._actionIndexRandomizer(dh), this._curActionName = dh[this._actionIndex];
        }
        enter(e) {
          this._parent.keys.actionsAllowed = false, this._updateActionIndex();
          const t = this._parent._proxy._animations[this._curActionName].action;
          if (t.getMixer().addEventListener("finished", this._finishedCallback), e) {
            const n = this._parent._proxy._animations[e.Name].action;
            t.reset(), t.setLoop(Lo, 1), t.clampWhenFinished = true, t.crossFadeFrom(n, 0.2, true), t.play();
          } else t.play();
        }
        _finished() {
          this._cleanup(), this._parent.setState("idle");
        }
        _cleanup() {
          this._parent._proxy._animations[this._curActionName].action.getMixer().removeEventListener("finished", this._finishedCallback), this._parent.keys.actionsAllowed = true;
        }
        exit() {
          this._cleanup();
        }
        update() {
        }
      }
      class dL extends Rn {
        constructor(e) {
          super(e);
        }
        get Name() {
          return "idle";
        }
        enter(e) {
          const t = this._parent._proxy._animations.idle.action;
          if (e) {
            const i = this._parent._proxy._animations[e.Name].action;
            t.time = 0, t.enabled = true, t.setEffectiveTimeScale(1), t.setEffectiveWeight(1), t.crossFadeFrom(i, 0.5, true), t.play();
          } else t.play();
        }
        exit() {
        }
        update(e, t) {
          t._keys.forward ? this._parent.setState("walk_fwd") : t._keys.backward ? this._parent.setState("walk_bwd") : t._keys.ctrl ? this._parent.setState("jumpStand") : t._keys.action && this._parent.setState("action");
        }
      }
      class uL extends Rn {
        constructor(e) {
          super(e), this._actionIndexRandomizer = new QA().getRandomIndex, this._updateActionIndex(), this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return this._curActionName;
        }
        _updateActionIndex() {
          this._actionIndex = this._actionIndexRandomizer(uh), this._curActionName = uh[this._actionIndex];
        }
        enter(e) {
          this._parent.keys.actionsAllowed = false, this._parent.keys.selfieMode = true, this._updateActionIndex();
          const t = this._parent._proxy._animations[this._curActionName].action;
          if (t.getMixer().addEventListener("finished", this._finishedCallback), e) {
            const n = this._parent._proxy._animations[e.Name].action;
            t.reset(), t.setLoop(Lo, 1), t.clampWhenFinished = true, t.crossFadeFrom(n, 0.2, true), t.play();
          } else t.play();
        }
        _finished() {
          this._cleanup(), this._parent.setState("lim_area_walk_fwd"), setTimeout(() => {
            this._parent.keys.selfieMode = false;
          }, 2e3);
        }
        _cleanup() {
          this._parent._proxy._animations.end_area.action.getMixer().removeEventListener("finished", this._finishedCallback);
        }
        exit() {
        }
        update(e, t) {
        }
      }
      class fL extends Rn {
        constructor(e) {
          super(e), this._finishedCallback = () => {
            this._finished();
          };
        }
        get Name() {
          return "lim_area_walk_fwd";
        }
        enter(e) {
          this._parent.keys.limitAreaWalk = true, this._parent.keys.limitAreaTurn = true;
          const t = this._parent._proxy._animations.lim_area_walk_fwd.action;
          if (e) {
            const i = this._parent._proxy._animations[e.Name].action;
            t.enabled = true, t.time = 0, t.setEffectiveTimeScale(1), t.setEffectiveWeight(1), t.crossFadeFrom(i, 0.5, true), t.play();
          } else t.play();
        }
        exit() {
        }
        update(e, t) {
          t._keys.limitAreaWalk || this._parent.setState("idle");
        }
      }
      class pL {
        constructor() {
          this._states = {}, this._currentState = null;
        }
        _addState(e, t) {
          this._states[e] = t;
        }
        _resetKeys() {
          for (const e in this.keys) e === "actionsAllowed" || e === "limitAreaWalk" || e === "limitAreaTurn" || e === "selfieMode" || (this.keys[e] = false);
        }
        setState(e) {
          const t = this._currentState;
          if (t) {
            if (t.Name == e) return;
            t.exit();
          }
          const i = new this._states[e](this);
          this._currentState = i, i.enter(t);
        }
        update(e, t) {
          this.keys.actionsAllowed || this._resetKeys(), this._currentState && this._currentState.update(e, t);
        }
      }
      class AL extends pL {
        constructor(e, t) {
          super(), this._proxy = e, this.keys = t, this._initStates();
        }
        _initStates() {
          this._addState("idle", dL), this._addState("walk_fwd", cL), this._addState("walk_bwd", lL), this._addState("run_fwd", aL), this._addState("run_bwd", oL), this._addState("action", hL), this._addState("jumpStand", nL), this._addState("jumpBwd", sL), this._addState("jumpFwd", rL), this._addState("end_area", uL), this._addState("lim_area_walk_fwd", fL);
        }
      }
      var Pi = Uint8Array, jr = Uint16Array, gL = Int32Array, OA = new Pi([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        0,
        0,
        0,
        0
      ]), zA = new Pi([
        0,
        0,
        0,
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        4,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        8,
        8,
        9,
        9,
        10,
        10,
        11,
        11,
        12,
        12,
        13,
        13,
        0,
        0
      ]), _L = new Pi([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      ]), GA = function(s, e) {
        for (var t = new jr(31), i = 0; i < 31; ++i) t[i] = e += 1 << s[i - 1];
        for (var n = new gL(t[30]), i = 1; i < 30; ++i) for (var r = t[i]; r < t[i + 1]; ++r) n[r] = r - t[i] << 5 | i;
        return {
          b: t,
          r: n
        };
      }, HA = GA(OA, 2), VA = HA.b, mL = HA.r;
      VA[28] = 258, mL[258] = 28;
      var wL = GA(zA, 0), bL = wL.b, fh = new jr(32768);
      for (var vt = 0; vt < 32768; ++vt) {
        var Qn = (vt & 43690) >> 1 | (vt & 21845) << 1;
        Qn = (Qn & 52428) >> 2 | (Qn & 13107) << 2, Qn = (Qn & 61680) >> 4 | (Qn & 3855) << 4, fh[vt] = ((Qn & 65280) >> 8 | (Qn & 255) << 8) >> 1;
      }
      var Us = function(s, e, t) {
        for (var i = s.length, n = 0, r = new jr(e); n < i; ++n) s[n] && ++r[s[n] - 1];
        var a = new jr(e);
        for (n = 1; n < e; ++n) a[n] = a[n - 1] + r[n - 1] << 1;
        var o;
        if (t) {
          o = new jr(1 << e);
          var c = 15 - e;
          for (n = 0; n < i; ++n) if (s[n]) for (var l = n << 4 | s[n], h = e - s[n], d = a[s[n] - 1]++ << h, u = d | (1 << h) - 1; d <= u; ++d) o[fh[d] >> c] = l;
        } else for (o = new jr(i), n = 0; n < i; ++n) s[n] && (o[n] = fh[a[s[n] - 1]++] >> 15 - s[n]);
        return o;
      }, ua = new Pi(288);
      for (var vt = 0; vt < 144; ++vt) ua[vt] = 8;
      for (var vt = 144; vt < 256; ++vt) ua[vt] = 9;
      for (var vt = 256; vt < 280; ++vt) ua[vt] = 7;
      for (var vt = 280; vt < 288; ++vt) ua[vt] = 8;
      var WA = new Pi(32);
      for (var vt = 0; vt < 32; ++vt) WA[vt] = 5;
      var yL = Us(ua, 9, 1), xL = Us(WA, 5, 1), ol = function(s) {
        for (var e = s[0], t = 1; t < s.length; ++t) s[t] > e && (e = s[t]);
        return e;
      }, Vi = function(s, e, t) {
        var i = e / 8 | 0;
        return (s[i] | s[i + 1] << 8) >> (e & 7) & t;
      }, cl = function(s, e) {
        var t = e / 8 | 0;
        return (s[t] | s[t + 1] << 8 | s[t + 2] << 16) >> (e & 7);
      }, EL = function(s) {
        return (s + 7) / 8 | 0;
      }, vL = function(s, e, t) {
        return (t == null || t > s.length) && (t = s.length), new Pi(s.subarray(e, t));
      }, SL = [
        "unexpected EOF",
        "invalid block type",
        "invalid length/literal",
        "invalid distance",
        "stream finished",
        "no stream handler",
        ,
        "no callback",
        "invalid UTF-8 data",
        "extra field too long",
        "date not in range 1980-2099",
        "filename too long",
        "stream finishing",
        "invalid zip data"
      ], ji = function(s, e, t) {
        var i = new Error(e || SL[s]);
        if (i.code = s, Error.captureStackTrace && Error.captureStackTrace(i, ji), !t) throw i;
        return i;
      }, CL = function(s, e, t, i) {
        var n = s.length, r = 0;
        if (!n || e.f && !e.l) return t || new Pi(0);
        var a = !t, o = a || e.i != 2, c = e.i;
        a && (t = new Pi(n * 3));
        var l = function(St) {
          var wt = t.length;
          if (St > wt) {
            var Ke = new Pi(Math.max(wt * 2, St));
            Ke.set(t), t = Ke;
          }
        }, h = e.f || 0, d = e.p || 0, u = e.b || 0, f = e.l, p = e.d, m = e.m, g = e.n, A = n * 8;
        do {
          if (!f) {
            h = Vi(s, d, 1);
            var x = Vi(s, d + 1, 3);
            if (d += 3, x) if (x == 1) f = yL, p = xL, m = 9, g = 5;
            else if (x == 2) {
              var M = Vi(s, d, 31) + 257, R = Vi(s, d + 10, 15) + 4, D = M + Vi(s, d + 5, 31) + 1;
              d += 14;
              for (var S = new Pi(D), E = new Pi(19), P = 0; P < R; ++P) E[_L[P]] = Vi(s, d + P * 3, 7);
              d += R * 3;
              for (var j = ol(E), H = (1 << j) - 1, Y = Us(E, j, 1), P = 0; P < D; ) {
                var te = Y[Vi(s, d, H)];
                d += te & 15;
                var b = te >> 4;
                if (b < 16) S[P++] = b;
                else {
                  var q = 0, Z = 0;
                  for (b == 16 ? (Z = 3 + Vi(s, d, 3), d += 2, q = S[P - 1]) : b == 17 ? (Z = 3 + Vi(s, d, 7), d += 3) : b == 18 && (Z = 11 + Vi(s, d, 127), d += 7); Z--; ) S[P++] = q;
                }
              }
              var V = S.subarray(0, M), re = S.subarray(M);
              m = ol(V), g = ol(re), f = Us(V, m, 1), p = Us(re, g, 1);
            } else ji(1);
            else {
              var b = EL(d) + 4, y = s[b - 4] | s[b - 3] << 8, I = b + y;
              if (I > n) {
                c && ji(0);
                break;
              }
              o && l(u + y), t.set(s.subarray(b, I), u), e.b = u += y, e.p = d = I * 8, e.f = h;
              continue;
            }
            if (d > A) {
              c && ji(0);
              break;
            }
          }
          o && l(u + 131072);
          for (var he = (1 << m) - 1, ve = (1 << g) - 1, Pe = d; ; Pe = d) {
            var q = f[cl(s, d) & he], Ve = q >> 4;
            if (d += q & 15, d > A) {
              c && ji(0);
              break;
            }
            if (q || ji(2), Ve < 256) t[u++] = Ve;
            else if (Ve == 256) {
              Pe = d, f = null;
              break;
            } else {
              var K = Ve - 254;
              if (Ve > 264) {
                var P = Ve - 257, ae = OA[P];
                K = Vi(s, d, (1 << ae) - 1) + VA[P], d += ae;
              }
              var be = p[cl(s, d) & ve], le = be >> 4;
              be || ji(3), d += be & 15;
              var re = bL[le];
              if (le > 3) {
                var ae = zA[le];
                re += cl(s, d) & (1 << ae) - 1, d += ae;
              }
              if (d > A) {
                c && ji(0);
                break;
              }
              o && l(u + 131072);
              var Te = u + K;
              if (u < re) {
                var Ze = r - re, Le = Math.min(re, Te);
                for (Ze + u < 0 && ji(3); u < Le; ++u) t[u] = i[Ze + u];
              }
              for (; u < Te; ++u) t[u] = t[u - re];
            }
          }
          e.l = f, e.p = Pe, e.b = u, e.f = h, f && (h = 1, e.m = m, e.d = p, e.n = g);
        } while (!h);
        return u != t.length && a ? vL(t, 0, u) : t.subarray(0, u);
      }, IL = new Pi(0), ML = function(s, e) {
        return ((s[0] & 15) != 8 || s[0] >> 4 > 7 || (s[0] << 8 | s[1]) % 31) && ji(6, "invalid zlib data"), (s[1] >> 5 & 1) == 1 && ji(6, "invalid zlib data: " + (s[1] & 32 ? "need" : "unexpected") + " dictionary"), (s[1] >> 3 & 4) + 2;
      };
      function TL(s, e) {
        return CL(s.subarray(ML(s), -4), {
          i: 2
        }, e, e);
      }
      var RL = typeof TextDecoder < "u" && new TextDecoder(), BL = 0;
      try {
        RL.decode(IL, {
          stream: true
        }), BL = 1;
      } catch {
      }
      function jA(s, e, t) {
        const i = t.length - s - 1;
        if (e >= t[i]) return i - 1;
        if (e <= t[s]) return s;
        let n = s, r = i, a = Math.floor((n + r) / 2);
        for (; e < t[a] || e >= t[a + 1]; ) e < t[a] ? r = a : n = a, a = Math.floor((n + r) / 2);
        return a;
      }
      function DL(s, e, t, i) {
        const n = [], r = [], a = [];
        n[0] = 1;
        for (let o = 1; o <= t; ++o) {
          r[o] = e - i[s + 1 - o], a[o] = i[s + o] - e;
          let c = 0;
          for (let l = 0; l < o; ++l) {
            const h = a[l + 1], d = r[o - l], u = n[l] / (h + d);
            n[l] = c + h * u, c = d * u;
          }
          n[o] = c;
        }
        return n;
      }
      function PL(s, e, t, i) {
        const n = jA(s, i, e), r = DL(n, i, s, e), a = new je(0, 0, 0, 0);
        for (let o = 0; o <= s; ++o) {
          const c = t[n - s + o], l = r[o], h = c.w * l;
          a.x += c.x * h, a.y += c.y * h, a.z += c.z * h, a.w += c.w * l;
        }
        return a;
      }
      function LL(s, e, t, i, n) {
        const r = [];
        for (let d = 0; d <= t; ++d) r[d] = 0;
        const a = [];
        for (let d = 0; d <= i; ++d) a[d] = r.slice(0);
        const o = [];
        for (let d = 0; d <= t; ++d) o[d] = r.slice(0);
        o[0][0] = 1;
        const c = r.slice(0), l = r.slice(0);
        for (let d = 1; d <= t; ++d) {
          c[d] = e - n[s + 1 - d], l[d] = n[s + d] - e;
          let u = 0;
          for (let f = 0; f < d; ++f) {
            const p = l[f + 1], m = c[d - f];
            o[d][f] = p + m;
            const g = o[f][d - 1] / o[d][f];
            o[f][d] = u + p * g, u = m * g;
          }
          o[d][d] = u;
        }
        for (let d = 0; d <= t; ++d) a[0][d] = o[d][t];
        for (let d = 0; d <= t; ++d) {
          let u = 0, f = 1;
          const p = [];
          for (let m = 0; m <= t; ++m) p[m] = r.slice(0);
          p[0][0] = 1;
          for (let m = 1; m <= i; ++m) {
            let g = 0;
            const A = d - m, x = t - m;
            d >= m && (p[f][0] = p[u][0] / o[x + 1][A], g = p[f][0] * o[A][x]);
            const b = A >= -1 ? 1 : -A, y = d - 1 <= x ? m - 1 : t - d;
            for (let M = b; M <= y; ++M) p[f][M] = (p[u][M] - p[u][M - 1]) / o[x + 1][A + M], g += p[f][M] * o[A + M][x];
            d <= x && (p[f][m] = -p[u][m - 1] / o[x + 1][d], g += p[f][m] * o[d][x]), a[m][d] = g;
            const I = u;
            u = f, f = I;
          }
        }
        let h = t;
        for (let d = 1; d <= i; ++d) {
          for (let u = 0; u <= t; ++u) a[d][u] *= h;
          h *= t - d;
        }
        return a;
      }
      function FL(s, e, t, i, n) {
        const r = n < s ? n : s, a = [], o = jA(s, i, e), c = LL(o, i, s, r, e), l = [];
        for (let h = 0; h < t.length; ++h) {
          const d = t[h].clone(), u = d.w;
          d.x *= u, d.y *= u, d.z *= u, l[h] = d;
        }
        for (let h = 0; h <= r; ++h) {
          const d = l[o - s].clone().multiplyScalar(c[h][0]);
          for (let u = 1; u <= s; ++u) d.add(l[o - s + u].clone().multiplyScalar(c[h][u]));
          a[h] = d;
        }
        for (let h = r + 1; h <= n + 1; ++h) a[h] = new je(0, 0, 0);
        return a;
      }
      function kL(s, e) {
        let t = 1;
        for (let n = 2; n <= s; ++n) t *= n;
        let i = 1;
        for (let n = 2; n <= e; ++n) i *= n;
        for (let n = 2; n <= s - e; ++n) i *= n;
        return t / i;
      }
      function UL(s) {
        const e = s.length, t = [], i = [];
        for (let r = 0; r < e; ++r) {
          const a = s[r];
          t[r] = new T(a.x, a.y, a.z), i[r] = a.w;
        }
        const n = [];
        for (let r = 0; r < e; ++r) {
          const a = t[r].clone();
          for (let o = 1; o <= r; ++o) a.sub(n[r - o].clone().multiplyScalar(kL(r, o) * i[o]));
          n[r] = a.divideScalar(i[0]);
        }
        return n;
      }
      function NL(s, e, t, i, n) {
        const r = FL(s, e, t, i, n);
        return UL(r);
      }
      class QL extends Ni {
        constructor(e, t, i, n, r) {
          super();
          const a = t ? t.length - 1 : 0, o = i ? i.length : 0;
          this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = n || 0, this.endKnot = r || a;
          for (let c = 0; c < o; ++c) {
            const l = i[c];
            this.controlPoints[c] = new je(l.x, l.y, l.z, l.w);
          }
        }
        getPoint(e, t = new T()) {
          const i = t, n = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), r = PL(this.degree, this.knots, this.controlPoints, n);
          return r.w !== 1 && r.divideScalar(r.w), i.set(r.x, r.y, r.z);
        }
        getTangent(e, t = new T()) {
          const i = t, n = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), r = NL(this.degree, this.knots, this.controlPoints, n, 1);
          return i.copy(r[1]).normalize(), i;
        }
        toJSON() {
          const e = super.toJSON();
          return e.degree = this.degree, e.knots = [
            ...this.knots
          ], e.controlPoints = this.controlPoints.map((t) => t.toArray()), e.startKnot = this.startKnot, e.endKnot = this.endKnot, e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.degree = e.degree, this.knots = [
            ...e.knots
          ], this.controlPoints = e.controlPoints.map((t) => new je(t[0], t[1], t[2], t[3])), this.startKnot = e.startKnot, this.endKnot = e.endKnot, this;
        }
      }
      let Xe, Pt, ui;
      class OL extends Ui {
        constructor(e) {
          super(e);
        }
        load(e, t, i, n) {
          const r = this, a = r.path === "" ? Kr.extractUrlBase(e) : r.path, o = new fr(this.manager);
          o.setPath(r.path), o.setResponseType("arraybuffer"), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(c) {
            try {
              t(r.parse(c, a));
            } catch (l) {
              n ? n(l) : console.error(l), r.manager.itemError(e);
            }
          }, i, n);
        }
        parse(e, t) {
          if (jL(e)) Xe = new WL().parse(e);
          else {
            const n = YA(e);
            if (!qL(n)) throw new Error("THREE.FBXLoader: Unknown format.");
            if (Uf(n) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Uf(n));
            Xe = new VL().parse(n);
          }
          const i = new Si(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
          return new zL(i, this.manager).parse(Xe);
        }
      }
      class zL {
        constructor(e, t) {
          this.textureLoader = e, this.manager = t;
        }
        parse() {
          Pt = this.parseConnections();
          const e = this.parseImages(), t = this.parseTextures(e), i = this.parseMaterials(t), n = this.parseDeformers(), r = new GL().parse(n);
          return this.parseScene(n, r, i), ui;
        }
        parseConnections() {
          const e = /* @__PURE__ */ new Map();
          return "Connections" in Xe && Xe.Connections.connections.forEach(function(i) {
            const n = i[0], r = i[1], a = i[2];
            e.has(n) || e.set(n, {
              parents: [],
              children: []
            });
            const o = {
              ID: r,
              relationship: a
            };
            e.get(n).parents.push(o), e.has(r) || e.set(r, {
              parents: [],
              children: []
            });
            const c = {
              ID: n,
              relationship: a
            };
            e.get(r).children.push(c);
          }), e;
        }
        parseImages() {
          const e = {}, t = {};
          if ("Video" in Xe.Objects) {
            const i = Xe.Objects.Video;
            for (const n in i) {
              const r = i[n], a = parseInt(n);
              if (e[a] = r.RelativeFilename || r.Filename, "Content" in r) {
                const o = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0, c = typeof r.Content == "string" && r.Content !== "";
                if (o || c) {
                  const l = this.parseImage(i[n]);
                  t[r.RelativeFilename || r.Filename] = l;
                }
              }
            }
          }
          for (const i in e) {
            const n = e[i];
            t[n] !== void 0 ? e[i] = t[n] : e[i] = e[i].split("\\").pop();
          }
          return e;
        }
        parseImage(e) {
          const t = e.Content, i = e.RelativeFilename || e.Filename, n = i.slice(i.lastIndexOf(".") + 1).toLowerCase();
          let r;
          switch (n) {
            case "bmp":
              r = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              r = "image/jpeg";
              break;
            case "png":
              r = "image/png";
              break;
            case "tif":
              r = "image/tiff";
              break;
            case "tga":
              this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", i), r = "image/tga";
              break;
            default:
              console.warn('FBXLoader: Image type "' + n + '" is not supported.');
              return;
          }
          if (typeof t == "string") return "data:" + r + ";base64," + t;
          {
            const a = new Uint8Array(t);
            return window.URL.createObjectURL(new Blob([
              a
            ], {
              type: r
            }));
          }
        }
        parseTextures(e) {
          const t = /* @__PURE__ */ new Map();
          if ("Texture" in Xe.Objects) {
            const i = Xe.Objects.Texture;
            for (const n in i) {
              const r = this.parseTexture(i[n], e);
              t.set(parseInt(n), r);
            }
          }
          return t;
        }
        parseTexture(e, t) {
          const i = this.loadTexture(e, t);
          i.ID = e.id, i.name = e.attrName;
          const n = e.WrapModeU, r = e.WrapModeV, a = n !== void 0 ? n.value : 0, o = r !== void 0 ? r.value : 0;
          if (i.wrapS = a === 0 ? mi : fi, i.wrapT = o === 0 ? mi : fi, "Scaling" in e) {
            const c = e.Scaling.value;
            i.repeat.x = c[0], i.repeat.y = c[1];
          }
          if ("Translation" in e) {
            const c = e.Translation.value;
            i.offset.x = c[0], i.offset.y = c[1];
          }
          return i;
        }
        loadTexture(e, t) {
          const i = /* @__PURE__ */ new Set([
            "tga",
            "tif",
            "tiff",
            "exr",
            "dds",
            "hdr",
            "ktx2"
          ]), n = e.FileName.split(".").pop().toLowerCase(), r = i.has(n) ? this.manager.getHandler(`.${n}`) : this.textureLoader;
          if (!r) return console.warn(`FBXLoader: ${n.toUpperCase()} loader not found, creating placeholder texture for`, e.RelativeFilename), new Nt();
          const a = r.path;
          a || r.setPath(this.textureLoader.path);
          const o = Pt.get(e.id).children;
          let c;
          o !== void 0 && o.length > 0 && t[o[0].ID] !== void 0 && (c = t[o[0].ID], (c.indexOf("blob:") === 0 || c.indexOf("data:") === 0) && r.setPath(void 0));
          const l = r.load(c);
          return r.setPath(a), l;
        }
        parseMaterials(e) {
          const t = /* @__PURE__ */ new Map();
          if ("Material" in Xe.Objects) {
            const i = Xe.Objects.Material;
            for (const n in i) {
              const r = this.parseMaterial(i[n], e);
              r !== null && t.set(parseInt(n), r);
            }
          }
          return t;
        }
        parseMaterial(e, t) {
          const i = e.id, n = e.attrName;
          let r = e.ShadingModel;
          if (typeof r == "object" && (r = r.value), !Pt.has(i)) return null;
          const a = this.parseParameters(e, t, i);
          let o;
          switch (r.toLowerCase()) {
            case "phong":
              o = new za();
              break;
            case "lambert":
              o = new Em();
              break;
            default:
              console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r), o = new za();
              break;
          }
          return o.setValues(a), o.name = n, o;
        }
        parseParameters(e, t, i) {
          const n = {};
          e.BumpFactor && (n.bumpScale = e.BumpFactor.value), e.Diffuse ? n.color = ze.toWorkingColorSpace(new ue().fromArray(e.Diffuse.value), nt) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (n.color = ze.toWorkingColorSpace(new ue().fromArray(e.DiffuseColor.value), nt)), e.DisplacementFactor && (n.displacementScale = e.DisplacementFactor.value), e.Emissive ? n.emissive = ze.toWorkingColorSpace(new ue().fromArray(e.Emissive.value), nt) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (n.emissive = ze.toWorkingColorSpace(new ue().fromArray(e.EmissiveColor.value), nt)), e.EmissiveFactor && (n.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), n.opacity = 1 - (e.TransparencyFactor ? parseFloat(e.TransparencyFactor.value) : 0), (n.opacity === 1 || n.opacity === 0) && (n.opacity = e.Opacity ? parseFloat(e.Opacity.value) : null, n.opacity === null && (n.opacity = 1 - (e.TransparentColor ? parseFloat(e.TransparentColor.value[0]) : 0))), n.opacity < 1 && (n.transparent = true), e.ReflectionFactor && (n.reflectivity = e.ReflectionFactor.value), e.Shininess && (n.shininess = e.Shininess.value), e.Specular ? n.specular = ze.toWorkingColorSpace(new ue().fromArray(e.Specular.value), nt) : e.SpecularColor && e.SpecularColor.type === "Color" && (n.specular = ze.toWorkingColorSpace(new ue().fromArray(e.SpecularColor.value), nt));
          const r = this;
          return Pt.get(i).children.forEach(function(a) {
            const o = a.relationship;
            switch (o) {
              case "Bump":
                n.bumpMap = r.getTexture(t, a.ID);
                break;
              case "Maya|TEX_ao_map":
                n.aoMap = r.getTexture(t, a.ID);
                break;
              case "DiffuseColor":
              case "Maya|TEX_color_map":
                n.map = r.getTexture(t, a.ID), n.map !== void 0 && (n.map.colorSpace = nt);
                break;
              case "DisplacementColor":
                n.displacementMap = r.getTexture(t, a.ID);
                break;
              case "EmissiveColor":
                n.emissiveMap = r.getTexture(t, a.ID), n.emissiveMap !== void 0 && (n.emissiveMap.colorSpace = nt);
                break;
              case "NormalMap":
              case "Maya|TEX_normal_map":
                n.normalMap = r.getTexture(t, a.ID);
                break;
              case "ReflectionColor":
                n.envMap = r.getTexture(t, a.ID), n.envMap !== void 0 && (n.envMap.mapping = lo, n.envMap.colorSpace = nt);
                break;
              case "SpecularColor":
                n.specularMap = r.getTexture(t, a.ID), n.specularMap !== void 0 && (n.specularMap.colorSpace = nt);
                break;
              case "TransparentColor":
              case "TransparencyFactor":
                n.alphaMap = r.getTexture(t, a.ID), n.transparent = true;
                break;
              case "AmbientColor":
              case "ShininessExponent":
              case "SpecularFactor":
              case "VectorDisplacementColor":
              default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", o);
                break;
            }
          }), n;
        }
        getTexture(e, t) {
          return "LayeredTexture" in Xe.Objects && t in Xe.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = Pt.get(t).children[0].ID), e.get(t);
        }
        parseDeformers() {
          const e = {}, t = {};
          if ("Deformer" in Xe.Objects) {
            const i = Xe.Objects.Deformer;
            for (const n in i) {
              const r = i[n], a = Pt.get(parseInt(n));
              if (r.attrType === "Skin") {
                const o = this.parseSkeleton(a, i);
                o.ID = n, a.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), o.geometryID = a.parents[0].ID, e[n] = o;
              } else if (r.attrType === "BlendShape") {
                const o = {
                  id: n
                };
                o.rawTargets = this.parseMorphTargets(a, i), o.id = n, a.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[n] = o;
              }
            }
          }
          return {
            skeletons: e,
            morphTargets: t
          };
        }
        parseSkeleton(e, t) {
          const i = [];
          return e.children.forEach(function(n) {
            const r = t[n.ID];
            if (r.attrType !== "Cluster") return;
            const a = {
              ID: n.ID,
              indices: [],
              weights: [],
              transformLink: new ge().fromArray(r.TransformLink.a)
            };
            "Indexes" in r && (a.indices = r.Indexes.a, a.weights = r.Weights.a), i.push(a);
          }), {
            rawBones: i,
            bones: []
          };
        }
        parseMorphTargets(e, t) {
          const i = [];
          for (let n = 0; n < e.children.length; n++) {
            const r = e.children[n], a = t[r.ID], o = {
              name: a.attrName,
              initialWeight: a.DeformPercent,
              id: a.id,
              fullWeights: a.FullWeights.a
            };
            if (a.attrType !== "BlendShapeChannel") return;
            o.geoID = Pt.get(parseInt(r.ID)).children.filter(function(c) {
              return c.relationship === void 0;
            })[0].ID, i.push(o);
          }
          return i;
        }
        parseScene(e, t, i) {
          ui = new Li();
          const n = this.parseModels(e.skeletons, t, i), r = Xe.Objects.Model, a = this;
          n.forEach(function(c) {
            const l = r[c.ID];
            a.setLookAtProperties(c, l), Pt.get(c.ID).parents.forEach(function(d) {
              const u = n.get(d.ID);
              u !== void 0 && u.add(c);
            }), c.parent === null && ui.add(c);
          }), this.bindSkeleton(e.skeletons, t, n), this.addGlobalSceneSettings(), ui.traverse(function(c) {
            if (c.userData.transformData) {
              c.parent && (c.userData.transformData.parentMatrix = c.parent.matrix, c.userData.transformData.parentMatrixWorld = c.parent.matrixWorld);
              const l = XA(c.userData.transformData);
              c.applyMatrix4(l), c.updateWorldMatrix();
            }
          });
          const o = new HL().parse();
          ui.children.length === 1 && ui.children[0].isGroup && (ui.children[0].animations = o, ui = ui.children[0]), ui.animations = o;
        }
        parseModels(e, t, i) {
          const n = /* @__PURE__ */ new Map(), r = Xe.Objects.Model;
          for (const a in r) {
            const o = parseInt(a), c = r[a], l = Pt.get(o);
            let h = this.buildSkeleton(l, e, o, c.attrName);
            if (!h) {
              switch (c.attrType) {
                case "Camera":
                  h = this.createCamera(l);
                  break;
                case "Light":
                  h = this.createLight(l);
                  break;
                case "Mesh":
                  h = this.createMesh(l, t, i);
                  break;
                case "NurbsCurve":
                  h = this.createCurve(l, t);
                  break;
                case "LimbNode":
                case "Root":
                  h = new qs();
                  break;
                case "Null":
                default:
                  h = new Li();
                  break;
              }
              h.name = c.attrName ? tt.sanitizeNodeName(c.attrName) : "", h.userData.originalName = c.attrName, h.ID = o;
            }
            this.getTransformData(h, c), n.set(o, h);
          }
          return n;
        }
        buildSkeleton(e, t, i, n) {
          let r = null;
          return e.parents.forEach(function(a) {
            for (const o in t) {
              const c = t[o];
              c.rawBones.forEach(function(l, h) {
                if (l.ID === a.ID) {
                  const d = r;
                  r = new qs(), r.matrixWorld.copy(l.transformLink), r.name = n ? tt.sanitizeNodeName(n) : "", r.userData.originalName = n, r.ID = i, c.bones[h] = r, d !== null && r.add(d);
                }
              });
            }
          }), r;
        }
        createCamera(e) {
          let t, i;
          if (e.children.forEach(function(n) {
            const r = Xe.Objects.NodeAttribute[n.ID];
            r !== void 0 && (i = r);
          }), i === void 0) t = new ct();
          else {
            let n = 0;
            i.CameraProjectionType !== void 0 && i.CameraProjectionType.value === 1 && (n = 1);
            let r = 1;
            i.NearPlane !== void 0 && (r = i.NearPlane.value / 1e3);
            let a = 1e3;
            i.FarPlane !== void 0 && (a = i.FarPlane.value / 1e3);
            let o = window.innerWidth, c = window.innerHeight;
            i.AspectWidth !== void 0 && i.AspectHeight !== void 0 && (o = i.AspectWidth.value, c = i.AspectHeight.value);
            const l = o / c;
            let h = 45;
            i.FieldOfView !== void 0 && (h = i.FieldOfView.value);
            const d = i.FocalLength ? i.FocalLength.value : null;
            switch (n) {
              case 0:
                t = new Vt(h, l, r, a), d !== null && t.setFocalLength(d);
                break;
              case 1:
                console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."), t = new ct();
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + n + "."), t = new ct();
                break;
            }
          }
          return t;
        }
        createLight(e) {
          let t, i;
          if (e.children.forEach(function(n) {
            const r = Xe.Objects.NodeAttribute[n.ID];
            r !== void 0 && (i = r);
          }), i === void 0) t = new ct();
          else {
            let n;
            i.LightType === void 0 ? n = 0 : n = i.LightType.value;
            let r = 16777215;
            i.Color !== void 0 && (r = ze.toWorkingColorSpace(new ue().fromArray(i.Color.value), nt));
            let a = i.Intensity === void 0 ? 1 : i.Intensity.value / 100;
            i.CastLightOnObject !== void 0 && i.CastLightOnObject.value === 0 && (a = 0);
            let o = 0;
            i.FarAttenuationEnd !== void 0 && (i.EnableFarAttenuation !== void 0 && i.EnableFarAttenuation.value === 0 ? o = 0 : o = i.FarAttenuationEnd.value);
            const c = 1;
            switch (n) {
              case 0:
                t = new Wl(r, a, o, c);
                break;
              case 1:
                t = new Oo(r, a);
                break;
              case 2:
                let l = Math.PI / 3;
                i.InnerAngle !== void 0 && (l = Ut.degToRad(i.InnerAngle.value));
                let h = 0;
                i.OuterAngle !== void 0 && (h = Ut.degToRad(i.OuterAngle.value), h = Math.max(h, 1)), t = new Ep(r, a, o, l, h, c);
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown light type " + i.LightType.value + ", defaulting to a PointLight."), t = new Wl(r, a);
                break;
            }
            i.CastShadows !== void 0 && i.CastShadows.value === 1 && (t.castShadow = true);
          }
          return t;
        }
        createMesh(e, t, i) {
          let n, r = null, a = null;
          const o = [];
          if (e.children.forEach(function(c) {
            t.has(c.ID) && (r = t.get(c.ID)), i.has(c.ID) && o.push(i.get(c.ID));
          }), o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new za({
            name: Ui.DEFAULT_MATERIAL_NAME,
            color: 13421772
          }), o.push(a)), "color" in r.attributes && o.forEach(function(c) {
            c.vertexColors = true;
          }), r.groups.length > 0) {
            let c = false;
            for (let l = 0, h = r.groups.length; l < h; l++) {
              const d = r.groups[l];
              (d.materialIndex < 0 || d.materialIndex >= o.length) && (d.materialIndex = o.length, c = true);
            }
            if (c) {
              const l = new za();
              o.push(l);
            }
          }
          return r.FBX_Deformer ? (n = new Mh(r, a), n.normalizeSkinWeights()) : n = new yt(r, a), n;
        }
        createCurve(e, t) {
          const i = e.children.reduce(function(r, a) {
            return t.has(a.ID) && (r = t.get(a.ID)), r;
          }, null), n = new oa({
            name: Ui.DEFAULT_MATERIAL_NAME,
            color: 3342591,
            linewidth: 1
          });
          return new is(i, n);
        }
        getTransformData(e, t) {
          const i = {};
          "InheritType" in t && (i.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? i.eulerOrder = ra(t.RotationOrder.value) : i.eulerOrder = ra(0), "Lcl_Translation" in t && (i.translation = t.Lcl_Translation.value), "PreRotation" in t && (i.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (i.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (i.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (i.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (i.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (i.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (i.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (i.rotationPivot = t.RotationPivot.value), e.userData.transformData = i;
        }
        setLookAtProperties(e, t) {
          "LookAtProperty" in t && Pt.get(e.ID).children.forEach(function(n) {
            if (n.relationship === "LookAtProperty") {
              const r = Xe.Objects.Model[n.ID];
              if ("Lcl_Translation" in r) {
                const a = r.Lcl_Translation.value;
                e.target !== void 0 ? (e.target.position.fromArray(a), ui.add(e.target)) : e.lookAt(new T().fromArray(a));
              }
            }
          });
        }
        bindSkeleton(e, t, i) {
          const n = this.parsePoseNodes();
          for (const r in e) {
            const a = e[r];
            Pt.get(parseInt(a.ID)).parents.forEach(function(c) {
              if (t.has(c.ID)) {
                const l = c.ID;
                Pt.get(l).parents.forEach(function(d) {
                  i.has(d.ID) && i.get(d.ID).bind(new aa(a.bones), n[d.ID]);
                });
              }
            });
          }
        }
        parsePoseNodes() {
          const e = {};
          if ("Pose" in Xe.Objects) {
            const t = Xe.Objects.Pose;
            for (const i in t) if (t[i].attrType === "BindPose" && t[i].NbPoseNodes > 0) {
              const n = t[i].PoseNode;
              Array.isArray(n) ? n.forEach(function(r) {
                e[r.Node] = new ge().fromArray(r.Matrix.a);
              }) : e[n.Node] = new ge().fromArray(n.Matrix.a);
            }
          }
          return e;
        }
        addGlobalSceneSettings() {
          if ("GlobalSettings" in Xe) {
            if ("AmbientColor" in Xe.GlobalSettings) {
              const e = Xe.GlobalSettings.AmbientColor.value, t = e[0], i = e[1], n = e[2];
              if (t !== 0 || i !== 0 || n !== 0) {
                const r = new ue().setRGB(t, i, n, nt);
                ui.add(new Nh(r, 1));
              }
            }
            "UnitScaleFactor" in Xe.GlobalSettings && (ui.userData.unitScaleFactor = Xe.GlobalSettings.UnitScaleFactor.value);
          }
        }
      }
      class GL {
        constructor() {
          this.negativeMaterialIndices = false;
        }
        parse(e) {
          const t = /* @__PURE__ */ new Map();
          if ("Geometry" in Xe.Objects) {
            const i = Xe.Objects.Geometry;
            for (const n in i) {
              const r = Pt.get(parseInt(n)), a = this.parseGeometry(r, i[n], e);
              t.set(parseInt(n), a);
            }
          }
          return this.negativeMaterialIndices === true && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t;
        }
        parseGeometry(e, t, i) {
          switch (t.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(e, t, i);
            case "NurbsCurve":
              return this.parseNurbsGeometry(t);
          }
        }
        parseMeshGeometry(e, t, i) {
          const n = i.skeletons, r = [], a = e.parents.map(function(d) {
            return Xe.Objects.Model[d.ID];
          });
          if (a.length === 0) return;
          const o = e.children.reduce(function(d, u) {
            return n[u.ID] !== void 0 && (d = n[u.ID]), d;
          }, null);
          e.children.forEach(function(d) {
            i.morphTargets[d.ID] !== void 0 && r.push(i.morphTargets[d.ID]);
          });
          const c = a[0], l = {};
          "RotationOrder" in c && (l.eulerOrder = ra(c.RotationOrder.value)), "InheritType" in c && (l.inheritType = parseInt(c.InheritType.value)), "GeometricTranslation" in c && (l.translation = c.GeometricTranslation.value), "GeometricRotation" in c && (l.rotation = c.GeometricRotation.value), "GeometricScaling" in c && (l.scale = c.GeometricScaling.value);
          const h = XA(l);
          return this.genGeometry(t, o, r, h);
        }
        genGeometry(e, t, i, n) {
          const r = new Qt();
          e.attrName && (r.name = e.attrName);
          const a = this.parseGeoNode(e, t), o = this.genBuffers(a), c = new _t(o.vertex, 3);
          if (c.applyMatrix4(n), r.setAttribute("position", c), o.colors.length > 0 && r.setAttribute("color", new _t(o.colors, 3)), t && (r.setAttribute("skinIndex", new ko(o.weightsIndices, 4)), r.setAttribute("skinWeight", new _t(o.vertexWeights, 4)), r.FBX_Deformer = t), o.normal.length > 0) {
            const l = new Oe().getNormalMatrix(n), h = new _t(o.normal, 3);
            h.applyNormalMatrix(l), r.setAttribute("normal", h);
          }
          if (o.uvs.forEach(function(l, h) {
            const d = h === 0 ? "uv" : `uv${h}`;
            r.setAttribute(d, new _t(o.uvs[h], 2));
          }), a.material && a.material.mappingType !== "AllSame") {
            let l = o.materialIndex[0], h = 0;
            if (o.materialIndex.forEach(function(d, u) {
              d !== l && (r.addGroup(h, u - h, l), l = d, h = u);
            }), r.groups.length > 0) {
              const d = r.groups[r.groups.length - 1], u = d.start + d.count;
              u !== o.materialIndex.length && r.addGroup(u, o.materialIndex.length - u, l);
            }
            r.groups.length === 0 && r.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
          }
          return this.addMorphTargets(r, e, i, n), r;
        }
        parseGeoNode(e, t) {
          const i = {};
          if (i.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], i.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (i.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (i.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (i.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
            i.uv = [];
            let n = 0;
            for (; e.LayerElementUV[n]; ) e.LayerElementUV[n].UV && i.uv.push(this.parseUVs(e.LayerElementUV[n])), n++;
          }
          return i.weightTable = {}, t !== null && (i.skeleton = t, t.rawBones.forEach(function(n, r) {
            n.indices.forEach(function(a, o) {
              i.weightTable[a] === void 0 && (i.weightTable[a] = []), i.weightTable[a].push({
                id: r,
                weight: n.weights[o]
              });
            });
          })), i;
        }
        genBuffers(e) {
          const t = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
          };
          let i = 0, n = 0, r = false, a = [], o = [], c = [], l = [], h = [], d = [];
          const u = this;
          return e.vertexIndices.forEach(function(f, p) {
            let m, g = false;
            f < 0 && (f = f ^ -1, g = true);
            let A = [], x = [];
            if (a.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
              const b = to(p, i, f, e.color);
              c.push(b[0], b[1], b[2]);
            }
            if (e.skeleton) {
              if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(b) {
                x.push(b.weight), A.push(b.id);
              }), x.length > 4) {
                r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = true);
                const b = [
                  0,
                  0,
                  0,
                  0
                ], y = [
                  0,
                  0,
                  0,
                  0
                ];
                x.forEach(function(I, M) {
                  let R = I, D = A[M];
                  y.forEach(function(S, E, P) {
                    if (R > S) {
                      P[E] = R, R = S;
                      const j = b[E];
                      b[E] = D, D = j;
                    }
                  });
                }), A = b, x = y;
              }
              for (; x.length < 4; ) x.push(0), A.push(0);
              for (let b = 0; b < 4; ++b) h.push(x[b]), d.push(A[b]);
            }
            if (e.normal) {
              const b = to(p, i, f, e.normal);
              o.push(b[0], b[1], b[2]);
            }
            e.material && e.material.mappingType !== "AllSame" && (m = to(p, i, f, e.material)[0], m < 0 && (u.negativeMaterialIndices = true, m = 0)), e.uv && e.uv.forEach(function(b, y) {
              const I = to(p, i, f, b);
              l[y] === void 0 && (l[y] = []), l[y].push(I[0]), l[y].push(I[1]);
            }), n++, g && (u.genFace(t, e, a, m, o, c, l, h, d, n), i++, n = 0, a = [], o = [], c = [], l = [], h = [], d = []);
          }), t;
        }
        getNormalNewell(e) {
          const t = new T(0, 0, 0);
          for (let i = 0; i < e.length; i++) {
            const n = e[i], r = e[(i + 1) % e.length];
            t.x += (n.y - r.y) * (n.z + r.z), t.y += (n.z - r.z) * (n.x + r.x), t.z += (n.x - r.x) * (n.y + r.y);
          }
          return t.normalize(), t;
        }
        getNormalTangentAndBitangent(e) {
          const t = this.getNormalNewell(e), n = (Math.abs(t.z) > 0.5 ? new T(0, 1, 0) : new T(0, 0, 1)).cross(t).normalize(), r = t.clone().cross(n).normalize();
          return {
            normal: t,
            tangent: n,
            bitangent: r
          };
        }
        flattenVertex(e, t, i) {
          return new oe(e.dot(t), e.dot(i));
        }
        genFace(e, t, i, n, r, a, o, c, l, h) {
          let d;
          if (h > 3) {
            const u = [], f = t.baseVertexPositions || t.vertexPositions;
            for (let A = 0; A < i.length; A += 3) u.push(new T(f[i[A]], f[i[A + 1]], f[i[A + 2]]));
            const { tangent: p, bitangent: m } = this.getNormalTangentAndBitangent(u), g = [];
            for (const A of u) g.push(this.flattenVertex(A, p, m));
            d = Lh.triangulateShape(g, []);
          } else d = [
            [
              0,
              1,
              2
            ]
          ];
          for (const [u, f, p] of d) e.vertex.push(t.vertexPositions[i[u * 3]]), e.vertex.push(t.vertexPositions[i[u * 3 + 1]]), e.vertex.push(t.vertexPositions[i[u * 3 + 2]]), e.vertex.push(t.vertexPositions[i[f * 3]]), e.vertex.push(t.vertexPositions[i[f * 3 + 1]]), e.vertex.push(t.vertexPositions[i[f * 3 + 2]]), e.vertex.push(t.vertexPositions[i[p * 3]]), e.vertex.push(t.vertexPositions[i[p * 3 + 1]]), e.vertex.push(t.vertexPositions[i[p * 3 + 2]]), t.skeleton && (e.vertexWeights.push(c[u * 4]), e.vertexWeights.push(c[u * 4 + 1]), e.vertexWeights.push(c[u * 4 + 2]), e.vertexWeights.push(c[u * 4 + 3]), e.vertexWeights.push(c[f * 4]), e.vertexWeights.push(c[f * 4 + 1]), e.vertexWeights.push(c[f * 4 + 2]), e.vertexWeights.push(c[f * 4 + 3]), e.vertexWeights.push(c[p * 4]), e.vertexWeights.push(c[p * 4 + 1]), e.vertexWeights.push(c[p * 4 + 2]), e.vertexWeights.push(c[p * 4 + 3]), e.weightsIndices.push(l[u * 4]), e.weightsIndices.push(l[u * 4 + 1]), e.weightsIndices.push(l[u * 4 + 2]), e.weightsIndices.push(l[u * 4 + 3]), e.weightsIndices.push(l[f * 4]), e.weightsIndices.push(l[f * 4 + 1]), e.weightsIndices.push(l[f * 4 + 2]), e.weightsIndices.push(l[f * 4 + 3]), e.weightsIndices.push(l[p * 4]), e.weightsIndices.push(l[p * 4 + 1]), e.weightsIndices.push(l[p * 4 + 2]), e.weightsIndices.push(l[p * 4 + 3])), t.color && (e.colors.push(a[u * 3]), e.colors.push(a[u * 3 + 1]), e.colors.push(a[u * 3 + 2]), e.colors.push(a[f * 3]), e.colors.push(a[f * 3 + 1]), e.colors.push(a[f * 3 + 2]), e.colors.push(a[p * 3]), e.colors.push(a[p * 3 + 1]), e.colors.push(a[p * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(n), e.materialIndex.push(n), e.materialIndex.push(n)), t.normal && (e.normal.push(r[u * 3]), e.normal.push(r[u * 3 + 1]), e.normal.push(r[u * 3 + 2]), e.normal.push(r[f * 3]), e.normal.push(r[f * 3 + 1]), e.normal.push(r[f * 3 + 2]), e.normal.push(r[p * 3]), e.normal.push(r[p * 3 + 1]), e.normal.push(r[p * 3 + 2])), t.uv && t.uv.forEach(function(m, g) {
            e.uvs[g] === void 0 && (e.uvs[g] = []), e.uvs[g].push(o[g][u * 2]), e.uvs[g].push(o[g][u * 2 + 1]), e.uvs[g].push(o[g][f * 2]), e.uvs[g].push(o[g][f * 2 + 1]), e.uvs[g].push(o[g][p * 2]), e.uvs[g].push(o[g][p * 2 + 1]);
          });
        }
        addMorphTargets(e, t, i, n) {
          if (i.length === 0) return;
          e.morphTargetsRelative = true, e.morphAttributes.position = [];
          const r = this;
          i.forEach(function(a) {
            a.rawTargets.forEach(function(o) {
              const c = Xe.Objects.Geometry[o.geoID];
              c !== void 0 && r.genMorphGeometry(e, t, c, n, o.name);
            });
          });
        }
        genMorphGeometry(e, t, i, n, r) {
          const a = t.Vertices !== void 0 ? t.Vertices.a : [], o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], c = i.Vertices !== void 0 ? i.Vertices.a : [], l = i.Indexes !== void 0 ? i.Indexes.a : [], h = e.attributes.position.count * 3, d = new Float32Array(h);
          for (let m = 0; m < l.length; m++) {
            const g = l[m] * 3;
            d[g] = c[m * 3], d[g + 1] = c[m * 3 + 1], d[g + 2] = c[m * 3 + 2];
          }
          const u = {
            vertexIndices: o,
            vertexPositions: d,
            baseVertexPositions: a
          }, f = this.genBuffers(u), p = new _t(f.vertex, 3);
          p.name = r || i.attrName, p.applyMatrix4(n), e.morphAttributes.position.push(p);
        }
        parseNormals(e) {
          const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.Normals.a;
          let r = [];
          return i === "IndexToDirect" && ("NormalIndex" in e ? r = e.NormalIndex.a : "NormalsIndex" in e && (r = e.NormalsIndex.a)), {
            dataSize: 3,
            buffer: n,
            indices: r,
            mappingType: t,
            referenceType: i
          };
        }
        parseUVs(e) {
          const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.UV.a;
          let r = [];
          return i === "IndexToDirect" && (r = e.UVIndex.a), {
            dataSize: 2,
            buffer: n,
            indices: r,
            mappingType: t,
            referenceType: i
          };
        }
        parseVertexColors(e) {
          const t = e.MappingInformationType, i = e.ReferenceInformationType, n = e.Colors.a;
          let r = [];
          i === "IndexToDirect" && (r = e.ColorIndex.a);
          for (let a = 0, o = new ue(); a < n.length; a += 4) o.fromArray(n, a), ze.toWorkingColorSpace(o, nt), o.toArray(n, a);
          return {
            dataSize: 4,
            buffer: n,
            indices: r,
            mappingType: t,
            referenceType: i
          };
        }
        parseMaterialIndices(e) {
          const t = e.MappingInformationType, i = e.ReferenceInformationType;
          if (t === "NoMappingInformation") return {
            dataSize: 1,
            buffer: [
              0
            ],
            indices: [
              0
            ],
            mappingType: "AllSame",
            referenceType: i
          };
          const n = e.Materials.a, r = [];
          for (let a = 0; a < n.length; ++a) r.push(a);
          return {
            dataSize: 1,
            buffer: n,
            indices: r,
            mappingType: t,
            referenceType: i
          };
        }
        parseNurbsGeometry(e) {
          const t = parseInt(e.Order);
          if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Qt();
          const i = t - 1, n = e.KnotVector.a, r = [], a = e.Points.a;
          for (let d = 0, u = a.length; d < u; d += 4) r.push(new je().fromArray(a, d));
          let o, c;
          if (e.Form === "Closed") r.push(r[0]);
          else if (e.Form === "Periodic") {
            o = i, c = n.length - 1 - o;
            for (let d = 0; d < i; ++d) r.push(r[d]);
          }
          const h = new QL(i, n, r, o, c).getPoints(r.length * 12);
          return new Qt().setFromPoints(h);
        }
      }
      class HL {
        parse() {
          const e = [], t = this.parseClips();
          if (t !== void 0) for (const i in t) {
            const n = t[i], r = this.addClip(n);
            e.push(r);
          }
          return e;
        }
        parseClips() {
          if (Xe.Objects.AnimationCurve === void 0) return;
          const e = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(e);
          const t = this.parseAnimationLayers(e);
          return this.parseAnimStacks(t);
        }
        parseAnimationCurveNodes() {
          const e = Xe.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
          for (const i in e) {
            const n = e[i];
            if (n.attrName.match(/S|R|T|DeformPercent/) !== null) {
              const r = {
                id: n.id,
                attr: n.attrName,
                curves: {}
              };
              t.set(r.id, r);
            }
          }
          return t;
        }
        parseAnimationCurves(e) {
          const t = Xe.Objects.AnimationCurve;
          for (const i in t) {
            const n = {
              id: t[i].id,
              times: t[i].KeyTime.a.map(XL),
              values: t[i].KeyValueFloat.a
            }, r = Pt.get(n.id);
            if (r !== void 0) {
              const a = r.parents[0].ID, o = r.parents[0].relationship;
              o.match(/X/) ? e.get(a).curves.x = n : o.match(/Y/) ? e.get(a).curves.y = n : o.match(/Z/) ? e.get(a).curves.z = n : o.match(/DeformPercent/) && e.has(a) && (e.get(a).curves.morph = n);
            }
          }
        }
        parseAnimationLayers(e) {
          const t = Xe.Objects.AnimationLayer, i = /* @__PURE__ */ new Map();
          for (const n in t) {
            const r = [], a = Pt.get(parseInt(n));
            a !== void 0 && (a.children.forEach(function(c, l) {
              if (e.has(c.ID)) {
                const h = e.get(c.ID);
                if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
                  if (r[l] === void 0) {
                    const d = Pt.get(c.ID).parents.filter(function(u) {
                      return u.relationship !== void 0;
                    })[0].ID;
                    if (d !== void 0) {
                      const u = Xe.Objects.Model[d.toString()];
                      if (u === void 0) {
                        console.warn("THREE.FBXLoader: Encountered a unused curve.", c);
                        return;
                      }
                      const f = {
                        modelName: u.attrName ? tt.sanitizeNodeName(u.attrName) : "",
                        ID: u.id,
                        initialPosition: [
                          0,
                          0,
                          0
                        ],
                        initialRotation: [
                          0,
                          0,
                          0
                        ],
                        initialScale: [
                          1,
                          1,
                          1
                        ]
                      };
                      ui.traverse(function(p) {
                        p.ID === u.id && (f.transform = p.matrix, p.userData.transformData && (f.eulerOrder = p.userData.transformData.eulerOrder));
                      }), f.transform || (f.transform = new ge()), "PreRotation" in u && (f.preRotation = u.PreRotation.value), "PostRotation" in u && (f.postRotation = u.PostRotation.value), r[l] = f;
                    }
                  }
                  r[l] && (r[l][h.attr] = h);
                } else if (h.curves.morph !== void 0) {
                  if (r[l] === void 0) {
                    const d = Pt.get(c.ID).parents.filter(function(A) {
                      return A.relationship !== void 0;
                    })[0].ID, u = Pt.get(d).parents[0].ID, f = Pt.get(u).parents[0].ID, p = Pt.get(f).parents[0].ID, m = Xe.Objects.Model[p], g = {
                      modelName: m.attrName ? tt.sanitizeNodeName(m.attrName) : "",
                      morphName: Xe.Objects.Deformer[d].attrName
                    };
                    r[l] = g;
                  }
                  r[l][h.attr] = h;
                }
              }
            }), i.set(parseInt(n), r));
          }
          return i;
        }
        parseAnimStacks(e) {
          const t = Xe.Objects.AnimationStack, i = {};
          for (const n in t) {
            const r = Pt.get(parseInt(n)).children;
            r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            const a = e.get(r[0].ID);
            i[n] = {
              name: t[n].attrName,
              layer: a
            };
          }
          return i;
        }
        addClip(e) {
          let t = [];
          const i = this;
          return e.layer.forEach(function(n) {
            t = t.concat(i.generateTracks(n));
          }), new vo(e.name, -1, t);
        }
        generateTracks(e) {
          const t = [];
          let i = new T(), n = new T();
          if (e.transform && e.transform.decompose(i, new At(), n), i = i.toArray(), n = n.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
            const r = this.generateVectorTrack(e.modelName, e.T.curves, i, "position");
            r !== void 0 && t.push(r);
          }
          if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
            const r = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
            r !== void 0 && t.push(r);
          }
          if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
            const r = this.generateVectorTrack(e.modelName, e.S.curves, n, "scale");
            r !== void 0 && t.push(r);
          }
          if (e.DeformPercent !== void 0) {
            const r = this.generateMorphTrack(e);
            r !== void 0 && t.push(r);
          }
          return t;
        }
        generateVectorTrack(e, t, i, n) {
          const r = this.getTimesForAllAxes(t), a = this.getKeyframeTrackValues(r, t, i);
          return new mr(e + "." + n, r, a);
        }
        generateRotationTrack(e, t, i, n, r) {
          let a, o;
          if (t.x !== void 0 && t.y !== void 0 && t.z !== void 0) {
            const u = this.interpolateRotations(t.x, t.y, t.z, r);
            a = u[0], o = u[1];
          }
          const c = ra(0);
          i !== void 0 && (i = i.map(Ut.degToRad), i.push(c), i = new Ht().fromArray(i), i = new At().setFromEuler(i)), n !== void 0 && (n = n.map(Ut.degToRad), n.push(c), n = new Ht().fromArray(n), n = new At().setFromEuler(n).invert());
          const l = new At(), h = new Ht(), d = [];
          if (!o || !a) return new Hn(e + ".quaternion", [
            0
          ], [
            0
          ]);
          for (let u = 0; u < o.length; u += 3) h.set(o[u], o[u + 1], o[u + 2], r), l.setFromEuler(h), i !== void 0 && l.premultiply(i), n !== void 0 && l.multiply(n), u > 2 && new At().fromArray(d, (u - 3) / 3 * 4).dot(l) < 0 && l.set(-l.x, -l.y, -l.z, -l.w), l.toArray(d, u / 3 * 4);
          return new Hn(e + ".quaternion", a, d);
        }
        generateMorphTrack(e) {
          const t = e.DeformPercent.curves.morph, i = t.values.map(function(r) {
            return r / 100;
          }), n = ui.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
          return new _r(e.modelName + ".morphTargetInfluences[" + n + "]", t.times, i);
        }
        getTimesForAllAxes(e) {
          let t = [];
          if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(i, n) {
            return i - n;
          }), t.length > 1) {
            let i = 1, n = t[0];
            for (let r = 1; r < t.length; r++) {
              const a = t[r];
              a !== n && (t[i] = a, n = a, i++);
            }
            t = t.slice(0, i);
          }
          return t;
        }
        getKeyframeTrackValues(e, t, i) {
          const n = i, r = [];
          let a = -1, o = -1, c = -1;
          return e.forEach(function(l) {
            if (t.x && (a = t.x.times.indexOf(l)), t.y && (o = t.y.times.indexOf(l)), t.z && (c = t.z.times.indexOf(l)), a !== -1) {
              const h = t.x.values[a];
              r.push(h), n[0] = h;
            } else r.push(n[0]);
            if (o !== -1) {
              const h = t.y.values[o];
              r.push(h), n[1] = h;
            } else r.push(n[1]);
            if (c !== -1) {
              const h = t.z.values[c];
              r.push(h), n[2] = h;
            } else r.push(n[2]);
          }), r;
        }
        interpolateRotations(e, t, i, n) {
          const r = [], a = [];
          r.push(e.times[0]), a.push(Ut.degToRad(e.values[0])), a.push(Ut.degToRad(t.values[0])), a.push(Ut.degToRad(i.values[0]));
          for (let o = 1; o < e.values.length; o++) {
            const c = [
              e.values[o - 1],
              t.values[o - 1],
              i.values[o - 1]
            ];
            if (isNaN(c[0]) || isNaN(c[1]) || isNaN(c[2])) continue;
            const l = c.map(Ut.degToRad), h = [
              e.values[o],
              t.values[o],
              i.values[o]
            ];
            if (isNaN(h[0]) || isNaN(h[1]) || isNaN(h[2])) continue;
            const d = h.map(Ut.degToRad), u = [
              h[0] - c[0],
              h[1] - c[1],
              h[2] - c[2]
            ], f = [
              Math.abs(u[0]),
              Math.abs(u[1]),
              Math.abs(u[2])
            ];
            if (f[0] >= 180 || f[1] >= 180 || f[2] >= 180) {
              const m = Math.max(...f) / 180, g = new Ht(...l, n), A = new Ht(...d, n), x = new At().setFromEuler(g), b = new At().setFromEuler(A);
              x.dot(b) && b.set(-b.x, -b.y, -b.z, -b.w);
              const y = e.times[o - 1], I = e.times[o] - y, M = new At(), R = new Ht();
              for (let D = 0; D < 1; D += 1 / m) M.copy(x.clone().slerp(b.clone(), D)), r.push(y + D * I), R.setFromQuaternion(M, n), a.push(R.x), a.push(R.y), a.push(R.z);
            } else r.push(e.times[o]), a.push(Ut.degToRad(e.values[o])), a.push(Ut.degToRad(t.values[o])), a.push(Ut.degToRad(i.values[o]));
          }
          return [
            r,
            a
          ];
        }
      }
      class VL {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(e) {
          this.nodeStack.push(e), this.currentIndent += 1;
        }
        popStack() {
          this.nodeStack.pop(), this.currentIndent -= 1;
        }
        setCurrentProp(e, t) {
          this.currentProp = e, this.currentPropName = t;
        }
        parse(e) {
          this.currentIndent = 0, this.allNodes = new qA(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
          const t = this, i = e.split(/[\r\n]+/);
          return i.forEach(function(n, r) {
            const a = n.match(/^[\s\t]*;/), o = n.match(/^[\s\t]*$/);
            if (a || o) return;
            const c = n.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), l = n.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = n.match("^\\t{" + (t.currentIndent - 1) + "}}");
            c ? t.parseNodeBegin(n, c) : l ? t.parseNodeProperty(n, l, i[++r]) : h ? t.popStack() : n.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(n);
          }), this.allNodes;
        }
        parseNodeBegin(e, t) {
          const i = t[1].trim().replace(/^"/, "").replace(/"$/, ""), n = t[2].split(",").map(function(c) {
            return c.trim().replace(/^"/, "").replace(/"$/, "");
          }), r = {
            name: i
          }, a = this.parseNodeAttr(n), o = this.getCurrentNode();
          this.currentIndent === 0 ? this.allNodes.add(i, r) : i in o ? (i === "PoseNode" ? o.PoseNode.push(r) : o[i].id !== void 0 && (o[i] = {}, o[i][o[i].id] = o[i]), a.id !== "" && (o[i][a.id] = r)) : typeof a.id == "number" ? (o[i] = {}, o[i][a.id] = r) : i !== "Properties70" && (i === "PoseNode" ? o[i] = [
            r
          ] : o[i] = r), typeof a.id == "number" && (r.id = a.id), a.name !== "" && (r.attrName = a.name), a.type !== "" && (r.attrType = a.type), this.pushStack(r);
        }
        parseNodeAttr(e) {
          let t = e[0];
          e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
          let i = "", n = "";
          return e.length > 1 && (i = e[1].replace(/^(\w+)::/, ""), n = e[2]), {
            id: t,
            name: i,
            type: n
          };
        }
        parseNodeProperty(e, t, i) {
          let n = t[1].replace(/^"/, "").replace(/"$/, "").trim(), r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
          n === "Content" && r === "," && (r = i.replace(/"/g, "").replace(/,$/, "").trim());
          const a = this.getCurrentNode();
          if (a.name === "Properties70") {
            this.parseNodeSpecialProperty(e, n, r);
            return;
          }
          if (n === "C") {
            const c = r.split(",").slice(1), l = parseInt(c[0]), h = parseInt(c[1]);
            let d = r.split(",").slice(3);
            d = d.map(function(u) {
              return u.trim().replace(/^"/, "");
            }), n = "connections", r = [
              l,
              h
            ], KL(r, d), a[n] === void 0 && (a[n] = []);
          }
          n === "Node" && (a.id = r), n in a && Array.isArray(a[n]) ? a[n].push(r) : n !== "a" ? a[n] = r : a.a = r, this.setCurrentProp(a, n), n === "a" && r.slice(-1) !== "," && (a.a = hl(r));
        }
        parseNodePropertyContinued(e) {
          const t = this.getCurrentNode();
          t.a += e, e.slice(-1) !== "," && (t.a = hl(t.a));
        }
        parseNodeSpecialProperty(e, t, i) {
          const n = i.split('",').map(function(h) {
            return h.trim().replace(/^\"/, "").replace(/\s/, "_");
          }), r = n[0], a = n[1], o = n[2], c = n[3];
          let l = n[4];
          switch (a) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              l = parseFloat(l);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              l = hl(l);
              break;
          }
          this.getPrevNode()[r] = {
            type: a,
            type2: o,
            flag: c,
            value: l
          }, this.setCurrentProp(this.getPrevNode(), r);
        }
      }
      class WL {
        parse(e) {
          const t = new kf(e);
          t.skip(23);
          const i = t.getUint32();
          if (i < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + i);
          const n = new qA();
          for (; !this.endOfContent(t); ) {
            const r = this.parseNode(t, i);
            r !== null && n.add(r.name, r);
          }
          return n;
        }
        endOfContent(e) {
          return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
        }
        parseNode(e, t) {
          const i = {}, n = t >= 7500 ? e.getUint64() : e.getUint32(), r = t >= 7500 ? e.getUint64() : e.getUint32();
          t >= 7500 ? e.getUint64() : e.getUint32();
          const a = e.getUint8(), o = e.getString(a);
          if (n === 0) return null;
          const c = [];
          for (let u = 0; u < r; u++) c.push(this.parseProperty(e));
          const l = c.length > 0 ? c[0] : "", h = c.length > 1 ? c[1] : "", d = c.length > 2 ? c[2] : "";
          for (i.singleProperty = r === 1 && e.getOffset() === n; n > e.getOffset(); ) {
            const u = this.parseNode(e, t);
            u !== null && this.parseSubNode(o, i, u);
          }
          return i.propertyList = c, typeof l == "number" && (i.id = l), h !== "" && (i.attrName = h), d !== "" && (i.attrType = d), o !== "" && (i.name = o), i;
        }
        parseSubNode(e, t, i) {
          if (i.singleProperty === true) {
            const n = i.propertyList[0];
            Array.isArray(n) ? (t[i.name] = i, i.a = n) : t[i.name] = n;
          } else if (e === "Connections" && i.name === "C") {
            const n = [];
            i.propertyList.forEach(function(r, a) {
              a !== 0 && n.push(r);
            }), t.connections === void 0 && (t.connections = []), t.connections.push(n);
          } else if (i.name === "Properties70") Object.keys(i).forEach(function(r) {
            t[r] = i[r];
          });
          else if (e === "Properties70" && i.name === "P") {
            let n = i.propertyList[0], r = i.propertyList[1];
            const a = i.propertyList[2], o = i.propertyList[3];
            let c;
            n.indexOf("Lcl ") === 0 && (n = n.replace("Lcl ", "Lcl_")), r.indexOf("Lcl ") === 0 && (r = r.replace("Lcl ", "Lcl_")), r === "Color" || r === "ColorRGB" || r === "Vector" || r === "Vector3D" || r.indexOf("Lcl_") === 0 ? c = [
              i.propertyList[4],
              i.propertyList[5],
              i.propertyList[6]
            ] : c = i.propertyList[4], t[n] = {
              type: r,
              type2: a,
              flag: o,
              value: c
            };
          } else t[i.name] === void 0 ? typeof i.id == "number" ? (t[i.name] = {}, t[i.name][i.id] = i) : t[i.name] = i : i.name === "PoseNode" ? (Array.isArray(t[i.name]) || (t[i.name] = [
            t[i.name]
          ]), t[i.name].push(i)) : t[i.name][i.id] === void 0 && (t[i.name][i.id] = i);
        }
        parseProperty(e) {
          const t = e.getString(1);
          let i;
          switch (t) {
            case "C":
              return e.getBoolean();
            case "D":
              return e.getFloat64();
            case "F":
              return e.getFloat32();
            case "I":
              return e.getInt32();
            case "L":
              return e.getInt64();
            case "R":
              return i = e.getUint32(), e.getArrayBuffer(i);
            case "S":
              return i = e.getUint32(), e.getString(i);
            case "Y":
              return e.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const n = e.getUint32(), r = e.getUint32(), a = e.getUint32();
              if (r === 0) switch (t) {
                case "b":
                case "c":
                  return e.getBooleanArray(n);
                case "d":
                  return e.getFloat64Array(n);
                case "f":
                  return e.getFloat32Array(n);
                case "i":
                  return e.getInt32Array(n);
                case "l":
                  return e.getInt64Array(n);
              }
              const o = TL(new Uint8Array(e.getArrayBuffer(a))), c = new kf(o.buffer);
              switch (t) {
                case "b":
                case "c":
                  return c.getBooleanArray(n);
                case "d":
                  return c.getFloat64Array(n);
                case "f":
                  return c.getFloat32Array(n);
                case "i":
                  return c.getInt32Array(n);
                case "l":
                  return c.getInt64Array(n);
              }
              break;
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + t);
          }
        }
      }
      class kf {
        constructor(e, t) {
          this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : true, this._textDecoder = new TextDecoder();
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(e) {
          this.offset += e;
        }
        getBoolean() {
          return (this.getUint8() & 1) === 1;
        }
        getBooleanArray(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getBoolean());
          return t;
        }
        getUint8() {
          const e = this.dv.getUint8(this.offset);
          return this.offset += 1, e;
        }
        getInt16() {
          const e = this.dv.getInt16(this.offset, this.littleEndian);
          return this.offset += 2, e;
        }
        getInt32() {
          const e = this.dv.getInt32(this.offset, this.littleEndian);
          return this.offset += 4, e;
        }
        getInt32Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getInt32());
          return t;
        }
        getUint32() {
          const e = this.dv.getUint32(this.offset, this.littleEndian);
          return this.offset += 4, e;
        }
        getInt64() {
          let e, t;
          return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
        }
        getInt64Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getInt64());
          return t;
        }
        getUint64() {
          let e, t;
          return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
        }
        getFloat32() {
          const e = this.dv.getFloat32(this.offset, this.littleEndian);
          return this.offset += 4, e;
        }
        getFloat32Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getFloat32());
          return t;
        }
        getFloat64() {
          const e = this.dv.getFloat64(this.offset, this.littleEndian);
          return this.offset += 8, e;
        }
        getFloat64Array(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(this.getFloat64());
          return t;
        }
        getArrayBuffer(e) {
          const t = this.dv.buffer.slice(this.offset, this.offset + e);
          return this.offset += e, t;
        }
        getString(e) {
          const t = this.offset;
          let i = new Uint8Array(this.dv.buffer, t, e);
          this.skip(e);
          const n = i.indexOf(0);
          return n >= 0 && (i = new Uint8Array(this.dv.buffer, t, n)), this._textDecoder.decode(i);
        }
      }
      class qA {
        add(e, t) {
          this[e] = t;
        }
      }
      function jL(s) {
        const e = "Kaydara FBX Binary  \0";
        return s.byteLength >= e.length && e === YA(s, 0, e.length);
      }
      function qL(s) {
        const e = [
          "K",
          "a",
          "y",
          "d",
          "a",
          "r",
          "a",
          "\\",
          "F",
          "B",
          "X",
          "\\",
          "B",
          "i",
          "n",
          "a",
          "r",
          "y",
          "\\",
          "\\"
        ];
        let t = 0;
        function i(n) {
          const r = s[n - 1];
          return s = s.slice(t + n), t++, r;
        }
        for (let n = 0; n < e.length; ++n) if (i(1) === e[n]) return false;
        return true;
      }
      function Uf(s) {
        const e = /FBXVersion: (\d+)/, t = s.match(e);
        if (t) return parseInt(t[1]);
        throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
      }
      function XL(s) {
        return s / 46186158e3;
      }
      const YL = [];
      function to(s, e, t, i) {
        let n;
        switch (i.mappingType) {
          case "ByPolygonVertex":
            n = s;
            break;
          case "ByPolygon":
            n = e;
            break;
          case "ByVertice":
            n = t;
            break;
          case "AllSame":
            n = i.indices[0];
            break;
          default:
            console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType);
        }
        i.referenceType === "IndexToDirect" && (n = i.indices[n]);
        const r = n * i.dataSize, a = r + i.dataSize;
        return JL(YL, i.buffer, r, a);
      }
      const ll = new Ht(), Or = new T();
      function XA(s) {
        const e = new ge(), t = new ge(), i = new ge(), n = new ge(), r = new ge(), a = new ge(), o = new ge(), c = new ge(), l = new ge(), h = new ge(), d = new ge(), u = new ge(), f = s.inheritType ? s.inheritType : 0;
        s.translation && e.setPosition(Or.fromArray(s.translation));
        const p = ra(0);
        if (s.preRotation) {
          const P = s.preRotation.map(Ut.degToRad);
          P.push(p), t.makeRotationFromEuler(ll.fromArray(P));
        }
        if (s.rotation) {
          const P = s.rotation.map(Ut.degToRad);
          P.push(s.eulerOrder || p), i.makeRotationFromEuler(ll.fromArray(P));
        }
        if (s.postRotation) {
          const P = s.postRotation.map(Ut.degToRad);
          P.push(p), n.makeRotationFromEuler(ll.fromArray(P)), n.invert();
        }
        s.scale && r.scale(Or.fromArray(s.scale)), s.scalingOffset && o.setPosition(Or.fromArray(s.scalingOffset)), s.scalingPivot && a.setPosition(Or.fromArray(s.scalingPivot)), s.rotationOffset && c.setPosition(Or.fromArray(s.rotationOffset)), s.rotationPivot && l.setPosition(Or.fromArray(s.rotationPivot)), s.parentMatrixWorld && (d.copy(s.parentMatrix), h.copy(s.parentMatrixWorld));
        const m = t.clone().multiply(i).multiply(n), g = new ge();
        g.extractRotation(h);
        const A = new ge();
        A.copyPosition(h);
        const x = A.clone().invert().multiply(h), b = g.clone().invert().multiply(x), y = r, I = new ge();
        if (f === 0) I.copy(g).multiply(m).multiply(b).multiply(y);
        else if (f === 1) I.copy(g).multiply(b).multiply(m).multiply(y);
        else {
          const j = new ge().scale(new T().setFromMatrixScale(d)).clone().invert(), H = b.clone().multiply(j);
          I.copy(g).multiply(m).multiply(H).multiply(y);
        }
        const M = l.clone().invert(), R = a.clone().invert();
        let D = e.clone().multiply(c).multiply(l).multiply(t).multiply(i).multiply(n).multiply(M).multiply(o).multiply(a).multiply(r).multiply(R);
        const S = new ge().copyPosition(D), E = h.clone().multiply(S);
        return u.copyPosition(E), D = u.clone().multiply(I), D.premultiply(h.invert()), D;
      }
      function ra(s) {
        s = s || 0;
        const e = [
          "ZYX",
          "YZX",
          "XZY",
          "ZXY",
          "YXZ",
          "XYZ"
        ];
        return s === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[s];
      }
      function hl(s) {
        return s.split(",").map(function(t) {
          return parseFloat(t);
        });
      }
      function YA(s, e, t) {
        return e === void 0 && (e = 0), t === void 0 && (t = s.byteLength), new TextDecoder().decode(new Uint8Array(s, e, t));
      }
      function KL(s, e) {
        for (let t = 0, i = s.length, n = e.length; t < n; t++, i++) s[i] = e[t];
      }
      function JL(s, e, t, i) {
        for (let n = t, r = 0; n < i; n++, r++) s[r] = e[n];
        return s;
      }
      class ZL {
        constructor(e) {
          this._animations = e;
        }
        get animations() {
          return this._animations;
        }
      }
      class $L {
        constructor() {
          this._init();
        }
        _init() {
          this._keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            space: false,
            shift: false,
            esc: false,
            action: false,
            limitAreaReachedAct: false,
            limitAreaTurn: false,
            limitAreaWalk: false,
            selfieMode: false,
            thirdPersonCamera: true,
            freeCamera: false,
            actionsAllowed: true
          }, document.addEventListener("keydown", (e) => this._onKeyDown(e), false), document.addEventListener("keyup", (e) => this._onKeyUp(e), false);
        }
        _onKeyDown(e) {
          switch (e.keyCode) {
            case 87:
            case 38:
              this._keys.forward = true;
              break;
            case 65:
            case 37:
              this._keys.left = true;
              break;
            case 83:
            case 40:
              this._keys.backward = true;
              break;
            case 68:
            case 39:
              this._keys.right = true;
              break;
            case 32:
              this._keys.space = true;
              break;
            case 17:
              this._keys.ctrl = true;
              break;
            case 82:
              this._keys.action = true;
              break;
            case 16:
              this._keys.shift = true;
              break;
            case 84:
              this._keys.thirdPersonCamera = true;
              break;
            case 70:
              break;
            case 89:
              this._keys.freeCamera = true;
              break;
            case 27:
              this._keys.esc = true;
              break;
          }
        }
        _onKeyUp(e) {
          switch (e.keyCode) {
            case 87:
            case 38:
              this._keys.forward = false;
              break;
            case 65:
            case 37:
              this._keys.left = false;
              break;
            case 83:
            case 40:
              this._keys.backward = false;
              break;
            case 68:
            case 39:
              this._keys.right = false;
              break;
            case 32:
              this._keys.space = false;
              break;
            case 17:
              this._keys.ctrl = false;
              break;
            case 82:
              this._keys.action = false;
              break;
            case 16:
              this._keys.shift = false;
              break;
            case 84:
              this._keys.thirdPersonCamera = false;
              break;
            case 70:
              break;
            case 89:
              this._keys.freeCamera = false;
              break;
            case 27:
              this._keys.esc = false;
              break;
          }
        }
        set actionsAllowed(e = true) {
          this._keys.actionsAllowed !== e && (this._keys.actionsAllowed = e);
        }
        set limitAreaReachedAct(e) {
          this._keys.limitAreaReachedAct = e;
        }
        get keys() {
          return this._keys;
        }
      }
      class eF {
        constructor(e, t) {
          this.characterHeight = 16, this._loadingManager = t, this._initCharControl(e);
        }
        _initCharControl(e) {
          this._params = e, this._decceleration = new T(-5e-4, -1e-4, -5), this._acceleration = new T(1, 0.25, 50), this._velocity = new T(0, 0, 0), this._position = new T(), this._animations = {}, this.thirdCameraViewEnabled = e.thirdPersonCameraEnabled, this._input = new $L(), this._stateMachine = new AL(new ZL(this._animations), this._input._keys), this._loadModels();
        }
        _loadModels() {
          const e = new OL(this._loadingManager);
          e.load("./models/characters/Big_Vegas.fbx", (t) => {
            t.scale.setScalar(0.1), t.traverse((c) => {
              c.castShadow = true;
            });
            const i = new on().setFromObject(t), n = i.max.y - i.min.y;
            t.userData.height = n, this._target = t, this._params.scene.add(this._target), this._mixer = new rw(this._target);
            const r = this._loadingManager.onLoad;
            this._loadingManager.onLoad = () => {
              r && r(), this._stateMachine && this._stateMachine.setState("idle");
            };
            const a = (c, l) => {
              const h = l.animations[0], d = this._mixer.clipAction(h);
              this._animations[c] = {
                clip: h,
                action: d
              };
            }, o = Zo._jumpStates;
            e.setPath("./models/animations/"), e.load("walk_fwd.fbx", (c) => {
              a("walk_fwd", c);
            }), e.load("walk_bwd.fbx", (c) => {
              a("walk_bwd", c);
            }), e.load("run_fwd.fbx", (c) => {
              a("run_fwd", c);
            }), e.load("run_bwd.fbx", (c) => {
              a("run_bwd", c);
            }), e.load("idle.fbx", (c) => {
              a("idle", c);
            }), e.load("arguing.fbx", (c) => {
              a("end_area", c);
            }), e.load("walk_fwd.fbx", (c) => {
              a("lim_area_walk_fwd", c);
            }), dh.forEach((c) => e.load(c + ".fbx", (l) => {
              a(c, l);
            })), o.forEach((c) => e.load(c + ".fbx", (l) => {
              a(c, l);
            })), uh.forEach((c) => e.load(c + ".fbx", (l) => {
              a(c, l);
            }));
          });
        }
        updateController(e) {
          if (!this._target) return;
          if (this._input._keys.thirdPersonCamera && !this._params.cameraState.thirdPersonCameraEnabled) {
            this._params.enableThirdCameraView();
            return;
          }
          if (this._input._keys.freeCamera && this._params.cameraState.thirdPersonCameraEnabled) {
            this._params.disableThirdCameraView();
            return;
          }
          this._stateMachine.update(e, this._input);
          const t = this._params.characterRigidBody.translation();
          this._target.position.set(t.x, t.y - this.characterHeight / 2, t.z), this._position.copy(this._target.position);
          let i = this._params.characterRigidBody.rotation();
          this._target.quaternion.set(i.x, i.y, i.z, i.w), this._mixer && this._mixer.update(e);
        }
        get position() {
          return this._position;
        }
        get rotation() {
          return this._target ? this._target.quaternion : new At();
        }
      }
      const KA = (s, e, t) => {
        s.freeCameraInstance = new tL(e, t.domElement);
      }, tF = (s, e, t) => {
        KA(s, e, t), s.thirdPersonCameraEnabled = false;
      }, iF = (s) => {
        s.freeCameraInstance._freeCamera.dispose(), s.thirdPersonCameraEnabled = true;
      }, nF = (s, e, t, i, n, r, a) => {
        const o = {
          camera: s,
          scene: e,
          cameraState: t,
          disableThirdCameraView: () => tF(t, s, a),
          enableThirdCameraView: () => iF(t),
          characterRigidBody: r.rigidBody
        }, c = new eF(o, i, n);
        t.thirdPersonCameraInstance = new iL({
          camera: s,
          target: c
        });
        const l = c._input.keys;
        return r.basicController = c, {
          controls: c,
          keys: l
        };
      }, rF = (s, e, t, i = true) => {
        const a = en.RigidBodyDesc.dynamic().setTranslation(t.x, t.y, t.z), o = s.createRigidBody(a), c = en.ColliderDesc.capsule(4, 4);
        c.setRestitution(0.1), c.setMass(500), s.createCollider(c, o);
        const l = s.createCharacterController(0.01), h = {
          rigidBody: o,
          controller: l
        }, d = new Ph(4, 4 * 2, 8, 16), u = new Ei({
          color: 16711680,
          wireframe: true
        }), f = new yt(d, u);
        return i && e.add(f), h.mesh = f, h;
      }, sF = (s) => {
        const t = new Si().load("./noise/perlin_noise.png");
        t.wrapS = t.wrapT = mi;
        const i = [];
        return s.children.forEach((n) => {
          n._forShadersModifiable && n.traverse((r) => {
            r.isMesh && (Array.isArray(r.material) ? r.material : [
              r.material
            ]).forEach((o) => {
              o.isMeshStandardMaterial && (o.onBeforeCompile = (c) => {
                c.uniforms.fogTime = {
                  value: 0
                }, c.uniforms.perlinNoise = {
                  value: t
                }, i.push(c);
              });
            });
          });
        }), i;
      };
      class aF {
        constructor(e) {
          this.scene = e, this.blades = null, this._initRotation(), this.speed = 0.4, this.rotationAngle = 0;
        }
        _initRotation() {
          const e = this.scene.children.find((t) => t.name === "blade");
          if (!e || e.children.length === 0) {
            console.warn("Windmill blades not found!");
            return;
          }
          this.blades = e.children[0];
        }
        updateBlades(e) {
          this.blades && (this.rotationAngle += e * this.speed, this.blades.rotation.y = this.rotationAngle);
        }
      }
      class oF {
        constructor() {
          this.simpleWater = null, this._init();
        }
        _init() {
          const e = new yr(400, 1300, 10, 10), t = new Zi({
            color: 3770313,
            transparent: true,
            opacity: 0.7
          });
          this.simpleWater = new yt(e, t), e.rotateX(as(-90)), e.translate(90, -8, 0);
        }
      }
      class cF {
        constructor(e) {
          __publicField(this, "_addGrass", async (e) => {
            await qx(), this.grassField = new Kx(e), this.grassField.createParticles(), this.scene.add(this.grassField);
          });
          __publicField(this, "_physicsFrameSkip", 2);
          __publicField(this, "_frameCount", 0);
          __publicField(this, "_previousFrame", null);
          __publicField(this, "_fixedTimeStep", 1 / 60);
          this.initSettings = e, this.initSettings.stats && (this.stats = new xP()), this.helpMenu = this.initHelpMenu(), this.LoadingManager = new YP(this.helpMenu).getManager(), this.GLTFLoader = new mA(this.LoadingManager), this.terrain = null, this.cameraState = {
            thirdPersonCameraEnabled: false,
            freeCameraInstance: null,
            thirdPersonCameraInstance: null
          }, this._previousFrame = null, this.grassField = null, this.RAPIER = en, this._eventQueue = new this.RAPIER.EventQueue(true), this.movement = new this.RAPIER.Vector3(0, 0, 0), this.worldPhysics = new this.RAPIER.World(Zc), this.simpleObjects = [], this.keys = {}, this.markersDistanceHandler = null, this._init();
        }
        async _init() {
          this.scene = new ao(), this.camera = new Vt(75, window.innerWidth / window.innerHeight, 1, 1e3), this.camera.position.set(-30, 50, 70), this.renderer = new Dp({
            antialias: true
          }), this.renderer.shadowMap.enabled = true, this.renderer.shadowMap.type = Qf, this.renderer.setSize(window.innerWidth, window.innerHeight), document.body.appendChild(this.renderer.domElement), new XP(this.initSettings.fog, this.scene).addSkyBox(), this.initLighting(), KA(this.cameraState, this.camera, this.renderer), this.riverCurveMesh = this.createRiverCurveMesh(), this.groundMeshToScene = true, this.terrain = await AP(this.GLTFLoader, this.scene, this.groundMeshToScene), await this._loadStructures(), this.initSettings.blades && this._windMillBlades(), this.shaders = sF(this.scene), eL(this.worldPhysics, this.terrain), this.initSettings.grass && this._addGrass(this.terrain), this.initSettings.fog && this.addExpImprovedFog(14674419, 6e-4), this.character = rF(this.worldPhysics, this.scene, $a, false), this._loadAnimatedModel(), this.loadPlayerAreaLimiter(), this.audio = this._initAudio(), this.setInteractions(), this.setVegetation(), this.initSettings.water ? this._addWater() : this._addSimpleWater(), this.setCollidersManually(kA), this.animate();
        }
        _windMillBlades() {
          this.windMill = new aF(this.scene);
        }
        loadPlayerAreaLimiter() {
          this.playerAreaLimiter = new JP(Jc, this.character);
        }
        _loadAnimatedModel() {
          const { controls: e, keys: t } = nF(this.camera, this.scene, this.cameraState, this.LoadingManager, this.GLTFLoader, this.character, this.renderer);
          this.controls = e, this.keys = t;
        }
        initHelpMenu() {
          return new KP(this.initSettings.sounds, this.initSettings.music);
        }
        _initAudio() {
          return new HP(this.initSettings, this.riverCurveMesh, this.camera, this.keys, this.controls._stateMachine, VP, this.scene, this.initSettings.music, this.initSettings.sounds, this.helpMenu);
        }
        setInteractions() {
          this.markersDistanceHandler = new CP(this.character), this.chapterViewer = new GP(this.markersDistanceHandler, this.audio, this.LoadingManager), this.modalMarkers = new SP(this.markersDistanceHandler), this.modalChapter = new IP(this.markersDistanceHandler, this.chapterViewer, this.audio);
        }
        setCollidersManually(e) {
          new vP(this.worldPhysics).createColliders(e);
        }
        initLighting() {
          const e = new Nh(16777215, 0.25);
          this.dirLight = new XD();
          const t = new ow(this.dirLight.dirLight, 5);
          t.visible = false, this.scene.add(t), this.scene.add(e), this.scene.add(this.dirLight.dirLight), this.scene.add(this.dirLight.dirLight.target);
        }
        setVegetation() {
          this.vegetation || (this.vegetation = new gP(this.scene, this.renderer, this.LoadingManager, this.terrain, this.worldPhysics, this.shaders)), this.vegetation.preloadModels(() => {
            this.vegetation.setVegetation();
          });
        }
        addExpImprovedFog(e, t) {
          this._fogController = new KD(this.terrain, this.shaders), this._fogController.fogHuck(), this.scene.fog = new Ch(e, t);
        }
        createRiverCurveMesh() {
          return new WP(this.scene);
        }
        _addWater() {
          new YD(this.scene);
        }
        _addSimpleWater() {
          const e = new oF();
          this.scene.add(e.simpleWater);
        }
        async _loadStructures() {
          await Ms(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/bridges_c.glb", this.scene), await Ms(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/signs_c.glb", this.scene), await Ms(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/structures_no_wind_blade_c.glb", this.scene), await Ms(this.LoadingManager, this.renderer, this.groundMeshToScene, "./map/wind_mill_blade_c.glb", this.scene, {
            x: -147.7,
            y: 77.4,
            z: 398
          }, {
            x: 8,
            y: 8,
            z: 8
          }, {
            x: as(90),
            y: 0,
            z: as(215)
          }, name = "blade");
        }
        _createPlaneGround(e = 100, t = 0.1, i = 100) {
          console.log("Ground Created");
          const n = this.RAPIER.RigidBodyDesc.fixed(), r = this.worldPhysics.createRigidBody(n), a = this.RAPIER.ColliderDesc.cuboid(e, t, i);
          this.worldPhysics.createCollider(a, r);
        }
        _updateCharacterMovement(e) {
          if (!this.character) return;
          const t = this.keys.shift ? 36 : 18, i = 60, n = -100, r = t * e * i;
          this._acceleration = new T(0.25, 0.5, 0.25), this._deceleration = new T(-0.5, -1e-4, -0.5), this._rotationSpeed = 4 * Math.PI * e * this._acceleration.y, this._rotationAxis = new T(0, 1, 0), this.rotation = new At();
          const a = Math.exp(this._deceleration.x * e * i);
          !this.keys.forward && !this.keys.backward && (this.movement.x *= a, this.movement.z *= a), (this.keys.left && this.keys.actionsAllowed || this.keys.right && this.keys.actionsAllowed) && (this.rotation.setFromAxisAngle(this._rotationAxis, this.keys.left ? this._rotationSpeed : -this._rotationSpeed), this.character.mesh.quaternion.multiply(this.rotation));
          let o = new T(0, 0, 1);
          o.applyQuaternion(this.character.mesh.quaternion), o.normalize(), this.keys.backward && this.keys.actionsAllowed && (this.movement.x += (-o.x * r - this.movement.x) * this._acceleration.x, this.movement.z += (-o.z * r - this.movement.z) * this._acceleration.z), this.keys.forward && this.keys.actionsAllowed && (this.movement.x += (o.x * r - this.movement.x) * this._acceleration.x, this.movement.z += (o.z * r - this.movement.z) * this._acceleration.z);
          let c = this.character.rigidBody.linvel();
          c.y += Zc.y * e, this.character.rigidBody.setLinvel(new this.RAPIER.Vector3(this.movement.x, c.y, this.movement.z), true);
          let l = this.character.rigidBody.translation();
          l.y < n && (this.character.rigidBody.setTranslation(new this.RAPIER.Vector3($a.x, $a.y, $a.z), true), this.character.rigidBody.setLinvel(new this.RAPIER.Vector3(0, 0, 0), true)), this.character.mesh.position.set(l.x, l.y, l.z);
          const h = this.character.mesh.quaternion;
          this.character.rigidBody.setRotation(new this.RAPIER.Quaternion(h.x, h.y, h.z, h.w), true);
        }
        _updateCharacterMesh() {
          if (!this.character) return;
          const e = this.character.rigidBody.translation();
          this.character.mesh.position.set(e.x, e.y, e.z);
        }
        _updateLimitedAreaMovement(e) {
          const t = () => {
            const n = this.character.mesh, r = new T();
            n.getWorldPosition(r);
            const a = new T(0, r.y, 0), o = new T().subVectors(a, r).normalize(), c = new At().setFromUnitVectors(new T(0, 0, 1), o);
            n.quaternion.slerp(c, this._rotationSpeed), this.character.rigidBody.setRotation(new this.RAPIER.Quaternion(n.quaternion.x, n.quaternion.y, n.quaternion.z, n.quaternion.w), true), n.quaternion.angleTo(c) < 0.01 && (this.keys.limitAreaTurn = false);
          }, i = () => {
            const a = 20 * e * 60, o = 30;
            let c = new T(0, 0, 1);
            c.applyQuaternion(this.character.mesh.quaternion), c.normalize(), this.movement.x += (c.x * a - this.movement.x) * this._acceleration.x, this.movement.z += (c.z * a - this.movement.z) * this._acceleration.z;
            let l = this.character.rigidBody.linvel();
            l.y += Zc.y * e, this.character.rigidBody.setLinvel(new this.RAPIER.Vector3(this.movement.x, l.y, this.movement.z), true);
            let h = this.character.rigidBody.translation();
            this.character.mesh.position.set(h.x, h.y, h.z);
            const d = this.character.mesh.quaternion;
            this.character.rigidBody.setRotation(new this.RAPIER.Quaternion(d.x, d.y, d.z, d.w), true), Math.abs(h.x) < Jc.maxX - o && Math.abs(h.z) < Jc.maxZ - o && (this.keys.limitAreaWalk = false, this.keys.limitAreaReachedAct = false, this.keys.actionsAllowed = true);
          };
          this.keys.limitAreaTurn && t(), i();
        }
        animate(e = 0) {
          requestAnimationFrame(this.animate.bind(this)), this.stats && this.stats.stats.begin(), this._previousFrame === null && (this._previousFrame = e);
          const t = (e - this._previousFrame) * 1e-3;
          this._previousFrame = e, this._fogController && this._fogController.fogStep(e), this.grassField && this.grassField.update(e), this.renderer.render(this.scene, this.camera), this.step(t), this._frameCount % this._physicsFrameSkip === 0 && (this.keys.limitAreaWalk || this.keys.limitAreaTurn ? this._updateLimitedAreaMovement(t) : this._updateCharacterMovement(t), this.windMill && this.windMill.updateBlades(t), this.playerAreaLimiter.update(), this.markersDistanceHandler && (this.markersDistanceHandler.updateCharPositionDistance(), this.modalMarkers.updateMarkerModalStatus()), this.controls && this.dirLight && this.dirLight.updateDirLightPosition(this.controls.position), this.worldPhysics.step(this._eventQueue, this._fixedTimeStep), this.audio && this.audio.updateSoundsState(), this.simpleObjects.forEach((i) => {
            const n = i.rigidBody.translation();
            i.mesh.position.set(n.x, n.y, n.z);
          })), this._frameCount++, this.stats && this.stats.stats.end();
        }
        step(e) {
          this.controls && this.controls.updateController(e), this.cameraState.thirdPersonCameraEnabled && this.cameraState.thirdPersonCameraInstance._update(e);
        }
      }
      class lF {
        constructor(e) {
          this._config = document.getElementById("config"), this._features = document.querySelector(".c-main__features"), this._lowPCBtn = document.querySelector(".c-main__lowPC-button"), this._startBtn = document.querySelector(".c-footer__start-btn"), this.settings = {
            fog: false,
            water: false,
            grass: false,
            sounds: false,
            music: false,
            stats: false,
            blades: false
          }, this.Game = e, this._init();
        }
        _init() {
          this._startBtn.addEventListener("click", (e) => {
            this._getSettings(), this._config.classList.add("config-hide"), this.Game && new this.Game(this.settings);
          }), this._lowPCBtn.addEventListener("click", (e) => {
            e.target.classList.toggle("active"), e.target.classList.contains("active") ? this._setCheckBoxes(false) : this._setCheckBoxes(true);
          });
        }
        _getSettings() {
          Array.from(this._features.children).forEach((e) => {
            const t = e.children[0];
            this.settings[t.value] = t.checked;
          });
        }
        _setCheckBoxes(e) {
          Array.from(this._features.children).forEach((t) => {
            const i = t.children[0];
            i.checked = e;
          });
        }
      }
      new lF(cF);
    })();
  }
});
export default require_stdin();
